select username, osuser, program, sid, serial# from v$session
select * from v$session where osuser = 'panfilov_ms'
select * from v$session where osuser = 'stepanenko_rb'
alter system kill session '122, 10899' 
alter system kill session '128, 20624'
select * from obj where status = 'INVALID'

MAKEBILLEVERYDAY_TCB

od.CREATEDEALDEPOSITHIST

begin
compileall;
end;

od.BILL_TCB
od.TAX_ATTRIBUTES
od.DEALCREATEDOCBYSCHEMACC

SELECT * FROM sys.aud$ WHERE obj$name = 'BBR_TCB_BILL_DEAL_LIST' 
BIC_DIR_LOAD
select * from filial

select * from VersionScript where schemename = 'DEAL'
select * from VersionScript where schemename = 'BILL'
select * from VersionScript where schemename = 'PAYS'
select * from VersionScript where schemename = 'GENA'
select * from VersionScript where schemename = 'SHAR'
select * from VersionScript where schemename = 'UNIV'
select * from VersionScript where schemename = 'DTRS'
select * from VersionScript where schemename = 'TRD'
select * from VersionScript where schemename = 'RDEA'
select * from VersionScript where schemename = 'GUID'
DPC_EDITGENERALACCTREE


----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
---- задача 2741                                                                                                                                    --
--- БАЗА: diling - база затерта в июне 2013
----------------------------------------------------------------------------------

-- добавить по новым типам (объекты SaleCurrencyBC и SaleCurrency) конверсии                                 +++
-- добавить по новым типам доп.атрибуты insertы ниже                                                         
-- включить новые типы документов в услугу 9.1                                                               +++
-- включить новые типы документов в список контроля валютного дня                                            +++
-- привязать процедуры DPC_TCB_IBANK_SET_STATUS_? на переходы по состояниям к SaleCurrencyBC                 +++
-- сверить операции по состояниям (2 удалить, 1 добавить)                                                    
-- добавить права (для Супервизора!!!) на операцию "Сохранить"                                               +++

----------------------------------------------------------------------------------
--- настройки от 27/11/2012 ---                                                                                                                     ++                                                                                                           
-- сделать новый тип документа "Курс Индивидуальный"                                                                                                ++
-- добавить в таблице курсов "Курс ETC" соотношение валют USD/EUR (в арх. дате 01/11/2012)                                                          ++ 
-- сделать новую таблицу курсов "Курс Индивидуальный" с соотношениями валют RUR/EUR USD/EUR RUR/USD (в арх. дате 01/11/2012)                        ++
-- в схеме канверсии "Конв. по схеме "Индивидуальный курс"" добавить параметры с новой таблицей курсов обмена (в арх. дате 01/11/2012)              ++
-- сделать в 16/11/2012 документы по смене курса для курса ЕТС и Индивидуального с единичными курсами                                               ++
-- убрать схему конверсии "Остальные конверсионные операции" с документов Пок/Прод валюты                                                           ++
----------------------------------------------------------------------------------

-- для класса "Покупки/продажи валют" (Category41) и дочерних классов удалить все операции для состояния "Доступен в работе"                                        ++
-- для класса "Покупки/продажи валют" (Category41) и дочерних классов поправить все переходы в/из состояния "Доступен в работе"                                     ++
-- для класса "Покупки/продажи валют" (Category41) переименовать операцию "В работу" на "Депонировать"                                                              ++
-- для класса "Покупки/продажи валют" (Category41) для операции "Депонировать" в конец списка действий добавить процедуры DPC_CancelPlanDoc, DPC_PROCESSLINKOBJECT, DPC_SetUnEdit ++
-- для класса "Покупки/продажи валют" (Category41) для действия "Открыть" в обработке связанных объектов сделать дополнительно
-- "Открыть" и "Исполнить"  "Незавершенные дочерние документы" "" (состояния "Создан" и "Доступен в работе")                                      ++ 
-- для класса "Покупки/продажи валют" (Category41) удалить операции "Вернуть в работу", "Исполнить" и "Сохранить" под состоянием "Депонирование"                    ++
-- для класса "Покупки/продажи валют" (Category41) переименовать состояние "Приостановлен" в "Отклонен"                                                             ++
-- для класса "Покупки/продажи валют" (Category41) добавить состояние "Казначейство"                                                                                ++   
-- для класса "Покупки/продажи валют" (Category41) добавить операцию "В казначейство" (Родитель = Ввести Курс) под состоянием "Депонирование"                       ++
-- для класса "Покупки/продажи валют" (Category41) дать права на операцию "В казначейство" для Супервизора, Бухгалтера и Операциониста валютного ДО                 +?
-- для класса "Покупки/продажи валют" (Category41) сделать два SQL-условия "Схема конв. "Стандартный курс"" и "Схема конв. "Курс ЕТС" или "Индивидуальный курс"":   ++ 
-- для класса "Покупки/продажи валют" (Category41) сделать два перехода по состояниям "Депонирование" -> "Казначейство" и "Депонирование" -> "Доступен в работе"
-- с SQL-условиями "Схема конв. "Стандартный курс"" и "Схема конв. "Курс ЕТС" или "Индивидуальный курс"":                                                           ++ 
----------------------------------------------------------------------------------
declare 
  
nValue  dt.Status; 

begin 
   
select count(convvariant) into nValue from bankoperconversion 
where doc = context.CurrentDoc and convvariant = 1072054772;
if nValue = 1 then 
      
:nCondResult := 1; 
   
else 
      
:nCondResult := 0; 
   
end if; 

end; 
----------------------------------------------------------------------------------
declare 
  
nValue  dt.Status; 

begin 
   
select count(convvariant) into nValue from bankoperconversion 
where doc = context.CurrentDoc and convvariant in (1072055651,1072056098);
if nValue = 1 then 
      
:nCondResult := 1; 
   
else 
      
:nCondResult := 0; 
   
end if; 

end; 
----------------------------------------------------------------------------------
-- для класса "Покупки/продажи валют" (Category41) сделать привязку экрана FRMBASERATE к состоянию "В Казначейство"                                                 ++
-- сделать допописание "Время заявки на конверсию" (Константа -1360 Теги <SIZE=3.5> Шаблон @G99\:99) и привязать к типам документов (SaleCurrencyBC и SaleCurrency) ++
-- для класса "Покупки/продажи валют" (Category41) сделать dpc-процедуру DPC_IsTrueFormatTime_TCB и повесить её на действие "Редактировать"                         ++
create or replace procedure DPC_IsTrueFormatTime_TCB
--------------------------------------------------------------------------------
-- Назначение: Проверка формата времени заявки на конверсию
-- Версия от : 01/11/2012 Панфилов М.С.
--------------------------------------------------------------------------------
as
  dTime  date; 
begin 
select to_date(nvl(get(context.CurrentDoc,DescClass(-1360)),'00:00'),'hh24:mi') into dTime from dual; 
exception when others then 
  raise_application_error(-20000,
    'Некорректное время заявки на конверсию!'); 
end DPC_IsTrueFormatTime_TCB;
----------------------------------------------------------------------------------
-- для класса "Покупки/продажи валют" (Category41) добавить операцию "В ДВР" (с одной процедурой DPC_DocChangeState) под состоянием "Казначейство"                  ++
-- для класса "Покупки/продажи валют" (Category41) сделать переход по состояниям "Казначейство" -> "Доступен в работе"                                              ++
-- для класса "Покупки/продажи валют" (Category41) дать права на операцию "В ДВР" для Супервизора и Операциониста валютного ДО                                      ++
-- для класса "Покупки/продажи валют" (Category41) добавить состояния "День 1" и "День 2"                                                                           ++
-- для класса "Биржевые операции" для действия "Обработать до" отключить три процедуры (DPC_Draw_IT, DPC_FromClientAcc_IT, DPC_ReturnReserv) чтобы не порождались проводки  ++
-- для класса "Покупки/продажи валют" (Category41) изменить состояние "Доступен в работе" (привязать родителя "Ввод курса" -> удалить операции "Сохранить" и "Отбраковать") ++
-- для класса "Покупки/продажи валют" (Category41) удалить обработку всех связанных объектов для действия "Исполнить"                                               ++ 
-- для класса "Покупки/продажи валют" (Category41) для состояния "Доступен в работе" удалить операцию "Исполнить" и сделать новую операцию "В День 1"
--(с процедурами DPC_DOCCHECKOPERDATE, DPC_BUYDATECHECK с условием "Дата валютирования сегодня", DPC_Draw_IT с условием "Дата валютирования сегодня", 
-- DPC_Convert_IT(знач. параметра = "нет") с условием "Дата валютирования сегодня", DPC_ENROLL_IT(знач. параметра = "нет") с условием "Дата валютирования сегодня", 
-- DPC_ReturnReserv с условием "Дата валютирования сегодня", DPC_BegAgreement с условием "Дата валютирования след. рабочий день", 
-- DPC_SendMoney_tcb с условием "Дата валютирования сегодня", DPC_PROCESSLINKOBJECT с условием "Дата валютирования след. рабочий день", DPC_DocChangeState)
-- дать права для Супервизора, Бухгалтера и Операциониста валютного ДО                                                                                              ++ 
-- для класса "Покупки/продажи валют" (Category41) удалить переход по состояниям "Доступен в работе" -> "Исполнить"                                                 ++
-- для класса "Покупки/продажи валют" (Category41) сделать два перехода по состояниям "Доступен в работе" -> "День 1" и "Доступен в работе" -> "День 2"
-- с SQL-условиями "Дата валютирования сегодня" и "Дата валютирования след. рабочий день"                                                             ++
-- для класса "Покупки/продажи валют" (Category41) дать права на операцию "В День 1" и "Удалить" для Супервизора и Операциониста валютного ДО                       ++
-- для класса "Покупки/продажи валют" (Category41) сделать привязку экрана FRMBASERATE к состояниям "В День 1" и "В День 2"                                         ++ 
----------------------------------------------------------------------------------
declare
nValue  dt.Status;
begin
select count(classified) into nValue from doctree 
where classified = context.CurrentDoc and trunc(validtodate) = trunc(context.OperDate);
if nValue = 1 then 
:nCondResult := 1; 
else 
:nCondResult := 0; 
end if; 
end;
----------------------------------------------------------------------------------
declare 
nValue  dt.Status; 
begin
select count(classified) into nValue from doctree 
where classified = context.CurrentDoc and trunc(validtodate) = trunc(aftworkday(context.OperDate));
if nValue = 1 then
:nCondResult := 1;
else
:nCondResult := 0;
end if;
end;
----------------------------------------------------------------------------------
-- для класса "Покупки/продажи валют" (Category41) для состояния "День 1" сделать операцию "Удалить" и дать права для Супервизора, Бухгалтера и Операциониста валютного ДО  ++
-- для класса "Покупки/продажи валют" (Category41) сделать переход по состояниям "День 1" -> "Удален"                                                               ++
-- для класса "Покупки/продажи валют" (Category41) для состояния "День 2" сделать операцию "Удалить" и дать права для Супервизора, Бухгалтера и Операциониста валютного ДО  ++
-- для класса "Покупки/продажи валют" (Category41) сделать переход по состояниям "День 2" -> "Удален"                                                               ++
-- для класса "Покупки/продажи валют" (Category41) для операции "Депонировать" добавить до основных действий родительского обработчика
-- процедуру DPC_OnCheckDateCurrency с условием "Дата валютирования след. рабочий день"                                                                             ++
-- для класса "Биржевые операции" для действия "Открыть" отключить процедуру (DPC_BegAgreement)                                                                     ++
-- для класса "Покупки/продажи валют" (Category41) для состояния "Доступен в работе" добавить порождение дочерних документов 
-- класса "Перевод по срочным счетам" с причиной "Открытие срочных сделок"                                                                                          ++
-- для класса "Покупки/продажи валют" (Category41) для состояния "День 1" добавить порождение дочерних документов 
-- класса "Перевод по срочным счетам" с причиной "Закрытие срочных сделок"                                                                                          ++
-- для класса "Покупки/продажи валют" (Category41) для действия "В День 1" в обработке связанных объектов сделать дополнительно
-- "Открыть" и "Исполнить" "Незавершенные дочерние документы" "Перевод по срочным счетам"                                                                           ++
-- для класса "Покупки/продажи валют" (Category41) сделать операцию "В День 2" (с процедурами DPC_DOCCHECKOPERDATE, DPC_BUYDATECHECK, DPC_Draw_IT, 
-- DPC_Convert_IT(знач. параметра = "нет"), DPC_ENROLL_IT(знач. параметра = "нет"), DPC_ReturnReserv, DPC_EndAgreement, DPC_SendMoney_tcb, DPC_PROCESSLINKOBJECT, DPC_DocChangeState)
-- под состоянием "День 1" и дать права для Супервизора, Бухгалтера и Операциониста валютного ДО                                                                    ++
-- для класса "Покупки/продажи валют" (Category41) сделать переход по состояниям "День 1" -> "День 2"                                                               ++
-- для класса "Покупки/продажи валют" (Category41) для действия "В День 2" в обработке связанных объектов сделать дополнительно
-- "Открыть" и "Исполнить" "Незавершенные дочерние документы" "Перевод по срочным счетам"                                                                           ++
-- для класса "Покупки/продажи валют" (Category41) для состояния "Доступен в работе" добавить порождение дочерних документов 
-- класса "Внутренний перевод" с причиной "Другие платежи" (удалить аналогичное порождение с класса "Пок/продажа вал по поручению кл по курсу банка")               ++
-- для класса "Покупки/продажи валют" (Category41) для состояния "День 2" сделать операцию "Исполнить" (действие = "Исполнить") (с одной процедурой DPC_PROCESSLINKOBJECT)
-- и дать права для Супервизора, Бухгалтера и Операциониста валютного ДО                                                                                            ++
-- для класса "Покупки/продажи валют" (Category41) для действия "Исполнить" в обработке связанных объектов сделать
-- "Открыть" и "Исполнить" "Незавершенные дочерние документы" "Внутренний перевод" ("Создан" и "Доступен в работе")                                                 ++                                                                           ++
-- для класса "Покупки/продажи валют" (Category41) сделать переход по состояниям "День 2" -> "Исполнен"                                                             ++
-- для класса "Биржевые операции" для действия "Исполнить" отключить все процедуры, порождающие проводки (DPC_Draw_IT, DPC_Convert_IT, DPC_ENROLL_IT, DPC_ReturnReserv,
-- DPC_SendMoney_tcb)                                                                                                                                               ++




-- продумать механизм обмена с RN и утверждения курсов (тесты diling <-> RNTEST8)                                                                                   --
--- отправка сделки в RN:                                                                                                                                           +-                                                                            
----- поправить od.bus_obj.get_conv, чтобы можно было отправлять в RN покупки/продажи валюты с разными схемами конверсии, передача времени заявки и комментария через поле operday_status_name    ++                                                                                        
----- продумать момент, если в RN конверсия не закачалась (напр. контрагент в RN отсутствует)                                                                       --
------ написать триггер на tcb_crc32, чтобы анализировал ответ из RN и откатывал непринятую в RN сделку                                                             --
------ пока не прийдёт ответ из RN конверсия должна быть недоступна для редактирования                                                                              --
------ написать отчет по F6 для чтения ошибки                                                                                                                       --
--- возврат сделки из RN:                                                                                                                                           --
----
--- запретить удалять в Афине покупки/продажи в состояниях "Казначейство" и выше (или продумать механизм отката в RN)                                               --
--- для класса "Покупки/продажи валют" (Category41) удалить операцию "Выгрузка конверсий в RN"                                                                      --
--- сделать новую процедуру типа "Выгрузка конверсий в RN", повесить на нужный переход                                                                              --
od.DPC_TCB_CONVUNLOAD
od.dpc_convert_it
od.bus_obj
select * from tcb_crc32 where dealtype = 'CONV'
select * from od.bankoperconversion where doc = 182067529
update od.bankoperconversion set sumto = sumfrom*42, truerate = 42, exchangerate = 42, isspecial = 1 where doc = 182067529

select * from tcb_crc32 where dtsend > sysdate - 1

select * from od.tcb_fx
select * from doccategory
select * from od.convvariant where classified in (1072054772,1072055651,1072056098)  -- станд. - етс - инд.

select * from doctree where classified = 182075188
select * from bankoperconversion where doc = 182075188



-- привязать процедуры DPC_TCB_IBANK_SET_STATUS_? на переходы по состояниям к SaleCurrencyBC                                                                        --
-- список дополнительных данных для загрузки из БК:                                                                                                                 --
---- время заявки на конверсию                                                                                                                                      --
---- схема конверсии (Станд., ЕТС, Инд.)                                                                                                                            --
---- ?????????????????????????????
-- на операцию "Депонировать" нужно повесить новую процедуру, которая апдейтила бы дату валютирования в зависимости от схемы конверсии и времени заявки             --
-- также наверное нужно выгружать из БК в Афину комментарий                                                                                                         --




-- продумать механизм АВТОГЕНЕРАЦИИ срочных счетов                                                                                                                  ??

-- как подтягивать транзитные счета и счет получателя в платежные реквизиты?                                                                                        ??

-- сделать запрет на редактирование (удаление) внутренних переводов по конверсии, у которых есть родитель класса "Покупки/продажи валют" (Category41)               ??                                                                      



-- переименовать операцию "Приостановить" в "Отклонить"                                                      -+
-- добавить удаление всех дочерних документов на действие "Приостановить"                                    -+
-- добавить операцию "Удалить" на состояние "Отклонен"                                                       -+                                                 


-- добавить права (для Супервизора!!!) на все новые операции                                                 -+
-- привязать процедуру DPC_DocChangeState (и DPC_PROCESSLINKOBJECT) на все новые операции, где есть смены состояний                         -+ 
-- проверить все переходы                                                                                                                   --  
-- привязать на все новые состояния экран "Покупка/продажа валюты"                                                                          -+
    
-- запретить смену курса для операциониста 

-- проблемы:
-- 1. курс ETC (как и любой другой) сейчас невозможно сделать неустановленным


----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--29/10/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 35015457
select * from doctype where classified = 1000133055

select * from objprop where obj = 35015457

select * from proplist where classified in (1000002563,1000002566,1003644477,1052547452,1166489815)

INSERT INTO ObjAssoc
 VALUE( SELECT NULL, 25, 1119545402, NULL, assoc, NULL, 1, NULL, TO_DATE('01.01.1980', 'dd.mm.yyyy'), TO_DATE('01.01.4444', 'dd.mm.yyyy') FROM ObjAssoc WHERE obj = 1011966162)

INSERT INTO ObjAssoc
 VALUE( SELECT NULL, 25, 1119545250, NULL, assoc, NULL, 1, NULL, TO_DATE('01.01.1980', 'dd.mm.yyyy'), TO_DATE('01.01.4444', 'dd.mm.yyyy') FROM ObjAssoc WHERE obj = 1011980756)         
      
od.setreplyprop
od.objattr

select * from tcb_crc32 

od.TCB_BUS_PREPFOROTHERSYSTEMS


bill

----------------------------------------------------------------------------------
--30/10/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.makebilleveryday_tcb

select od.Pref.OurBank() from dual

select * from bill where classified = 1179391202

----------------------------------------------------------------------------------
-- убрал права на все операции для класса "Депозитарный перевод" (Category1014) и дочерних, чтобы пользовались только "Мемордерами ДЕПО"                ++
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--31/10/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

BBR_DOC_SWIFT

select * from CUROPERMAIN where doc in (select classified from doctree where category = 41) 
and clientdate is not null and executedate is not null and clientdate != executedate 
order by clientdate desc

select * from doctree where classified = 159394406

od.DPC_EditCurOper

select * from billaccintention where classified = 1190738041 -- 1065910892

select* from od.bill 

----------------------------------------------------------------------------------
--02/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.DPC_BillOper
OD.CU_BILLACCOUNT_UNIQUE

select * from bill where num = '0022659'
select * from sysfilial where

----------------------------------------------------------------------------------
--06/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------


select * from bill where num = '60294'
select * from billoper where bill = 1066421348
select * from syscertificate where classified = 1044189132

od.DPC_IntTransLimit

od.DPC_ControlAccountMOUS

----------------------------------------------------------------------------------
--08/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_EndAgreement

od.DPC_TCB_CONVUNLOAD


select * from conversion where doc = 182066886
select * from bankoperconversion where doc = 182066886



declare
nCode varchar(50);

BEGIN
SELECT max(bc.code)
  INTO ncode
  FROM bankcode bc
      ,dealnetting     d
 WHERE d.doc = CONTEXT.currentdoc
   AND d.counterparty = bc.client
   AND bc.codesystem = 1000104502
  AND nvl(bc.validtodate,max_date) > CONTEXT.OperDate;

IF ncode in ('NCCB', 'CSBN', 'INTF')  THEN
  :ncondresult := 1;
ELSE
  :ncondresult := 0;
END IF;
END;

SELECT 'Роснефть' --INTO ncode
  FROM dealnetting d
 WHERE d.doc = 19280925
 AND counterparty = 95401892 --95401892 --CONTEXT.currentdoc


select * from tcb_crc32 where classified = 192675147

----------------------------------------------------------------------------------
--08/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- форматировал отчет bbr.BBR_TCB_BILLDISC_DEAL_LIST по задаче IPI 113596                                                                                         ++ 
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--12/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from od.ACCESSOPERATION where accessgroup = 1099459304

select * from od.accessgroup
select (select label from entityclass where classified = eo.entityclass), eo.* from entityoperation eo where classified in (select entityoperation from od.ACCESSOPERATION where accessgroup = 1099459304)


select * from entityclass where classified = eo.classified

BBR_TCB_BILLOWN_MFSO_REP_NEW

----------------------------------------------------------------------------------
--15/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--16/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.tcb_bki_mbk_proc

od.DPC_FILLDEALDEPINTEREST 

select * from DealDeposit where Doc = 193890970

select distinct P.Classified, P.PaymentLine, I.StartDate
              bulk collect into idaPayPeriod, idaPaymentLine, dtaStartDate
              from DealSwapPayPeriod P, DealSwapInterest I
             where I.Doc = idDoc
               and P.InterestPeriod = I.Classified
               and I.StartDate >= dtStartDate
             order by I.StartDate asc;

select * from DealSwapPayPeriod
select * from DealSwapInterest

----------------------------------------------------------------------------------
--21/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- переименовал группы векселей и выпуски ц.б. в Питере на "НЕ ИСП!!!", оставил с нормальным названием только одну, чтобы не путались                      ++ 
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billgroup

select * from bill where billgroup = 1102764675

select * from bill where num = '0019181'

select * from syscertificate where classified in (1194114740, 1194136086)

----------------------------------------------------------------------------------
--22/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from portfolioaccount

od.MAKEBILLACCRUAL
bill_p.PercentSum

----------------------------------------------------------------------------------
--27/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- правил od.dpc_tcb_set_deal_purpose                                                                                                                      ++
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
od.dpc_tcb_set_deal_purpose   

select * from doccategory
od.bus_obj

select * from doctree where classified = 194418232
select * from doctree where classified = 195079925
update doctree set parent = 195079925 where classified = 194418232

----------------------------------------------------------------------------------
--29/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.CreatePercentAccountDoc
od.UT_DEALACCRUAL

select
DECODE(d.CATEGORY,41, com.clientdate || ' ' || ObjAttr.GetOneDesc(d.Classified,ObjAttr.DescClass(-1360)) || ' ' || d.description,'Бэк офис') AS operday_status_name -- ds.label -- 28/11/2012 Панфилов М.С. для 41 категории отправляем информацию о времени заявки и комментарий
                                        
  FROM bankoperconversion bop,
       doctree d,
       currency crb,
       currency crs,
       docstate ds,
       curopermain com/*,
       tcb_crc32 c*/
 WHERE d.classified = 182075202
  /* AND c.idpocket = p_id*/
   AND bop.doc = d.classified
   AND bop.currencyfrom = crb.classified
   AND bop.currencyto = crs.classified
   AND d.docstate = ds.classified
   AND com.doc(+) = d.classified
   
   
   
   od.GetBillAccount
   
   nCompetitorType = 1000001779
nIsResident = 
nDepartment = 1034506732
nIntention = 1065910892
nCurrency = 1000001275



select * --Account, Department
                       from BillAccount
                      where AccIntention = 1065910892 and Bill is null and BillGroup is null
                        and Currency = 1000001275
                      --  and (Department = 1034506732 or Department is null)
                      --  and nvl(IsResident, -1) = -1
                      --  and nvl(CompetitorType, 0) = nvl(1000001779, 0)
                      order by Department 
                      loop
                      
                      select * from account where classified in (37267896,56047566,103640227,107766979,107764219,183711210)
                      
                      select * from sysfilial

----------------------------------------------------------------------------------
--30/11/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select 0.101*(1500000000*((30-16)/366)) from dual
select 0.101*(1500000000*((94)/366)) from dual
select 0.101*(1500000000*(((14+31)/366)+((94-45)/365))) from dual


select (38965405.34*((30-16)/94)) from dual
select (38965405.34*((30-16)/94)) from dual

select to_date('18.02.2013','dd.mm.yyyy') - to_date('16.11.2012','dd.mm.yyyy') from dual

select * from account where code = '31308810301000010000'
select * from accountwithreestr where account = 193966878
select * from reestr where accountwithreestr = 1193530446
od.CreatePercentAccountDoc 
select * from DealSwapPayPeriod where doc = 193953201

select * from billaccintention 
update billaccintention set iscompetitortype = 0 where classified in (1065910874, 1065910892)

----------------------------------------------------------------------------------
-- update doctree set parent = 195603649 where classified = 195237049  -- Бакумцева поздно заметила что у по БЫСТРОБАНКУ изменилась категория качества на первую, пришлось переподвязать счет резерва под предыдущую сделку в цепочке пролонгаций  ++
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--03/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- delete from billaccount where bill in (select classified from bill where num in ('0028518','0028519','0028520')) and accintention = 1011996332 -- удалил для Питера


select * from billaccintention where classified = 1011996332 


----------------------------------------------------------------------------------
--05/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billoper

select * from bill b where b.repaydate is not null

-- повесил на действие оплатить DPC_BillFactPayDate для Переучета и Погашения векселя по задаче IPI 116104                                                      ++
-- написать глобальный update                                                                                                                                   ++
select * from bill where status in (4,46,8)
(
select dt.classified, dt.operdate, bl.repaydate, bl.* from bill bl, doctree dt, billoper bo, billrange br, doctype dty
where dt.classified=bo.doc
            and   dt.doctype=dty.classified
            and   bo.doc = br.doc
            and   br.bill = bl.classified
            and   bl.status in (4,46,8)
            and   dt.docstate=1000000035
            and   dty.category in (703,712,714)
            and   dt.operdate >= to_date('01012012','ddmmyyyy')
            )

/*
declare
begin
  for rec in (select dt.classified, dt.operdate, bl.repaydate, bl.classified billcl from bill bl, doctree dt, billoper bo, billrange br, doctype dty
where dt.classified=bo.doc
            and   dt.doctype=dty.classified
            and   bo.doc = br.doc
            and   br.bill = bl.classified
            and   bl.status in (4,46,8)
            and   dt.docstate=1000000035
            and   dty.category in (703,712,714)
            and   dt.operdate >= to_date('01012012','ddmmyyyy')) loop

update bill b set repaydate = rec.operdate where classified = rec.billcl ;

      end loop;
end;*/


----------------------------------------------------------------------------------
--06/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

update doctree set parent = null where classified in (select classified from account where code like '31309810803340280000')

select * from billaccount where bill in (select classified from bill where num = '0304275')
select * from account where classified = 110611240

od.Dpc_Billoper
od.getbillaccount

select * from account where code like '47408810500100000014'

-- delete  from billaccount where account = 196555681 -- у Крендель в Перми заглючил учет векселя - подтягивался счет 47408 вместо 47407 -> пришлось зачистить pact по векселю

select * from doctree where classified = 196555661
select * from doctype where classified = 1065660049

select  from billoper b where doc = 217537503
select * from billaccount where account in (select classified from account where code = '47408810700100000018')
update billaccount set pact = null where account in (select classified from account where code = '47408810700100000018')
----------------------------------------------------------------------------------
--07/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.BIC_DIR_LOAD_CCH_TCB

--тестирование собственного загрузчика в Афину справочника SWIFT CCH--------------
CREATE TABLE "OD"."BIC_DIR_LOAD_CCH_TCB" 
   (	"ROWDATA" VARCHAR2(2000)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT)
  TABLESPACE "USERS" ;
   COMMENT ON COLUMN "OD"."BIC_DIR_LOAD_CCH_TCB"."ROWDATA" IS 'Строка справочника BIC Directory/BIC Plus Directory CCH';
  GRANT SELECT ON "OD"."BIC_DIR_LOAD_CCH_TCB" TO "REPORT";
  GRANT INSERT ON "OD"."BIC_DIR_LOAD_CCH_TCB" TO "TELLER";
  GRANT DELETE ON "OD"."BIC_DIR_LOAD_CCH_TCB" TO "TELLER";
  GRANT SELECT ON "OD"."BIC_DIR_LOAD_CCH_TCB" TO "TELLER";

create or replace procedure SRP_LoadBicDirectory_CCH_TCB
-- -----------------------------------------------------------------------------
-- Описание: Закачка справочника BICDirectory (только Holidays)
-- Автор: Данилов О.В.
-- Версия от 01/02/2007
-- Версия от 02/05/2007 - Поддержка справочника с фиксированной длиной полей
-- Версия от 20/05/2007 - Сделана "оболочечной" для обработки различных типов справочников
-- Версия от 05/02/2008 - Добавлена рассылка итогов группе доступа
-- Версия от 11/04/2008 - Изменен алгоритм определения разделителя полей
-- Версия от 08/12/2008 - Добавлена обработка записей BI
-- Версия от 17/03/2009 - Чистим таблицу BIC_Dir_temp перед загрузкой, а не после
-- Версия: UAV (25/12/2009)
-- SRP_LoadBicDirectory  - Закачка справочника BICDirectory, Изменения в запуске загрузки справочников выходных дней.
-- Версия: UAV (04/02/2010)
-- SRP_LoadBicDirectory  - Закачка справочника BICDirectory, добавлена очистка constholiday.
-- 07/12/2012 Панфилов М.С. качаем только Holidays (на основе SRP_LoadBicDirectory)
-- -----------------------------------------------------------------------------
as
   sTag           DT.Label;            -- тэг
   nCount         DT.Counter := 0;
   nCTCount       DT.Counter := 0;
   nHFCount       DT.Counter := 0;
   nErrCount      DT.Counter := 0;
   sRowData       DT.Text;
   sFldName       DT.SQLName;
   nAddrExt       DT.Status;           -- поле Address отдельными строками
   nZIPExist      DT.Status;           -- поле ZIP отдельно
   nSpCode1       DT.Status;           -- поле Spec Code 1 присутствует
   nFixFldLen     DT.Status;           -- грузим файл с фиксированной длиной полей
   nRecFIExist    DT.Status := 0;      -- есть 'FI' записи
   dtHDStart      date;
   dtHDend        date;
   function MakeSendText return DT.Text
      as
         sSendText DT.Text;             -- текст для рассылки
         sCRLF     DT.Label := CHR(13)||CHR(10);
   begin
      sSendText := 'Закачка CCH завершена ';
      if nCount = 0 or nErrCount > 0 then
         sSendText := sSendText||'с ошибками.';
      else
         sSendText := sSendText||'успешно.';
      end if;
      sSendText := sSendText||sCRLF||'Обработано записей: '||nCount||', из них с ошибками: '||nErrCount;
      return sSendText;
   end MakeSendText;

   procedure SendResult
      as
         nSendGroup     DT.Reference;
         naWPMailList   DT.ClassType;
         naDoc          DT.ClassType;
         naReport       DT.ClassType;
         sSendText      DT.Text;             -- текст для рассылки
   begin
      nSendGroup := TO_NUMBER(nvl(Registry.GetValue('TRANS\SWIFT\SRP_LoadBicDirectory_SendGroup'),'0'));
      if nSendGroup > 0 then
         Get_AG_WP_List(naWPMailList,nSendGroup);
         sSendText := MakeSendText;
         dbms_output.put_line( 'sSendText = '||sSendText );
         Mail_Proc.Send(naWPMailList,'Итоги обработки BicDirectory CCH',SUBSTR(sSendText,1,254),null,naDoc,naReport);
      end if;
   end SendResult;
begin
   -- если нечего загружать, то выходим
   select count(*) into nCount from BIC_DIR_LOAD_CCH_TCB;
   if nCount = 0 then
      SendResult;
--      raise_application_error(-20000,'Таблица BIC_Dir_Load пуста');
--      tm_proc.RaiseError(20157);
      raise_application_error(-20000,'Таблица BIC_DIR_LOAD_CCH_TCB пуста');
   end if;

   begin
      --select rowdata into sRowData from BIC_Dir_Load where upper(substr(rowdata,1,3)) = 'TAG';
      nFixFldLen := 0;         -- если есть заголовок грузим файл с раделителем полей "Tab"
      nCount := nCount - 1;   -- кол-во строк уменьшаем на строку заголовока

      nZIPExist := 0;
      nAddrExt := 0;
      nSpCode1 := 0;
      while sRowData is not null loop
         sFldName := UPPER(text_proc.cut_part_of_string(sRowData,null,Chr(9)));
         if instr(sFldName,'ZIPCODE') > 0 then
            nZIPExist := 1;
         elsif instr(sFldName,'PHYSICAL ADDRESS 1') > 0 then
           nAddrExt := 1;
         elsif instr(sFldName,'SPEC CODE1') > 0 then
           nSpCode1 := 1;
         end if;
      end loop;
   exception
      when NO_DATA_FOUND then
         -- определим разделитель полей
         select rowdata into sRowData from BIC_DIR_LOAD_CCH_TCB where rownum = 1;
         if INSTR(sRowData,Chr(9)) > 0 then
            nFixFldLen := 0;         -- грузим файл с раделителем полей "Tab"
         else
            nFixFldLen := 1;         -- грузим файл с фиксированной длиной полей
         end if;
   end;
   -- почистим таблицу
   --delete from BIC_Dir_temp;
   --commit;

   if EventService.IsLogOpen = false then
      EventLog_Start(4,0,'Загрузка BIC/BIC+ Directory CCH ');
   end if;
   EventService.PutEvent(35,'TRANS','Загрузка BIC/BIC+ Directory CCH '||sysdate, 'Загрузка BIC/BIC+ Directory CCH '||sysdate);
   EventService.Markfolder(2,Context.Currentdoc);
   dtHDStart := trunc( S.ysdate,'YYYY' );
   dtHDEnd   := add_months( dtHDStart,24 );
   -- далее разбираем записи
   for rec in (select * from BIC_DIR_LOAD_CCH_TCB) loop
      begin
         sTag := upper(substr(rec.RowData,1,2));
         /*if sTag = 'BI' then
            nRecFIExist := 1;
            LoadBICDir_BI(rec.RowData);
         elsif sTag = 'FI' then
            nRecFIExist := 1;
            LoadBICDir_FI(rec.RowData, nFixFldLen, nAddrExt, nZIPExist, nSpCode1);*/
         if sTag = 'CT' then
            LoadBICDir_CT_TCB(rec.RowData, nFixFldLen);
            nCTCount := nCTCount + 1;
         elsif sTag = 'HF' then
            if nHFCount = 0 and to_number(nvl(Registry.GetValue('TRANS\SWIFT\DelHoliday'),'0')) = 1 then
               -- Удаляем все выходные дни за год
               delete from Holiday
                where HolidaySchema in (select HolidaySch
                                          from ClientRegionTree
                                         where Classified in (select distinct Client
                                                                         from BankCode
                                                                        where CodeSystem = (select Classified
                                                                                              from CodeSystem
                                                                                             where Const = 17)))
                  and HolidayDate >= S.ysDate
                  and HolidayDate < dtHDEnd;
               delete from ConstHoliday
                where HolidaySchema in (select HolidaySch
                                          from ClientRegionTree
                                         where Classified in (select distinct Client
                                                                         from BankCode
                                                                        where CodeSystem = (select Classified
                                                                                              from CodeSystem
                                                                                             where Const = 17)));
            end if;
            LoadBICDir_HF_TCB(rec.RowData, nFixFldLen);
            nHFCount := nHFCount + 1;
         else
            null;
         end if;
      exception
         when OTHERS then
            nErrCount := nErrCount + 1;
            if sqlcode != 20000 then
               EventService.PutError('TRANS',121,AddParam('','Ошибка при обработке справочника '),sqlerrm||' в строке: '||chr(13)||chr(10)||rec.RowData,false, Context.CurrentDoc);
            end if;
      end;
   end loop;
   -- если были 'FI' записи, то обработаем их
   /*if nRecFIExist = 1 then
      nErrCount := nErrCount + LoadBIC_FI;
   end if;*/
   if nHFCount > 0 then
      EventService.PutEvent(34,'TRANS','Обработано праздников: '||nHFCount,null,Context.CurrentDoc);
   end if;
   if nCTCount > 0 then
      EventService.PutEvent(34,'TRANS','Обработано кодов стран: '||nCTCount,null,Context.CurrentDoc);
   end if;
   EventService.PutEvent(34,'TRANS','Считано: '||nCount,null,Context.CurrentDoc);

   EventService.PutEvent(45,'TRANS','Загрузка BIC/BIC+ Directory CCH '||sysdate, 'Загрузка BIC/BIC+ Directory CCH '||sysdate);
   AddDocText(Context.CurrentDoc,46,'Справочник обработан');
   SendResult;
end SRP_LoadBicDirectory_CCH_TCB;

create or replace procedure LoadBICDir_HF_TCB(
   siRowData in out DT.PString,           -- строка с данными 'HF'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника выходных дней
-- Автор: Данилов О.В.
-- Версия от 20/06/2007
-- Версия: UAV (25/12/2009)
-- LoadBICDir_HF  - Процедура для закачки справочника выходных дней. Исправлены условия для выхода из обработки,
-- иначе не загружались данные.
-- 07/12/2012 Панфилов М.С. (на основе LoadBICDir_HF) поправлена в соответствии с текущими реалиями справочника SWIFT_CCH
-- 07/12/2012 Панфилов М.С. РФ не трогаем
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HF'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sCountryCode   DT.Label;             -- краткий код ISO государства
   sCountryName1  DT.Label;             -- наименование государства (часть 1)
   sCountryName2  DT.Label;             -- наименование государства (часть 2)
   dtDate         date;                 -- дата праздника
   sHolidayType   DT.Label;             -- тип праздника
   sSpecInfo      DT.Text;              -- дополнительная информаци
   nCountry       DT.Reference;
   nHoliday       DT.Reference;
   nRef           DT.Reference;
   nCount         DT.Quantity;
   sDate          DT.Label;
   nDay           ConstHoliday.DayNumber%TYPE;
   nMonth         ConstHoliday.MonthNumber%TYPE;
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
	-- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sCountryCode := cut_of_string(siRowData,2);
      sCountryName1 := cut_of_string(siRowData,35);
      sCountryName2 := null; --cut_of_string(siRowData,35);                                -- 07/12/2012 Панфилов М.С.
      dtDate := TO_DATE(cut_of_string(siRowData,8),'YYYYMMDD');
      sHolidayType := cut_of_string(siRowData,1);
      sSpecInfo := cut_of_string(siRowData,320);
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryName1 := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryName2 := null; --text_proc.cut_part_of_string(siRowData,null,CHR(9));        -- 07/12/2012 Панфилов М.С.
      dtDate := TO_DATE(text_proc.cut_part_of_string(siRowData,null,CHR(9)),'YYYYMMDD');
      sHolidayType := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sSpecInfo := text_proc.cut_part_of_string(siRowData,null,320);
   end if;
   -- Проверяем тип записи
   if sTag != 'HF' or sTag is null or sCountryCode is null
      or dtDate < S.ysdate then
      return;
   end if;
   -- Ищем страну
   if sCountryCode = 'RU' then        -- 07/12/2012 Панфилов М.С.
         return;
   end if;
   nCountry := FindObjectByCode(sCountryCode, 17);
   if nCountry is null then
      if sCountryName1 is null then
         return;
      end if;
      -- Ищем тип региона - государство
      begin
         select Classified into nRef from RegionType where Const = 1;
      exception
         when No_Data_Found then
            null;
      end;
      -- Заводим страну
      ClientRegionIns(nCountry, null, substr( rtrim(rpad(sCountryName1,35)||sCountryName2), 1, 50),
         rtrim(rpad(sCountryName1,35)||sCountryName2), null, nRef);
      nRef := null;
      BankCode_Edit(nRef, nCountry, sCountryCode, 17);
   end if;
   -- Схема выходных дней у региона
   select HolidaySch into nHoliday from ClientRegionTree where Classified = nCountry;
   if nHoliday is null then
      -- Заводим схему выходных дней
      select Classified.NextVal into nHoliday from Dual;
      insert into HolidaySchema( Classified, Label, Description )
         values( nHoliday, substr( 'Календарь г-ва '||rtrim(rpad(sCountryName1,35)||sCountryName2), 1, 50 ),
            'Схема выходных дней государства '||rtrim(rpad(sCountryName1,35)||sCountryName2) );
      insert into WeekDefinition( ClientRegion, WeekBegining, MonType, TueType, WedType, ThuType, FriType, SatType, SunType )
         values( nHoliday, 1, 0, 0, 0, 0,  0, 1, 1 );
      -- Удаляем выходные дни
      delete from Holiday where HolidaySchema = nHoliday;
      -- Привязываем схему к региону
      update ClientRegionTree set HolidaySch = nHoliday where Classified = nCountry;
   end if;
   select Count(*) into nCount from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
	sDate := to_char(dtDate,'DD/MM/YYYY');
   if sFlag = 'D' then
      if nCount > 0 then
         delete from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
         Eventservice.Putevent(34,'TRANS','В схеме выходных дней для г-ва '||rtrim(rpad(sCountryName1,35)||sCountryName2)||
                                          ' удаляется праздник '||sDate,'Загрузка BIC/BIC+ Directory '||sysdate);
      end if;
   elsif nCount = 0 then
      -- Добавляем праздник
      insert into Holiday( HolidaySchema, HolidayDate ) values( nHoliday, dtDate );
      if sHolidayType = 'H' then    -- только праздники, имеющие статус "обычного"
			nDay := TO_NUMBER(SUBSTR(sDate,1,2));
			nMonth := TO_NUMBER(SUBSTR(sDate,4,2));
			begin
				insert into ConstHoliday values(nHoliday, nMonth, nDay);
			exception
            when others then null;
			end;
		end if;
   end if;
end LoadBICDir_HF_TCB;

create or replace procedure LoadBICDir_CT_TCB(
   siRowData in out DT.PString,               -- строка с данными 'CT'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника стран
-- Автор: Данилов О.В.
-- Версия от 20/06/2007
-- 07/12/2012 Панфилов М.С. (на основе LoadBICDir_CT) поправлена в соответствии с текущими реалиями справочника SWIFT_CCH
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HF'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sCountryCode   DT.Label;             -- краткий код ISO государства
   sCountryName1  DT.Label;             -- наименование государства (часть 1)
   sCountryName2  DT.Label;             -- наименование государства (часть 2)
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
	-- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sCountryCode := cut_of_string(siRowData,2);
      sCountryName1 := cut_of_string(siRowData,35);
      sCountryName2 := null; -- cut_of_string(siRowData,35); -- 07/12/2012 Панфилов М.С.
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryName1 := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryName2 := null; -- text_proc.cut_part_of_string(siRowData,null,CHR(9)); -- 07/12/2012 Панфилов М.С.
   end if;
   LoadSwift.ISORegion(null, sTag, sFlag, sCountryCode, sCountryName1, sCountryName2);
end LoadBICDir_CT_TCB;

----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--10/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.SRP_LoadBicDirectory_CCH_TCB
od.LoadBICDir_HF_TCB
od.SRP_LoadBicDirectory

select count(rowid) from BIC_Dir_Load -- 612300

select * from BIC_Dir_Load
select * from BIC_DIR_LOAD_CCH_TCB

select * from BIC_Dir_temp -- 3048

select FindObjectByCode('TL', 17) from dual

select * from CodeSystem where Const = 17

select count(rowid) from Holiday h where h.holidayschema = 1000131227 -- 5348

----------------------------------------------------------------------------------
--11/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.ChangeDealDeposit 

od.ChangeDealOption
od.ChangeDealDeposit

----------------------------------------------------------------------------------
--12/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 197280058 

OD.DPC_BILLOPER 

----------------------------------------------------------------------------------
--17/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.DPC_TCB_DealSwift_MT399

----------------------------------------------------------------------------------
-- перенос срочных форексных сделок теперь идет день в день:                                                                                                    
-- надо написать od.movealltimedsum2_tcb - теперь будут юзать процедуру "Перенос срочных сумм - 3 (день в день)" вместо "Перенос срочных сумм - 2"             ++
----------------------------------------------------------------------------------
od.movealltimedsum2

od.MoveAllTimedSum2_TCB


----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from dp 28818


----------------------------------------------------------------------------------
--18/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------
select nvl(tcb_tools.JurBookCode(16020, 'Registration', 'OldNumber'),tcb_tools.JurBookCode(16020, 'Registration', 'RegNumber')) from dual
select * /*jb.classified into JuridicalBookId*/ from JuridicalBook jb where jb.code='Registration' and jb.ReportSchema = ReportSchemaId;

----------------------------------------------------------------------------------
-- поправить настройки отправки писем в tcb_bki_mbk_proc по задаче IPI 114168                                                                             ++
-- 18/12/2012 вложения стали отправляться пустые                                                                                                          ++
----------------------------------------------------------------------------------
od.tcb_bki_mbk_proc 
'post.transcapital.com'

begin
  od.tcb_bki_mbk_proc(sysdate,4);
end;


SELECT GLOBAL_NAME /*into sGLOBAL_NAME*/ FROM GLOBAL_NAME
select * from tcb_bki_mbk_tbl

utl_smtp.write_data(mail_conn, utl_tcp.crlf);
Create_field('Building',ltrim(ltrim(SUBSTR(tcb_tools.addressLines(rec_banks.classified, 'AddressFact', 'Building'),1,6),'СТР.'),' '),a1_node); -- 18/12/2012 Панфилов М.С. 
Create_field('Building',ltrim(ltrim(SUBSTR(tcb_tools.addressLines(rec_banks.classified, 'AddressJur', 'Building'),1,6),'СТР.'),' '),a1_node); -- 18/12/2012 Панфилов М.С. 
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

od.tcb_tools

od.tcb_rn_ath_paycheck

select ltrim(ltrim('СТР.   Building . Building','СТР.'),' ') from dual

----------------------------------------------------------------------------------
-- ищем банки для передачи в БКИ
select c.* from client c where c.type in (select classified from clienttype where cltypeconst = 2)
and 
(
c.classified in (select obj from od.objdesc where desctext = 0 and description = DescClass(5202))
or 
SYSDATE >= to_date(getobjdesc(c.classified,DescClass(5203)),'ddmmyyyyhh24miss')
)
---------------------------------------------------------------------------------- 33

----------------------------------------------------------------------------------
--19/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------
select * from billaccount where department is not null and bill = 1105282909
select * from bill where classified = 1105282909
select * from account where classified = 107687217
select * from department where classified = 1043278904
select * from billaccintention
od.bill_p



select * from bill where num = '0028261'

select sum(amount) from billsum where bill = 1115516463
select * from billsum where bill = 1115516463
40808,47

select 1000000*((20*0.0365)/366) from dual


od.dpc_filldealdepinterest

select * from deal where doc = 182106802

select DSP.* -- nvl(max(DSP.ValueDate), to_date('01/08/2012','dd/mm/yyyy')) --into dtStartDate
           from DealSwapPayment DSP, Doctree DCT
          where DSP.Doc = 182106802
            --and DSP.Classified = DCT.OperObj
            and DCT.Parent = DSP.Doc
            and DCT.DocState = 1000000035
            
select * from doctree where classified in (182107766,182109621)
1180504680
select DSP.* -- nvl(max(DSP.ValueDate), to_date('01/08/2012','dd/mm/yyyy')) --into dtStartDate
           from DealSwapPayment DSP
          where DSP.Doc = 182106802
-- затирается doctree.operobj на исполненных событиях сделки при создании/удалении доп. соглашения, 
-- из-за этого при добавлении новых доп.соглашений и пересчете процентного графика, исполненные события игнорируются
         select nvl(max(DSP.ValueDate), dtOperDate) into dtStartDate
           from DealSwapPayment DSP, Doctree DCT
          where DSP.Doc = idDoc
            and DSP.Classified = DCT.OperObj
            and DCT.Parent = DSP.Doc
            and DCT.DocState = Constants.State_Close;
-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
od.DPC_DealDepositAmend_Cancel

select * from DealSwapPayment where doc = 182105296

----------------------------------------------------------------------------------
--20/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.dpc_billoper
od.UT_DealAccrual

----------------------------------------------------------------------------------
--21/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select od.GetAccMaxTime(145775968) from dual

----------------------------------------------------------------------------------
--25/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проверить на RN (сделать offer как bid, если разъедутся 12:00 15:00 16:20)
SELECT s.instrument_short_name, m.maturity_title,t.bid, t.offer , t.last_update, t.rowid FROM sec_market t 
,sec_instrument s
,maturity_classes m
WHERE t.trade_date >=(to_date('25122012','ddmmyy'))
AND t.product_id = 101
AND s.instrument_id = t.instrument_id
AND t.term = m.id 
AND t.bid IS NOT NULL;       




select * from fx where ticket = 78214
select * from deals ОТП б/н

select * from V_Doctree_Client
select * from V_Doctree


----------------------------------------------------------------------------------
--26/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.SRP_LoadBicDirectory
od.LoadBICDir_HF
od.LoadBICDir_HS

create or replace procedure SRP_LoadBicDirectory_CCH_TCB
-- -----------------------------------------------------------------------------
-- Описание: Закачка справочника BICDirectory 
-- Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе SRP_LoadBicDirectory)
-- Автор: Данилов О.В.
-- Версия от 01/02/2007
-- Версия от 02/05/2007 - Поддержка справочника с фиксированной длиной полей
-- Версия от 20/05/2007 - Сделана "оболочечной" для обработки различных типов справочников
-- Версия от 05/02/2008 - Добавлена рассылка итогов группе доступа
-- Версия от 11/04/2008 - Изменен алгоритм определения разделителя полей
-- Версия от 08/12/2008 - Добавлена обработка записей BI
-- Версия от 17/03/2009 - Чистим таблицу BIC_Dir_temp перед загрузкой, а не после
-- Версия: UAV (25/12/2009)
-- SRP_LoadBicDirectory  - Закачка справочника BICDirectory, Изменения в запуске загрузки справочников выходных дней.
-- Версия: UAV (04/02/2010)
-- SRP_LoadBicDirectory  - Закачка справочника BICDirectory, добавлена очистка constholiday.
-- Версия от 22/12/2012: Исправлена ошибка при приеме справочника CCH с разделителем CHR(9)
-- 26/12/2012 Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе SRP_LoadBicDirectory)
-- -----------------------------------------------------------------------------
as
   sTag           DT.Label;            -- тэг
   nCount         DT.Counter := 0;
   nCTCount       DT.Counter := 0;
   nHFCount       DT.Counter := 0;
   nErrCount      DT.Counter := 0;
   sRowData       DT.Text;
   sFldName       DT.SQLName;
   nAddrExt       DT.Status;           -- поле Address отдельными строками
   nZIPExist      DT.Status;           -- поле ZIP отдельно
   nSpCode1       DT.Status;           -- поле Spec Code 1 присутствует
   nFixFldLen     DT.Status;           -- грузим файл с фиксированной длиной полей
   nRecFIExist    DT.Status := 0;      -- есть 'FI' записи
   dtHDStart      date;
   dtHDend        date;
   function MakeSendText return DT.Text
      as
         sSendText DT.Text;             -- текст для рассылки
         sCRLF     DT.Label := CHR(13)||CHR(10);
   begin
      sSendText := 'Закачка CCH завершена ';
      if nCount = 0 or nErrCount > 0 then
         sSendText := sSendText||'с ошибками.';
      else
         sSendText := sSendText||'успешно.';
      end if;
      sSendText := sSendText||sCRLF||'Обработано записей: '||nCount||', из них с ошибками: '||nErrCount;
      return sSendText;
   end MakeSendText;

   procedure SendResult
      as
         nSendGroup     DT.Reference;
         naWPMailList   DT.ClassType;
         naDoc          DT.ClassType;
         naReport       DT.ClassType;
         sSendText      DT.Text;             -- текст для рассылки
   begin
      nSendGroup := TO_NUMBER(nvl(Registry.GetValue('TRANS\SWIFT\SRP_LoadBicDirectory_SendGroup'),'0'));
      if nSendGroup > 0 then
         Get_AG_WP_List(naWPMailList,nSendGroup);
         sSendText := MakeSendText;
         dbms_output.put_line( 'sSendText = '||sSendText );
         Mail_Proc.Send(naWPMailList,'Итоги обработки BicDirectory CCH',SUBSTR(sSendText,1,254),null,naDoc,naReport);
      end if;
   end SendResult;
begin
   -- если нечего загружать, то выходим
   select count(*) into nCount from BIC_Dir_Load;
   if nCount = 0 then
      SendResult;
--      raise_application_error(-20000,'Таблица BIC_Dir_Load пуста');
      tm_proc.RaiseError(20157);
   end if;

   begin
      select rowdata into sRowData from BIC_Dir_Load where upper(substr(rowdata,1,3)) = 'TAG' and rownum = 1;
      nFixFldLen := 0;         -- если есть заголовок грузим файл с раделителем полей "Tab"
      nCount := nCount - 1;   -- кол-во строк уменьшаем на строку заголовока

      nZIPExist := 0;
      nAddrExt := 0;
      nSpCode1 := 0;
      while sRowData is not null loop
         sFldName := UPPER(text_proc.cut_part_of_string(sRowData,null,Chr(9)));
         if instr(sFldName,'ZIPCODE') > 0 then
            nZIPExist := 1;
         elsif instr(sFldName,'PHYSICAL ADDRESS 1') > 0 then
           nAddrExt := 1;
         elsif instr(sFldName,'SPEC CODE1') > 0 then
           nSpCode1 := 1;
         end if;
      end loop;
   exception
      when NO_DATA_FOUND then
         -- определим разделитель полей
         select rowdata into sRowData from BIC_Dir_Load where rownum = 1;
         if INSTR(sRowData,Chr(9)) > 0 then
            nFixFldLen := 0;         -- грузим файл с раделителем полей "Tab"
         else
            nFixFldLen := 1;         -- грузим файл с фиксированной длиной полей
         end if;
   end;
   -- почистим таблицу
   delete from BIC_Dir_temp;
   commit;

   if EventService.IsLogOpen = false then
      EventLog_Start(4,0,'Загрузка BIC/BIC+ Directory CCH ');
   end if;
   EventService.PutEvent(35,'TRANS','Загрузка BIC/BIC+ Directory CCH'||sysdate, 'Загрузка BIC/BIC+ Directory '||sysdate);
   EventService.Markfolder(2,Context.Currentdoc);
   dtHDStart := trunc( S.ysdate,'YYYY' );
   dtHDEnd   := add_months( dtHDStart,24 );
   -- далее разбираем записи
   for rec in (select * from BIC_Dir_Load) loop
      begin
         sTag := upper(substr(rec.RowData,1,2));
         if sTag = 'BI' then
            nRecFIExist := 1;
            LoadBICDir_BI(rec.RowData);
         elsif sTag = 'FI' then
            nRecFIExist := 1;
            LoadBICDir_FI(rec.RowData, nFixFldLen, nAddrExt, nZIPExist, nSpCode1);
         elsif sTag = 'CT' then
            LoadBICDir_CT(rec.RowData, nFixFldLen);
            nCTCount := nCTCount + 1;
         elsif sTag = 'HF' then
            if nHFCount = 0 and to_number(nvl(Registry.GetValue('TRANS\SWIFT\DelHoliday'),'0')) = 1 then
               -- Удаляем все выходные дни за год
               delete from Holiday
                where HolidaySchema in (select HolidaySch
                                          from ClientRegionTree
                                         where Classified in (select distinct Client
                                                                         from BankCode
                                                                        where CodeSystem = (select Classified
                                                                                              from CodeSystem
                                                                                             where Const = 17)))
                  and HolidayDate >= S.ysDate
                  and HolidayDate < dtHDEnd;
               delete from ConstHoliday
                where HolidaySchema in (select HolidaySch
                                          from ClientRegionTree
                                         where Classified in (select distinct Client
                                                                         from BankCode
                                                                        where CodeSystem = (select Classified
                                                                                              from CodeSystem
                                                                                             where Const = 17)));
            end if;
            LoadBICDir_HF_CCH_TCB(rec.RowData, nFixFldLen); -- 26/12/2012 Панфилов М.С.
            nHFCount := nHFCount + 1;
         elsif sTag = 'HS' then -- 26/12/2012 Панфилов М.С. закачка специфических календарей (напр. EUR)
            LoadBICDir_HS_CCH_TCB(rec.RowData, nFixFldLen);
         else
            null;
         end if;
      exception
         when OTHERS then
            nErrCount := nErrCount + 1;
            if sqlcode != 20000 then
               EventService.PutError('TRANS',121,AddParam('','Ошибка при обработке справочника '),sqlerrm||' в строке: '||chr(13)||chr(10)||rec.RowData,false, Context.CurrentDoc);
            end if;
      end;
   end loop;
   -- если были 'FI' записи, то обработаем их
   if nRecFIExist = 1 then
      nErrCount := nErrCount + LoadBIC_FI;
   end if;
   if nHFCount > 0 then
      EventService.PutEvent(34,'TRANS','Обработано праздников: '||nHFCount,null,Context.CurrentDoc);
   end if;
   if nCTCount > 0 then
      EventService.PutEvent(34,'TRANS','Обработано кодов стран: '||nCTCount,null,Context.CurrentDoc);
   end if;
   EventService.PutEvent(34,'TRANS','Считано: '||nCount,null,Context.CurrentDoc);

   EventService.PutEvent(45,'TRANS','Загрузка BIC/BIC+ Directory CCH '||sysdate, 'Загрузка BIC/BIC+ Directory CCH '||sysdate);
   AddDocText(Context.CurrentDoc,46,'Справочник обработан');
   SendResult;
end SRP_LoadBicDirectory_CCH_TCB;


create or replace procedure LoadBICDir_HF_CCH_TCB(
   siRowData in out DT.PString,           -- строка с данными 'HF'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника выходных дней
-- Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе LoadBICDir_HF)
-- Автор: Данилов О.В.
-- Версия от 20/06/2007
-- Версия: UAV (25/12/2009)
-- LoadBICDir_HF  - Процедура для закачки справочника выходных дней. Исправлены условия для выхода из обработки,
-- иначе не загружались данные.
-- Версия от 22/12/2012: Исправлено начитывание названия страны для формат с разделителем <Tab>
-- 26/12/2012 Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе LoadBICDir_HF)
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HF'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sCountryCode   DT.Label;             -- краткий код ISO государства
   sCountryName1  DT.Description;       -- наименование государства (часть 1)
   sCountryName2  DT.Label;             -- наименование государства (часть 2)
   dtDate         date;                 -- дата праздника
   sHolidayType   DT.Label;             -- тип праздника
   sSpecInfo      DT.Text;              -- дополнительная информаци
   nCountry       DT.Reference;
   nHoliday       DT.Reference;
   nRef           DT.Reference;
   nCount         DT.Quantity;
   sDate          DT.Label;
   nDay           ConstHoliday.DayNumber%TYPE;
   nMonth         ConstHoliday.MonthNumber%TYPE;
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
 -- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sCountryCode := cut_of_string(siRowData,2);
      sCountryName1 := cut_of_string(siRowData,35);
      sCountryName2 := cut_of_string(siRowData,35);
      sCountryName1 := rtrim(rpad(sCountryName1,35)||sCountryName2);
      dtDate := TO_DATE(cut_of_string(siRowData,8),'YYYYMMDD');
      sHolidayType := cut_of_string(siRowData,1);
      sSpecInfo := cut_of_string(siRowData,320);
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryName1 := text_proc.cut_part_of_string(siRowData,null,CHR(9));
--      sCountryName2 := text_proc.cut_part_of_string(siRowData,null,CHR(9));  название только одно
      dtDate := TO_DATE(text_proc.cut_part_of_string(siRowData,null,CHR(9)),'YYYYMMDD');
      sHolidayType := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sSpecInfo := text_proc.cut_part_of_string(siRowData,null,320);
   end if;
   -- Проверяем тип записи
   if sTag != 'HF' or sTag is null or sCountryCode is null
      or dtDate < S.ysdate then
      return;
   end if;
   -- Ищем страну
   if sCountryCode = 'RU' then        -- 26/12/2012 Панфилов М.С. РФ не трогаем!!!
         return;
   end if;
   nCountry := FindObjectByCode(sCountryCode, 17);
   if nCountry is null then
      if sCountryName1 is null then
         return;
      end if;
      -- Ищем тип региона - государство
      begin
         select Classified into nRef from RegionType where Const = 1;
      exception
         when No_Data_Found then
            null;
      end;
      -- Заводим страну
      ClientRegionIns(nCountry, null, substr(sCountryName1, 1, 50), sCountryName1, null, nRef);
      nRef := null;
      BankCode_Edit(nRef, nCountry, sCountryCode, 17);
   end if;
   -- Схема выходных дней у региона
   select HolidaySch into nHoliday from ClientRegionTree where Classified = nCountry;
   if nHoliday is null then
      -- Заводим схему выходных дней
      select Classified.NextVal into nHoliday from Dual;
      insert into HolidaySchema(Classified, Label, Description)
         values(nHoliday, substr('Календарь г-ва '||sCountryName1, 1, 50),'Схема выходных дней государства '||sCountryName1);
      insert into WeekDefinition(ClientRegion, WeekBegining, MonType, TueType, WedType, ThuType, FriType, SatType, SunType)
         values( nHoliday, 1, 0, 0, 0, 0,  0, 1, 1 );
      -- Удаляем выходные дни
      delete from Holiday where HolidaySchema = nHoliday;
      -- Привязываем схему к региону
      update ClientRegionTree set HolidaySch = nHoliday where Classified = nCountry;
   end if;
   select Count(*) into nCount from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
   sDate := to_char(dtDate,'DD/MM/YYYY');
   if sFlag = 'D' then
      if nCount > 0 then
         delete from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
         Eventservice.Putevent(34,'TRANS','В схеме выходных дней для г-ва '||sCountryName1||' удаляется праздник '||sDate,
                                          'Загрузка BIC/BIC+ Directory '||sysdate);
      end if;
   elsif nCount = 0 then
      -- Добавляем праздник
      insert into Holiday( HolidaySchema, HolidayDate ) values( nHoliday, dtDate );
      if sHolidayType = 'H' then    -- только праздники, имеющие статус "обычного"
   nDay := TO_NUMBER(SUBSTR(sDate,1,2));
   nMonth := TO_NUMBER(SUBSTR(sDate,4,2));
   begin
    insert into ConstHoliday values(nHoliday, nMonth, nDay);
   exception
            when others then null;
   end;
  end if;
   end if;
end LoadBICDir_HF_CCH_TCB;

create or replace procedure LoadBICDir_HS_CCH_TCB(
   siRowData in out DT.PString,           -- строка с данными 'HF'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника выходных дней для специфических календарей (пока только EUR)
-- 26/12/2012 Панфилов М.С. для TCB для закачки CCH
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HS'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sServiceCode   DT.Label;             -- краткий код календаря
   dtDate         date;                 -- дата праздника
   sHolidayType   DT.Label;             -- тип праздника
   sSpecInfo      DT.Text;              -- дополнительная информаци
   nCountry       DT.Reference;
   nHoliday       DT.Reference;
   nRef           DT.Reference;
   nCount         DT.Quantity;
   sDate          DT.Label;
   nDay           ConstHoliday.DayNumber%TYPE;
   nMonth         ConstHoliday.MonthNumber%TYPE;
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
 -- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sServiceCode := cut_of_string(siRowData,3);
      dtDate := TO_DATE(cut_of_string(siRowData,8),'YYYYMMDD');
      sHolidayType := cut_of_string(siRowData,1);
      sSpecInfo := cut_of_string(siRowData,320);
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sServiceCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      dtDate := TO_DATE(text_proc.cut_part_of_string(siRowData,null,CHR(9)),'YYYYMMDD');
      sHolidayType := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sSpecInfo := text_proc.cut_part_of_string(siRowData,null,320);
   end if;
   -- Проверяем тип записи
   if sTag != 'HS' or sTag is null or sServiceCode is null
      or dtDate < S.ysdate then
      return;
   end if;
   -- пока только EUR
   if sServiceCode != 'EUR' then
     return;
   end if;
   nHoliday := 1199945084;
   select Count(*) into nCount from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
   sDate := to_char(dtDate,'DD/MM/YYYY');
   if sFlag = 'D' then
      if nCount > 0 then
         delete from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
         Eventservice.Putevent(34,'TRANS','В схеме выходных дней '||sServiceCode||' удаляется праздник '||sDate,
                                          'Загрузка BIC/BIC+ Directory CCH '||sysdate);
      end if;
   elsif nCount = 0 then
      -- Добавляем праздник
      insert into Holiday( HolidaySchema, HolidayDate ) values( nHoliday, dtDate );
      if sHolidayType = 'H' then    -- только праздники, имеющие статус "обычного"
   nDay := TO_NUMBER(SUBSTR(sDate,1,2));
   nMonth := TO_NUMBER(SUBSTR(sDate,4,2));
   begin
    insert into ConstHoliday values(nHoliday, nMonth, nDay);
   exception
            when others then null;
   end;
  end if;
   end if;
   
end LoadBICDir_HS_CCH_TCB;

----------------------------------------------------------------------------------
--27/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from HolidaySchema
select * from WeekDefinition

----------------------------------------------------------------------------------
--28/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified in (select doc from client where type = 1000001778)
select * from client where classified = 16298 type = 1000001778

----------------------------------------------------------------------------------
--29/12/2012----------------------------------------------------------------------
----------------------------------------------------------------------------------

bbr.BBR_BANKLETTER_MBC_TCB

select d.  from doctype d

-- правил BBR_BANKLETTER_MBC_TCB (добавил дополнительные разрывы страниц)
bbr.BBR_BANKLETTER_MBC_TCB

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------




--2013




----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------



----------------------------------------------------------------------------------
--09/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_FXEvent_Doc

select * from SummaryPay

----------------------------------------------------------------------------------
--11/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


bbr.BBR_TCB_BILL_EBRR_REP

to_date('31122012','ddmmyyyy')

select 
--nvl(sum(nvl(od.bill_p.PercentSum(b.classified,to_date('31122012','ddmmyyyy')),0)+nvl(od.bill_p.DiscSum(b.classified,to_date('31122012','ddmmyyyy')),0))/1000,0) -- into nTPrcBill

nvl(od.bill_p.PercentSum(b.classified,to_date('31122012','ddmmyyyy')),0), nvl(od.bill_p.DiscSum(b.classified,to_date('31122012','ddmmyyyy')),0), b.num
from
     od.bill b
     ,od.billstatushistory bsh
     ,od.billrange br
     ,od.billgroup bg
     
where
     bsh.status=6
     and bsh.startdate<=to_date('31122012','ddmmyyyy')
     and bsh.enddate> to_date('31122012','ddmmyyyy')
     and bsh.bill=b.classified
     AND b.date1 BETWEEN (to_date('31122012','ddmmyyyy') + 31) AND (to_date('31122012','ddmmyyyy') + 60)
     and br.bill=b.classified
     and br.doc=bsh.doc
     and bg.classified = b.billgroup
and b.syscertificate not in (
select sc.classified from syscertificate sc, syssecurityseries ss, deposecurity ds, client c where
sc.series = ss.classified and ss.security = ds.syssecurity and ds.issuer = c.classified and c.type = 1000001778
)
     AND (1 is null or b.sysfilial=1)
     AND NOT EXISTS (SELECT * FROM od.billriskgroup brg,od.riskgroup r WHERE bg.riskgroup = brg.riskgroup AND bg.riskgroup=r.classified AND r.constrg<>1)



----------------------------------------------------------------------------------
-- update для Епановой по задаче IPI 121280                                                                                                                          ++

select dt.classified, dt.operdate, bl.repaydate, bl.* from bill bl, doctree dt, billoper bo, billrange br, doctype dty
where dt.classified=bo.doc
            and   dt.doctype=dty.classified
            and   bo.doc = br.doc
            and   br.bill = bl.classified
            and   bl.status in (4,46,8)
            and   dt.docstate=1000000035
            and   dty.category in (703,712,714)
            and   dt.operdate >= to_date('01012012','ddmmyyyy')
            and   bl.repaydate is null

/*
declare
begin
  for rec in (select dt.classified, dt.operdate, bl.repaydate, bl.classified billcl from bill bl, doctree dt, billoper bo, billrange br, doctype dty
where dt.classified=bo.doc
            and   dt.doctype=dty.classified
            and   bo.doc = br.doc
            and   br.bill = bl.classified
            and   bl.status in (4,46,8)
            and   dt.docstate=1000000035
            and   dty.category in (703,712,714)
            and   dt.operdate >= to_date('01012012','ddmmyyyy')
            and   bl.repaydate is null) loop

update bill b set repaydate = to_date('05122012','ddmmyyyy') where classified = rec.billcl ;

      end loop;
end;*/

----------------------------------------------------------------------------------

select * from OBJdesc 1014336995

select * from typetree where classified = 1014336995
select * from objtype where root = 1014336995

getobjdesc(c.classified,DescClass(5203))

select ObjAttr.GetOneType(id,1014336995) from dual



select ObjAttr.GetTypeTreeLabel(130540,1014336995) from dual

или

select * from objtype where root = 1014336995 and obj = id

, где id - это classified счета




select * from tcb_paym p where p.paym_id = 200538807 

od.tcb_paym_cur_ins

select * from tcb_crc32  where classified = 652197

----------------------------------------------------------------------------------
--14/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

bbr.BBR_TCB_BILL_OPER_MSK
-- правил отчет МСФО. Учтенные векселя для Филимоновой bbr.BBR_TCB_BILLDISC_MFSO_LIST                                                                                ++
----------------------------------------------------------------------------------
select * from od.bill



   function GetSumD(dtDFrom date, dtDTo date, nBillNomD number, nPriceD number, nBillCurrD number) return number is
        nTime          number;
        nYearLen       number;
        nSumDAll       number;
        dtYearFrom     date;
        dtYearTo       date;
        dtYear         date;
        dtYearNext     date;
   begin
   nSumDAll := 0;
   
           dtYearFrom := trunc(dtDFrom, 'YEAR');
           dtYearTo := trunc(dtDTo, 'YEAR');
           dtYear := dtYearFrom;
           while dtYear <= dtYearTo loop
              dtYearNext := Add_Months(dtYear, 12);
              nYearLen := dtYearNext - dtYear;
              if dtYearFrom = dtYearTo then
   
                 nTime := dtDTo - dtDFrom;
   
                 nSumDAll := nSumDAll + nTime/nYearLen;
                 exit;
              end if;
              if dtYear = dtYearFrom then
   
                 nTime := (dtYearNext-1) - dtDFrom;
   
                 nSumDAll := nSumDAll + nTime/nYearLen;
              end if;
              if dtYear = dtYearTo then
   
                 nTime := dtDTo - (dtYear-1);
   
                 nSumDAll := nSumDAll + nTime/nYearLen;
              end if;
              if dtYear != dtYearFrom and dtYear != dtYearTo then
                 nSumDAll := nSumDAll + 1;
              end if;
              dtYear := dtYearNext;
           end loop;
    return nvl(round(((nBillNomD-nPriceD)/nPriceD)*(1/nSumDAll)*100, MinorUnit(nBillCurrD)), 0);
   -- return to_number(to_char(dtYearTo,'yyyy'));
   end GetSumD; 

begin
                  nDoxod := nvl(GetSumD(to_date(dtOperDate,'dd.mm.yyyy'),to_date(dtPayDate,'dd.mm.yyyy'),nBillNominal,nPrice,ncur),0); 
                  exception when others then null;
                  end;
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--17/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doccategory where category = 703

select * from balance where account = 192055400

od.accountbalance

-- правил BBR_BILL_OWN_OUTSTAND_15 для Епановой                                                                                                        ++
        and b.endturn = 0

----------------------------------------------------------------------------------
--18/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_CREATEPERCENTACCOUNTDOC

od.DPC_FXEvent_Doc
od.DPC_FXDeal_AccSet

----------------------------------------------------------------------------------
--21/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.MoveAllTimedSum2_TCB

od.DPC_FXDeal_AccSet
od.UT_DealAccrual

select * from GenIntention

select * from od.dealaccintention

select IsPercAccount(182122431) from dual

----------------------------------------------------------------------------------
--22/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

   select AccountCode(DA.Account), DA.Account
     from DealAccount DA, DealAccIntention DAI
    where DA.Doc = 182122431
      and DA.AccIntention = DAI.Classified
      and DAI.ConstIntention in (18);

----------------------------------------------------------------------------------
-- правил BBR_TCB_BILL_OPER_MSK, теперь в журнал входят операции погошения на дату начала отчета (включительно)                                                      ++
----------------------------------------------------------------------------------

bbr.BBR_TCB_BILL_OPER_MSK

select * from doctype where classified = 1000133055
----------------------------------------------------------------------------------
--28/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--29/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- накатил getbillaccount после патчирования                                                                                                                         ++
----------------------------------------------------------------------------------
od.getbillaccount

select 82228.57*((29*0.02)/365) from dual

select 82228.57*(((31+30+6)*0.02)/366) + 130.66 from dual --431.72

select 82228.57*(((31)*0.02)/366)  from dual 

select * from billsum where bill in(select classified from bill where num = '0023755')

select * from bill where num = '0023755'

0,000
26,960
134,800
139,300
130,660

0,245

select  BC.GetBillSum(1189912724, 3) from dual

select * from od.billsumtype

select sum(Amount) into nAmount from BillSum
   where Bill = nBill and SumType
   
   select round(bill_p.PercentSum(1189912724, sysdate), MinorUnit(GetBillCurrency(1189912724))) from dual
   
   select 431.72 + 82228.57 from dual
   
   select* from billoper where doc = 202607001

begin
if 82660.290 = 82660.29 then
  dbms_output.put_line( 'sSendText');
end if;
end;

declare
   nSum        DT.Amount := 0;
   nSumNewPerc DT.Amount := 0;
   nSumPlus    DT.Amount := 0;
begin
   if BC.recDoc.nCategory = 703 then 
      nSum := BC.GetBillSum(BC.GetBill, 12);
      if nSum is null then
        nSum := nvl(round(bill_p.PercentSum(BC.GetBill, Context.OperDate), MinorUnit(GetBillCurrency(BC.GetBill))),0);
      end if;
      if nvl(BC.GetBillOperSum(BC.GetBill,3),0)<BC.recBill.nBillSum+nSum then
        nSumNewPerc:=nvl(BC.GetBillOperSum(BC.GetBill,3),0)-BC.recBill.nBillSum;--%% по новой ставке
        nSumPlus:=nvl(nSumNewPerc,0)-nvl(BC.GetBillSum(BC.GetBill, bill_p.SumTypeClassified(14)),0);
        dbms_output.put_line('Доначисление(>0)/списание(<0) = '||nSumPlus);
      end if;
  end if;
  if nSumPlus >= 0 then
    :nCondResult := 1;
  else
    :nCondResult := 0;
  end if;
end;

od.FUNC_BILL_REEXP302P

select to_date('01012013','ddmmyyyy') - to_date('01012012','ddmmyyyy') from dual 

select ADD_MONTHS(sysdate,-12) from dual

select (82660.29-82228.57)*(29/(31+30+6+29)) from dual --130.41


od.FUNC_BILL_PREVYEARPERC_DELTA

od.FUNC_BILL_NEWPERCENT_DELTA

od.FUNC_BILL_THISYEARPERC_DELTA


----------------------------------------------------------------------------------
--30/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

      nYOld := dtBeg - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nYAll := ADD_MONTHS(dtBeg,12) - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nCountYearAll := EXTRACT(YEAR from dtBeg) - EXTRACT(YEAR from dtdate0) + 1; 
      
      nSumNewPercAll:=nvl(BC.GetBillOperSum(nBill,3),0)-BC.recBill.nBillSum;--все %% по новой ставке
      nCur:=(trunc(dtBeg)-1)-trunc(dtDraw);--82
      nAll:=trunc(Context.OperDate)-trunc(dtDraw);--97
      nRest:=trunc(dtBeg)-1-trunc(dtDraw);
      nSumNewPerc:=((nYAll/2)/(366/(2-1)))*nSumNewPercAll*nCur/nAll;
      
      select 431.72*(((31+30+6)*(731/2))/((31+30+6+29)*(366))) from dual  -- должно быть 301.6
      
      select 431.72*(((31+30+6)/(366))/((31+30+6+29)/(731/2)+())) from dual  -- должно быть 301.6
      select 431.72*(((31+30+6)/(366))) from dual  -- должно быть 301.6
      
      select 431.72 - 130.66 from dual -- 301.06
      
      select to_date('0101'||to_char(sysdate - 1,'yyyy'),'ddmmyyyy') - to_date('01012012','ddmmyyyy') from dual  -- 366
      select ADD_MONTHS(to_date('01012013','ddmmyyyy'),12) - to_date('01012012','ddmmyyyy') from dual            -- 731
      
      select * from tcb_bki_mbk_tbl

SELECT GLOBAL_NAME FROM GLOBAL_NAME



nPerc := nSumNewPercAll/((dtdate0 - ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12))/(nYOld1) + 0 + /365);  --новый процент
      
nSumNewPerc:= BC.recBill.nBillSum*nPerc*((dtdate0 - ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12))/(nYOld1));

select 431.72/((((31+30+6)/366)+(29/365))*(82228.57)) from dual 

select 82228.57*0.02*   ((31+30+6)/366) from dual 

select 
round(431.72/(((dtdate0 - ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12))/(nYOld1) + 2 - 2 + (29)/(366))*82228.57),4)
from dual

----------------------------------------------------------------------------------
-- правил процедуры для Филимоновой из-за проблем с високосным годом в схеме проводок по векселям                                                                     ++
----------------------------------------------------------------------------------

create or replace function FUNC_BILL_THISYEARPERC_DELTA
/******************************************************************************
 Назначение:   Функция возвращает разницу между %%, которые должны быть начислены на дату расчета,
               и реальными %%, определяемыми как (Цена векселя в операции-номинал векселя), за текущий год.
               
 Версия от : 23/06/2010
  -- 30/01/2013 Панфилов М.С. проблема с високосными годами
******************************************************************************/
return DT.Amount as
   nSumNewPerc DT.Amount := 0;
   nSumNewPercAll DT.Amount := 0;
   nSumPlus    DT.Amount := 0;
   nSumPercThisYear DT.Amount := 0;
   nBill       DT.Reference;
   dtDraw      Date;
   dtBeg       Date;
   nSumInt     DT.Reference;
   nCur DT.Amount := 0;
   nall DT.Amount := 0;
   nRest DT.Amount := 0;   
   
      -- 30/01/2013 Панфилов М.С.
   nYAll DT.Amount := 0;               -- количество дней во всех годах
   nYOld DT.Amount := 0;               -- количество дней в прошлых годах
   nCountYearAll DT.Amount := 0;       -- количество всех лет
   nYOld1 DT.Amount := 0;              -- количество дней в самом первом прошлом году
   nPerc DT.Relation := 0;                -- новый процент
   
   dtdate0   Date;
   
begin
   if BC.recDoc.nCategory = 703 then  -- погашение
      -- Доначисление при погашении
      nBill:=BC.GetBill;
      dtBeg:=to_date('0101'||to_char(Context.OperDate,'yyyy'),'ddmmyyyy');
      begin
        select dt.validfromdate into dtDraw
          from billrange br, DocTree dt
         where br.Doc = dt.Classified
            and dt.Category = 702
            and br.bill=nBill
            and dt.Docstate=Constants.State_Close;   
      exception when Others then 
         raise_application_error(-20000,'По векселю ('||nBill||') невозможно определить дату выдачи!');
      end;
      dtdate0:=to_date('0101'||to_char(dtBeg-10,'yyyy'),'ddmmyyyy');
      if dtDraw>dtdate0 then
        dtdate0:=dtDraw;
      end if;
----%% этого года по ставке
      nSumInt:=bill_p.SumTypeClassified(14);
      begin
        select sum(bs.AMOUNT) into nSumPercThisYear--сумма начисл.%% этого года
          from billSum bs, DocTree dt
         where bs.Doc = dt.Classified
            and trunc(dt.validfromdate)>=dtBeg
            and bs.SUMTYPE=nSumInt
            and bs.bill=nBill
            and dt.Docstate=Constants.State_Close;   
      exception when Others then 
         raise_application_error(-20000,'По векселю ('||nBill||') невозможно определить cумму %%!');
      end;
      
      -- 30/01/2013 Панфилов М.С.
      nYOld := dtBeg - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nYAll := ADD_MONTHS(dtBeg,12) - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nYOld1 := ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12) - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nCountYearAll := EXTRACT(YEAR from dtBeg) - EXTRACT(YEAR from dtdate0) + 1; 
      
      nSumNewPercAll:=nvl(BC.GetBillOperSum(nBill,3),0)-BC.recBill.nBillSum;--все %% по новой ставке
      nCur:=trunc(Context.OperDate)-(trunc(dtBeg)-1);--82
      nAll:=trunc(Context.OperDate)-trunc(dtDraw);--97
      nRest:=trunc(dtBeg)-1-trunc(dtDraw);
      
      -- 30/01/2013 Панфилов М.С.
      nPerc := round(nSumNewPercAll/(((ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12)-1-dtdate0)/(nYOld1) + nCountYearAll - 2 + (nAll - nCur)/(nYAll - nYOld))*BC.recBill.nBillSum),4);  --новый процент
      
      -- 30/01/2013 Панфилов М.С.
      nSumNewPerc := round(BC.recBill.nBillSum*nPerc*((ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12)-1-dtdate0)/(nYOld1) + nCountYearAll - 2),2); --все %% прошлого года по новой ставке
      
      --nSumNewPerc:=nSumNewPercAll*nCur/nAll;--все %% этого года по новой ставке
      if nSumNewPerc>=nSumPercThisYear then--%% этого года по новой ставке>сумма начисл.%% этого года, доначислениe
        nSumPlus:=nSumNewPerc-nSumPercThisYear;--сумма доначисления 
        dbms_output.put_line('Погашение по новой ставке, доначислениe, nSumNewPerc='||nSumNewPerc||', nSumPercThisYear='||nSumPercThisYear||', доначисление='||nSumPlus);
      else
        nSumPlus:=nSumNewPerc-nSumPercThisYear;--сумма списания 
        dbms_output.put_line('Погашение по новой ставке, списаниe, nSumNewPerc='||nSumNewPerc||', nSumPercThisYear='||nSumPercThisYear||', доначисление='||nSumPlus);
      end if;
      insert into BillSum(Bill, SumType, Doc, Amount)
      values(nBill, nSumInt, BC.GetDoc, nSumPlus);
      --BC.SaveBillSum(nBill, bill_p.SumTypeClassified(14), BC.GetDoc, nSumPlus);
--raise_application_error(-20000,'Цена='||nvl(BC.GetBillOperSum(nBill,3),0)||'Nom='||BC.recBill.nBillSum||'nSumNewPercAll='||nSumNewPercAll||'nSumPlus='||nSumPlus||'nSumPercThisYear='||nSumPercThisYear||'dtBeg='||dtBeg||'dtDraw='||dtDraw);
      return nSumPlus;
   end if;
end FUNC_BILL_THISYEARPERC_DELTA; 




create or replace function FUNC_BILL_PREVYEARPERC_DELTA
/******************************************************************************
 Назначение:   Функция возвращает разницу между %%, которые должны быть начислены на дату расчета,
               и реальными %%, определяемыми как (Цена векселя в операции-номинал векселя), за прошлый год.
               
 Версия от : 23/06/2010
 -- 30/01/2013 Панфилов М.С. проблема с високосными годами
******************************************************************************/
return DT.Amount as
   nSumNewPerc DT.Amount := 0;
   nSumNewPercAll DT.Amount := 0;
   nSumPlus    DT.Amount := 0;
   nSumPercPrevYear DT.Amount := 0;
   nBill       DT.Reference;
   dtDraw      Date;
   dtBeg       Date;
   dtdate0     Date;
   nSumInt     DT.Reference;
   nCur DT.Amount := 0;
   nall DT.Amount := 0;
   nRest DT.Amount := 0;   
   
   -- 30/01/2013 Панфилов М.С.
   nYAll DT.Amount := 0;               -- количество дней во всех годах
   nYOld DT.Amount := 0;               -- количество дней в прошлых годах
   nCountYearAll DT.Amount := 0;       -- количество всех лет
   nYOld1 DT.Amount := 0;              -- количество дней в самом первом прошлом году
   nPerc DT.Relation  := 0;               -- новый процент
   
begin
   if BC.recDoc.nCategory = 703 then  -- погашение
      -- Доначисление при погашении
      nBill:=BC.GetBill;
      dtBeg:=to_date('0101'||to_char(Context.OperDate,'yyyy'),'ddmmyyyy');
      begin
        select dt.validfromdate into dtDraw
          from billrange br, DocTree dt
         where br.Doc = dt.Classified
            and dt.Category = 702
            and br.bill=nBill
            and dt.Docstate=Constants.State_Close;   
      exception when Others then 
         raise_application_error(-20000,'По векселю ('||nBill||') невозможно определить дату выдачи!');
      end;
      dtdate0:=to_date('0101'||to_char(dtBeg-10,'yyyy'),'ddmmyyyy');
      if dtDraw>dtdate0 then
        dtdate0:=dtDraw;
      end if;
----%% прошлого года по ставке
      nSumInt:=bill_p.SumTypeClassified(14);
      begin
        select sum(bs.AMOUNT) into nSumPercPrevYear--сумма начисл.%% прошлого года
          from billSum bs, DocTree dt
         where bs.Doc = dt.Classified
            and trunc(dt.validfromdate)<=dtBeg
            and trunc(dt.validfromdate)>=dtdate0
            and bs.SUMTYPE=nSumInt
            and bs.bill=nBill
            and dt.Docstate=Constants.State_Close;   
      exception when Others then 
         raise_application_error(-20000,'По векселю ('||nBill||') невозможно определить cумму %%!');
      end;
      
      -- 30/01/2013 Панфилов М.С.
      nYOld := dtBeg - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nYAll := ADD_MONTHS(dtBeg,12) - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nYOld1 := ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12) - to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy');
      nCountYearAll := EXTRACT(YEAR from dtBeg) - EXTRACT(YEAR from dtdate0) + 1;               
      
      nSumNewPercAll:=nvl(BC.GetBillOperSum(nBill,3),0)-BC.recBill.nBillSum;--все %% по новой ставке
      nCur:=(trunc(dtBeg)-1)-trunc(dtDraw);--82
      nAll:=trunc(Context.OperDate)-trunc(dtDraw);--97
      nRest:=trunc(dtBeg)-1-trunc(dtDraw);
      
      -- 30/01/2013 Панфилов М.С.
      nPerc := round(nSumNewPercAll/(((ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12)-1-dtdate0)/(nYOld1) + nCountYearAll - 2 + (nAll - nCur)/(nYAll - nYOld))*BC.recBill.nBillSum),4);  --новый процент
      
      dbms_output.put_line('// nSumNewPercAll='||nSumNewPercAll||', dtdate0='||dtdate0||', nYOld1='||nYOld1||', nCountYearAll='||nCountYearAll||', nAll='||nAll||', nCur='||nCur||', nYAll='||nYAll||', nYOld='||nYOld||', BC.recBill.nBillSum='||BC.recBill.nBillSum);
      
      -- 30/01/2013 Панфилов М.С.
      nSumNewPerc := round(BC.recBill.nBillSum*nPerc*((ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12)-1-dtdate0)/(nYOld1) + nCountYearAll - 2),2); --все %% прошлого года по новой ставке
      
      --nSumNewPerc:=nSumNewPercAll*nCur/nAll;--все %% прошлого года по новой ставке
      nSumPlus:= nSumNewPerc - nSumPercPrevYear;--сумма списания 
      dbms_output.put_line('Погашение по новой ставке, списаниe, процент='||nPerc||', nSumNewPerc='||nSumNewPerc||', nSumPercPrevYear='||nSumPercPrevYear||', доначисление='||nSumPlus);
      --BC.SaveBillSum(nBill, bill_p.SumTypeClassified(14), BC.GetDoc, nSumPlus);
      insert into BillSum(Bill, SumType, Doc, Amount)
      values(nBill, nSumInt, BC.GetDoc, nSumPlus);
--raise_application_error(-20000,'Цена='||nvl(BC.GetBillOperSum(nBill,3),0)||'Nom='||BC.recBill.nBillSum||'nSumNewPercAll='||nSumNewPercAll||'nSumPlus='||nSumPlus||'nSumPercPrevYear='||nSumPercPrevYear||'dtBeg='||dtBeg||'dtDraw='||dtDraw);
      return Abs(nSumPlus);
   end if;
end FUNC_BILL_PREVYEARPERC_DELTA; 


----------------------------------------------------------------------------------
--31/01/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billaccount where pact = 133199589

select * from account where classified = 202791875

od.dpc_clsallchild

select * from billoper

select * from doctype where classified = ? 






select * from billsum where bill in(select classified from bill where num = '0023733')

nPerc := round(nSumNewPercAll/(((ADD_MONTHS(to_date('0101'||to_char(dtdate0,'yyyy'),'ddmmyyyy'),12)-1-dtdate0)/(nYOld1) + nCountYearAll - 2 + (nAll - nCur)/(nYAll - nYOld))*BC.recBill.nBillSum),4);

select nvl(BC.GetBillOperSum(1186456741,3),0) from dual

select nvl(PriceInSum, RowPrice)
           from BillRange
          where Doc = 202793430 and Bill = 1186456741
          
select 
round(280194.92/(((ADD_MONTHS(to_date('01012012','ddmmyyyy'),12)-1-to_date('01102012','ddmmyyyy'))/(366) + 2 - 2 + (31+31+31+30 - 91)/(731 - 366))*14000000),4)
from dual 

select 
round(280194.92/(((ADD_MONTHS(to_date('01012012','ddmmyyyy'),12)-1-to_date('01102012','ddmmyyyy'))/(366) + 2 - 2 + (31+31+31+30 - 91)/(731 - 366))*14000000),4)
from dual 

select 14000000*0.06*(31/365) from dual 

od.Dpc_Checkloandepbillclient_Tcb

select * from od.bill
select * from od.billoper

----------------------------------------------------------------------------------
--01/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.FXEvent_Doc

od.MakeServiceObjects

od.dealtransaction

od.DPC_ReadDealTransaction2

od.DPC_BillOper


----------------------------------------------------------------------------------
-- правил начисления дисконтов по воронежскому векселю 0026574                                                                                                     ++
----------------------------------------------------------------------------------

select rowid, b.* from bill b where b.num = '0026574'
select rowid, b.* from billsum b where b.bill = 1166971778 and b.sumtype = 1042775368

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

od.AUTOMOVE_DIASTCB 


----------------------------------------------------------------------------------
--04/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- tcb_bki_mbk_proc - включил в рассылку Алтынбаева Рамиля вместо Князева Олега                                                                                    ++
----------------------------------------------------------------------------------
od.tcb_bki_mbk_proc


----------------------------------------------------------------------------------
--05/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

      select qv.* --lineValue 
      from lineCode lc, questValue qv
      where lc.reportSchema = 1000062175-- (select * from ReportSchema rs where rs.code = 'AddressFact') 
        --and ( (ALineCodes is null) or (instr(','||ALineCodes||',', ','||lc.code||',') > 0))
        and qv.client = 12597
        --and qv.obj    = ClientId
        and qv.lineCode = lc.classified 
        and qv.lineValue is not null
      order by lc.orderNum

select lc.* --lineValue 
      from lineCode lc where classified = 1000062178

----------------------------------------------------------------------------------    
-- правил od.tcb_bki_mbk_proc                                                                                                                                      ++
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--06/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

bbr.BBR_FORM116_TCB

----------------------------------------------------------------------------------
--07/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.dpc_billoper

od.DPC_EDITBILLDISCOUNT

select * from od.billaccintention

select * from billaccount where bill in (select classified from bill where num = '0324643')

select* from account where classified = 109532378

select * from od.billoper



select bsh.STATUS, 
       b.Classified, 
       b.SERIES,
       b.NUM,
       od.objattr.getonedesc(b.Classified, DescClass(713),null, to_date('01/01/2012','dd/mm/yyyy')),
       b.DRAWDATE,
       substr( BillGetPayDateVar( b.Classified), 1, 254),
       b.BILLSUM,
       b.BILLCURRENCY,
       b.PAYEE,
       ConstantLabel( bsh.STATUS, 'Bill', 'Status'),
       9,
       bsh.doc,
       b.RePayDate
from od.bill b,billstatushistory bsh, objprop op
where bsh.status = 4
   and b.CLASSIFIED = bsh.BILL
   and bsh.STARTDATE <= dtDate_
   and bsh.STARTDATE >= dtDateS
   and bsh.ENDDATE in (select min(ENDDATE) 
                       from billstatushistory 
                       where bill = b.CLASSIFIED 
                            and nvl(ENDDATE,dtDate) >  dtDate_)
   and bsh.sortorder in (select max(sortorder) 
                         from billstatushistory 
                         where bill = b.CLASSIFIED 
                             and ENDDATE = bsh.ENDDATE and STARTDATE = bsh.STARTDATE)
  -- and b.STATUS = bsh.STATUS
   and op.Obj(+) = b.Classified
   and op.Prop(+) = ObjAttr.PropClass(1741)
   and nvl(op.STATUS,0) = 0
   and b.MAKER in (select OurBank from od.preference where  SYSFILIAL =  14)
   and bsh.doc in (select classified from doctree where docstate = Constants.State_Close)
   and b.SYSFILIAL = 14
   
   select * from sysfilial 
   
   select to_date('01022013','ddmmyyyy') - 1/86400 from dual
   
   select trunc(to_date('01022013','ddmmyyyy') - 1/86400,'mm') from dual
   
----------------------------------------------------------------------------------
--08/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

delete from bill where sysfilial = 17 and num between '0024631' and '0028000'  

select * from billoper where bill in (select classified from bill where sysfilial = 17 and num between '0024631' and '0028000' )

----------------------------------------------------------------------------------
-- удалить векселя для Брянска                                                                                                                                       ++
----------------------------------------------------------------------------------
SELECT b.*, b.rowid FROM bill b WHERE b.drawdate = td AND b.sysfilial = 17 AND b.num NOT IN ('0024630') AND b.num < '0028001' AND b.status = 0  
delete FROM bill b WHERE b.drawdate = td AND b.sysfilial = 17 AND b.num NOT IN ('0024630') AND b.num < '0028001' AND b.status = 0 


----------------------------------------------------------------------------------
--11/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
-- проверка курсов в RN в 12:15 14:30 16:30---------------------------------------
----------------------------------------------------------------------------------
SELECT s.instrument_short_name, m.maturity_title,t.bid, t.offer , t.last_update, t.rowid FROM sec_market t                                                           
,sec_instrument s
,maturity_classes m
WHERE t.trade_date >=(to_date('15022013','ddmmyy'))
AND t.product_id = 101
AND s.instrument_id = t.instrument_id
AND t.term = m.id 
AND t.bid IS NOT NULL;
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_CHANGEPORTFOLIO
od.DOCCHANGEPORTFOLIO
od.UT_TradeMarketAccount

select code, getclientlabel(client), opened from account a where code like '30601%' and closed > sysdate and exists (select d.classified from doctree d where a.doc = d.classified and d.docstate = 1000000039)

select * from account where doc = 26718953
select * from doctree where classified = 26718953

od.FUNC_BILL_PERCACCR
od.FUNC_BILL_PERCUNDEF
od.FUNC_BILL_FINREZ

select* from bill where num = '0238219'
select* from billsum where bill = 1206803512
select * from doctree where classified = 204464720

select * from billsumtype where classified = 1011996478
select * from billsumtype where classified = 1042775364

select 1000000* 0.0516*(34+10)/366 from dual  

----------------------------------------------------------------------------------
-- проблема с начислением процентов по векселям по предъявлению, но не ранее (с двумя датами). Филимонова говорит, что
-- после второй даты проценты начисляться не должны. Но в схеме проводок при переучете векселя они начисляются (в bill_p.PercentSum)                                
-- Также, вероятно, нужно добавить условие "только для дисконтных векселей" на проводки, с ФинРезом.                                                                
----------------------------------------------------------------------------------
bill_p.PercentSum(nBill, dtDate)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--13/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.SaveCompetitorMarketInfo(NULL, 1206939504, 120503948, 1033590798, 6, '00555', 1153127906,0)

select * from CompetitorMarketInfo

----------------------------------------------------------------------------------
-- Кривой фондовый модуль Задача в IPI 45178 - обещают исправить 14/02/2013                                                                                          ++
-- отписать Канцур => 15/02/2013 заменили модуль на боевой базе                                                                                                      ++
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--15/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from od.billaccount where pact = 133897995
select * from department d where category = 14

od.dpc_billoper

od.DPC_RB_BillOper

----------------------------------------------------------------------------------
-- запрос по задаче 126142                                                                                                                                        ++  
-- сделал отчет bbr.BBR_PLAST_20209_TCB                                                                                                                           ++                                                                                                                                                                                                              
----------------------------------------------------------------------------------

select amount, begdate from od.balance where account in
(
select a.classified from od.account a where classified in (
select account from od.dpaccount dpa where dp in (select classified from department d where category = 14)
) and code like '20209%' and sysfilial = 1
) and type = 5 and endturn = 0


select abs(b.amount), b.begdate, a.code, d.label from od.balance b, od.account a, od.dpaccount dpa, department d  
where dpa.dp = d.classified 
      and a.classified = dpa.account
      and b.account = a.classified
      and d.category = 14 
      and b.type = 5 
      and b.endturn = 0
      and a.code like '20209%' and a.sysfilial = 1
      
order by d.classified, a.code, b.begdate

bbr.BBR_PLAST_20209_TCB
      
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--18/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

bbr.BBR_EXECUTOR_REESTR_TCB

select * from doctree where classified = 205036473 
select * from doctree where classified = 204958856

select * from doctype where classified = 1000131174

----------------------------------------------------------------------------------
--19/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- оптимизация запросов в отчетах по задаче IPI 126389                                                                                                              ++
--  BBR_TCB_BILLOWN_MFSO_REP_NEW, BBR_TCB_BILLOWN_MFSO_REP, BBR_TCB_BILL_OPER_MSK
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- добавил в BBR_TCB_BILL_OPER_MSK столбцы 44,45 "проценты/дисконт за 2012 год"                                                                                     ++
-- "проценты/дисконт за 2012 год" в нац.эквиваленте                                                                                                                 ++
----------------------------------------------------------------------------------
bbr.BBR_TCB_BILL_OPER_MSK

nPercent:= null;
nDiscount:= null;
if (nCategory in (702,703) or ndoctype = 1155771305) then
   begin
     select nvl(sum(bs.amount),0) into nPercent
       from BillSum bs, doctree dt
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =14);
   exception when Others then nPercent:=0;
   end;
   begin
     select nvl(sum(bs.amount),0) into nDiscount
       from BillSum bs, doctree dt
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =15);
   exception when Others then nDiscount:=0;
   end;
elsif (nCategory in (711,712,714) or ndoctype = 1103223475) then
   begin
     select nvl(sum(bs.amount),0) into nPercent
       from BillSum bs, doctree dt
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =29);
   exception when Others then nPercent:=0;
   end;
   begin
     select nvl(sum(bs.amount),0) into nDiscount
       from BillSum bs, doctree dt 
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =30);
   exception when Others then nDiscount:=0;
   end;
end if;



nPercent:= null;
nDiscount:= null;
if (nCategory in (702,703) or ndoctype = 1155771305) then
   begin
     select nvl(sum(bs.amount),0) into nPercent
       from BillSum bs, doctree dt
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =14);
   exception when Others then nPercent:=0;
   end;
   begin
     select nvl(sum(bs.amount),0) into nDiscount
       from BillSum bs, doctree dt
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =15);
   exception when Others then nDiscount:=0;
   end;
elsif (nCategory in (711,712,714) or ndoctype = 1103223475) then
   begin
     select nvl(sum(bs.amount),0) into nPercent
       from BillSum bs, doctree dt
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =29);
   exception when Others then nPercent:=0;
   end;
   begin
     select nvl(sum(bs.amount),0) into nDiscount
       from BillSum bs, doctree dt 
      where bs.Bill=nBClas and bs.doc=dt.classified and trunc(dt.OperDate)<=dtEnd and trunc(dt.OperDate) >= to_date('01/01/1980','dd/mm/yyyy')
        and bs.SumType in (select classified from billsumtype where consttype =30);
   exception when Others then nDiscount:=0;
   end;
end if;




select * from billsum
select * from doctree
select * from od.bill
nRateCBonDD := Rate(ncurop,1000001275,pref.exchmatrix,dt.OperDate);
nBillNominalE := nBillNominal*nRateCBonDD;


----------------------------------------------------------------------------------
--20/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------



----------------------------------------------------------------------------------
-- Герасимова просила закрывать и удалять счета 91202 при удалении документа принятия в залог  
-- написал процедуру dpc_rb_billpactaccount91202_tcb  =>  решили не ставить, так как есть отчет BBR_TCB_BILL_RASP_CLOSE_ACC, который закрывает такие счета
----------------------------------------------------------------------------------
create or replace PROCEDURE dpc_rb_billpactacc91202_tcb
-- 20/02/2013 Панфилов М.С. - удаляем счета 91202 и зачищаем BillAccount
IS
begin  
for recAcc in (select account from od.billaccount where pact = Context.CurrentDoc and accintention = 1011996337) loop
  delete from od.billaccount where account = recAcc.Account and pact = Context.CurrentDoc and accintention = 1011996337;
  DocProcessForChild(recAcc.account,Context.OperDate,1,1000000035 /*Constants.State_RollBack*/);
end loop;
end dpc_rb_billpactacc91202_tcb;
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
DPC_DocChangeState
AGC_ACCOUNTFOREDITINGTCB

BBR_TCB_BILL_RASP_CLOSE_ACC

select * from od.billaccount where pact = 204856237
select * from billaccintention where classified = 1011996337
select * from account where classified = 204856239

od.DPC_RB_BillOper
select * from docstate

----------------------------------------------------------------------------------
--21/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.fxevent_doc

begin
  
  if (select * from dual) then
    dbms_output.put_line('ddasda');
  end if;
    
end;

----------------------------------------------------------------------------------
--22/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
 
----------------------------------------------------------------------------------
-- правил векселя для Брянска                                                                                                                                      ++
----------------------------------------------------------------------------------
update od.bill set PAYDATEVAR = 1  WHERE sysfilial = 17 AND (num IN ('0024630') or num > '0028000')
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--27/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from proplist where classified = 1000002563

od.DealDep_proc

----------------------------------------------------------------------------------
--28/02/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select 40965000*((0.06*32)/366) from dual

select 40965000*((0.06*29)/366) from dual

select * from bill where num = '0028551'
update
1210391605

update bill set percentdate = to_date('27.02.2013','dd.mm.yyyy') where num in ('0028551') -- правил для Герасимовой                                                  ++

select * from bill where num in ('0028551')

select * from billsum where bill = 1210391605

select * from doctree where classified = 206646717

----------------------------------------------------------------------------------
--01/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


select Classified Bill
                 from Bill
                where Status in (2, 32, 34, 38, 33)
                  --and Maker = Pref.OurBank
                  /*and (
                      (nBill is null and nBillGroup is null)
                      or
                      (nBill is null and nBillGroup is not null and nBillGroup = BillGroup)
                      or
                      (nBill is not null and nBill = Classified)
                      )*/
                  and (nvl(nToRepay, 0) = 0 or nToRepay = 1 and bill_p.RepayDateNoNull(Classified) = to_date('27.02.2013','dd.mm.yyyy'))
                  
----------------------------------------------------------------------------------
--04/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- правил bbr.BBR_TCB_BILLOWN_DATE_REP для Филимоновой b.drawdate>=to_date('01.' || substr(to_char                                                                   ++
----------------------------------------------------------------------------------

         select b.num,
(
 (case when ( (case when b.paydatevar = 1 then add_months(b.date1, 12)  
                    else b.date1 
                    end) >to_date('01.03.2013','dd.mm.yyyy')) then to_date('01.03.2013','dd.mm.yyyy') 
       else b.date1 
       end)
       
       -
       
 (case when (b.drawdate>=to_date('01.' || substr(to_char(to_date('01.03.2013','dd.mm.yyyy'),'dd.mm.yyyy'),4,8),'dd.mm.yyyy')) then b.drawdate + 1 
       else to_date('01.' || substr(to_char(to_date('01.03.2013','dd.mm.yyyy'),'dd.mm.yyyy'),4,8),'dd.mm.yyyy') 
       end)
       
       +1
)
*(b.billsum - br.rowprice)/((case when b.paydatevar = 1 then add_months(b.date1, 12) else b.date1 end)-b.drawdate)
--into nRURDiscount
      from
            bill b
            ,billstatushistory bsh
          --  ,client c
            ,billrange br
          --  ,billoper bo
            ,doctree dt
      where
                 (( (od.billdayrepay(b.classified,to_date('01.03.2013','dd.mm.yyyy'))>=0)
             and (od.billdayrepay(b.classified,to_date('01.03.2013','dd.mm.yyyy'))<=50000) )
             or od.billdayrepay(b.classified,to_date('01.03.2013','dd.mm.yyyy')) is null)
             and   bsh.STATUS in(2,34,38,14) --in (6,8)
             and  bsh.startdate<=to_date('01.03.2013','dd.mm.yyyy')
             and  bsh.enddate>to_date('01.03.2013','dd.mm.yyyy')
             and not exists (select *
                             from billstatushistory t
                             where t.bill=bsh.bill
                             and bsh.startdate<t.startdate 
                             and t.startdate<to_date('01.03.2013','dd.mm.yyyy') )
             and  bsh.bill=b.classified
         --    and b.maker=c.classified
             and br.bill=bsh.bill
             and b.billcurrency=1000001275
             and dt.classified=br.doc
             and dt.docstate <> 1000000037
         --    and bo.doc=dt.classified
             and (b.date1 is null or b.date1<=to_date('01.03.2013','dd.mm.yyyy')+50000)
            -- and b.sysfilial=1
             --  and dty.classified=dt.doctype
             --and bsh.doc=dt.classified
             and (dt.doctype=1065524926 or dt.doctype is null)
             and b.percent is null  /*and b.sysfilial = 1*/ and b.maker = 1 
             and od.tcb_getbillbalacc(to_date('01.03.2013','dd.mm.yyyy'),b.classified) != '52406';  
             

select * from bill where num = '0023992'

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--20/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

bus_obj


select * from department where classified = 1058336142
od.DPC_TCB_CONVUNLOAD
select * from tcb_crc32 where classified = 208831054

----------------------------------------------------------------------------------
--22/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- задача 123349 от Герасимовой                                                                                                                                      ++
--- на athena3:
---- в схеме вексельных проводок: для операции "Выдача векселя" перенести проводку Д99999* К90705* с "Оплатить" на "Исполнить" (только для МОСКВЫ !!!!!!!!!!!!)      ++
---- прописать для этой проводки назначение платежа "Выдача векселя @SER@ № @NUM@."                                                                                  ++
---- в manager:                                                                                                                                                      ++
----- для "Выдачи векселей" добавить тип связанного объекта "Дочерние внебалансовые 99999/90705"  (только для МОСКВЫ !!!!!!!!!!!!)                                   ++
----- навесить на действие "Исполнить" две обработки связанных объектов "Дочерние внебалансовые 99999/90705" Создан -> Доступен в работе -> Исполнен                 ++
----- привязать процедуру DPC_PROCESSLINKOBJECT к операции "Исполнить"                                                                                               ++
---- поправить отчет распоряжения по дисконтным векселям (bbr.BBR_TCB_BILL_RASP_OPER), чтобы не вылазили эти проводки -> убрал раздел 2 -> вернул раздел 2 ->
----- ограничил раздел 2 по GetDocCategory(dt.parent) <> 702                                                                                                         ++
--- настроить на боевой                                                                                                                                              ++
--- проверить                                                                                                                                                        ++
--- по поводу назначений платежа в проводках, где одновременно несколько векселей                                                                                    ++
---- сделать тег в справочнике общего назначения ParBillList с процедурой GetParBillList                                                                             ++
---- написать GetParBillList                                                                                                                                         ++
--- настроить на боевой                                                                                                                                              ++
--- Крендель просила отключить совсем эту проводку для Перми                                                                                                         ++                                                                        

od.DPC_BillOper
od.GetParentLabel
----------------------------------------------------------------------------------
select DT.Classified, DT.DocType from Doctree DT, bankoper bo, preparemoney pm where DT.Parent = :idObject and DT.Classified = bo.doc and DT.Classified = pm.doc and acccode(bo.account) like '99999%' and acccode(pm.account) like '90705%'


create or replace function GetParBillList
--------------------------------------------------------------------------------
-- Возвращает : Номера и серии всех векселей из родительского документа
-- Версия от  : 28/03/2013
-- Автор      : Панфилов М.С.
--------------------------------------------------------------------------------
return dt.Label
as
   sLabel  dt.Description;
begin
  
      for rec in (select distinct nvl(series || ' ','') as sss, numfrom, numto from billrange where doc in (select parent from DocTree where Classified = Message.idObject))
      loop
        if rec.numfrom = rec.numto then
           sLabel := sLabel || rec.sss || '№' || rec.numfrom || ',';  
        else
           sLabel := sLabel || rec.sss || '№№' || rec.numfrom || '-' || rec.numto || ','; 
        end if;
      end loop;
    
   --
   return rtrim(sLabel,',');
   --
exception
   when OTHERS then
      return null;
end GetParBillList;
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
  --drop public synonym GetParBillList for GetParBillList;


select * from doctree where classified = 209370316
select* from billoper where doc = 209370316
select* from billrange where doc = 209370316
select* from billrange where doc = 209188337
select* from billoper where doc = 209188337

(select num, nvl(series,' ') as sss from bill where classified in (select bill from billrange where doc in (209188337)))

od.DPC_ExpandPayReason
----------------------------------------------------------------------------------
--25/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.bus_obj
bbr.BBR_TCB_UNIV_RTF

od.sm_DealEv_Split
od.sm_DealEv_Split_WithDate
od.sm_DealEv_Split_NoCheck

execute MakeServiceObjects.ForProc('sm_DealEv_Split',-2,'','DTRS','TMY');


   elsif c_access.IsEditDoc(niDoc) = 0 then
      tm_proc.RaiseError(42045); -- Не достаточно прав для редактирования документа!
   elsif CanDocOpen(recDT.DocType) = 0 then
      tm_proc.RaiseError(42046); -- Не достаточно прав для создания документов!
   end if;
   
   (
   nDoc                 DT.Reference,  -- расщепляемое событие
   naAmount_            DT.NumberType, -- новые суммы событий
   naResultDoc in out   DT.ClassType,  -- результирующий массив с документами событий
   dtaDate     in       DT.DateType  default empty_date_array   -- новые даты валютирования событий
)


od.bus_obj

od.DPC_EditDeal

----------------------------------------------------------------------------------
-- по задаче IPI 130457 правили od.bus_obj                                                                                                                        ++
-- проверить закачку банкнотных сделок из RN в Афину                                                                                                              ++
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--26/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--27/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 182143344 

select * from od.sysdepo sd where sd.security = 1218230667
select * from od.syssecurity where classified = 1218230667


----------------------------------------------------------------------------------
--28/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.DPC_BillOper

od.dpc_checkcodevaloper_tcb
od.CheckVO_TCB

----------------------------------------------------------------------------------
--29/03/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
select* from doccategory 

----------------------------------------------------------------------------------
-- задача от Герасимовой по автоматизации расчетов при досрочном погашении векселей IPI 130215                                                                    ++
----------------------------------------------------------------------------------
-- на базе best
-- .xls с текущей схемой проводок для Герасимовой                                                                                                                 ++
-- предложить Герасимовой новую схему                                                                                                                             ++
-- доступ к модулям (задачу IPI 136676 заводил Игорь Дударев)                                                                                                     ++
-- настройки:                                                                                                                                                     ++
---- od.DPC_BillSumCorrection -- отключить для досрочных погашений в manager                                                                                      ++                                                                                                
---- сделать доп.описание "Процентная ставка досрочного погашения" -1370, повесить его на документ "Досрочный выкуп собственного векселя"                         ++
---- отключить в схеме проводок по документу "Досрочный выкуп собственного векселя" на "Оформить" 4 проводки по процентным векселям                               ++
---- сделать условие для вексельных документов "Есть ставка досрочного погашения?"                                                                                ++
---- написать процедуру "Коррекция суммы (для досрочного выкупа) TCB" DPC_BillSumCorrection_TCB и BillDPPercentSum_TCB                                            ++
---- для док-та "Досрочный выкуп собственного векселя" навесить DPC_BillSumCorrection_TCB на действия "Редактировать" и "Восстановить" с усл. "Вексель процентный"++
---- сделать условие для вексельных документов "начисленные %% >= ранее начисленных %%"                                                                           ++
---- сделать новый тип суммы FUNC_Bill_AccrualAdd_TCB "Сумма процентов для доначисления по векселю (с проверкой ставки досрочного погашения при досрочном выкупе)"++
---- сделать три проводки по процентным векселям                                                                                                                  ++
---- назначения платежа
-- есть ещё вопросы у Епановой в задаче 130215 (дисконтные кредитные векселя)                                                                                     ++
---- доступ на BEST для Епановой по задаче 136676                                                                                                                 ++
---- написать процедуру "Коррекция суммы (для досрочного выкупа ДИСК) TCB" DPC_BillSumCorrectionDisc_TCB                                                          ++
---- для док-та "Досрочный выкуп собственного векселя" навесить DPC_BillSumCorrectionDisc_TCB на действия "Редактировать" и "Восстановить" с усл. НЕ "Вексель процентный" ++
---- доступ на BEST для Якушиной по задаче 136676                                                                                                                 ++ 
---- тесты Епановой и Якушиной                                                                                                                                    ++

-- отразить в документации                                                                                                                                        ++
-- перенести на боевую                                                                                                                                            ++
-- база BEST больше не нужна                                                                                                                                        
                                                                                                                                            
----------------------------------------------------------------------------------
od.FUNC_Bill_AccrualAdd_TCB
od.DPC_BillSumCorrection_TCB
od.DPC_BillSumCorrectionDisc_TCB
nPrePercSum := nvl(BC.GetBillSum(bc.getbill, bill_p.SumTypeClassified(14)),0);
select * from billsum where doc = 233274627
select * from billsum where bill = 1236227343

create or replace procedure DPC_BillSumCorrectionDisc_TCB
/******************************************************************************
 Изменение суммы операции по непроцентному векселю (коррекция цены для досрочного выкупа по ставке досрочного учета векселя)
 для пермских непроцентных векселей, которые выдются по номиналу
 Дата: 16/07/2013
 Автор: Панфилов М.С.
******************************************************************************/
as
  psum           dt.Amount;
  allsum         dt.Amount := 0;                -- вся сумма по операции
  sPerc          objdesc.desctext%type;         -- процентная ставка дисконта из доп.описания
  nPerc          billrange.percentsum%type;     -- процентная ставка дисконта из доп.описания
  dateend        date;                          -- дата погашения векселя
  T              dt.Quantity;                   -- срок, оставшийся до погашения
begin
  dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB ->');

  for rec in (select br.*, b.billsum, b.paydatevar, b.date1, b.date2, b.DRAWDATE, b.time from BillRange br, bill b where br.Doc = CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      begin
        psum  := null;
        sPerc := null;
        nPerc := null;
        dateend := null;
        T := null;
      
      -- проверяем доп.описание
      begin
      select value into sPerc from ENUMTYPEVALUE where classified in (select ENUMTYPEVALUE from OBJENUM where enumtype = (select classified from enumtype where constenum = -5000) and obj = rec.bill);

      nPerc := sPerc;
      dbms_output.put_line('sPerc -> ' || sPerc);
      exception
             when others then null;
      end;
    
      -- если доп.описание есть
      if nPerc is not null then
      -- вычислим срок, оставшийся до погашения
      begin
                  select CASE
                  WHEN rec.paydatevar = 1 AND rec.date2 IS NOT NULL THEN
                   rec.date1
                  WHEN rec.paydatevar = 1 AND rec.date1 IS NOT NULL THEN
                   rec.date1
                  WHEN rec.paydatevar = 4 THEN
                   rec.date1
                  when rec.paydatevar = 1 and rec.date1 is null and rec.date2 is null then
                   rec.DRAWDATE 
                    when rec.paydatevar = 3 then
                   rec.DRAWDATE + rec.time
                  ELSE
                   null
                  END into dateend from dual;
                  dbms_output.put_line('dateend -> ' || to_char(dateend,'dd.mm.yyyy'));
                  T := trunc(dateend) - trunc(CONTEXT.OperDate);
                  dbms_output.put_line('T -> ' || T);
      exception
        when others then null;
      end;
      -- вычислим сумму дисконта по новой ставке nPerc
      psum := round(rec.billsum*(1-T*nPerc/36500),MinorUnit(GetBillCurrency(rec.bill)));
      update BillRange set rowprice = psum where bill = rec.bill;
      allsum := allsum + psum;
      dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB ' || psum);
      end if;
      exception
        when others then null;
      end;
  end loop;
  update BillOper set OperSum=allsum, SumFrom=allsum, SumTo=allsum where Doc=CONTEXT.CurrentDoc;
  
dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB <- ');
exception
  when others then null;
end DPC_BillSumCorrectionDisc_TCB;

----------------------------------------------------------------------------------

select 9024319.27*(1-5*11/36500) from dual 
select br.*, b.billsum, b.paydatevar, b.date1, b.date2, b.DRAWDATE, b.time from BillRange br, bill b where br.Doc = 211806362 and br.bill = b.classified

od.DPC_BillSumCorrectionDisc_TCB
od.DPC_BillSumCorrection_TCB
od.DPC_BillSumCorrection -- отключить для досрочных погашений
od.DPC_MO_CheckAccount

select * from od.billsum where bill in (select classified from bill where num = '0019826')  
-- 5148686,51 ранее начисленные проценты
-- 5329630,76 ранее начисленные проценты + проценты за 22 дня апреля
select 32989337.07* ((0.091*22)/365) + 5148686.51 from dual
select * from doctree where classified = 210232842
select * from billoper where doc = 211800344

select 5329630.76 - 5148686.51 from dual


od.DPC_BillOper

od.FUNC_BILL_NEWPERCENT_DELTA
select * from BillSumType
   where ConstType = 12 or Classified = 12
   
select * from objdesc 
select * from desclist
select * from od.bill

select OD.*, trim(OD.desctext)
   from objdesc OD, desclist DL
    where OD.doc = 211800344
     and OD.description = DL.classified
      and DL.constdesc = -1370

select * from billrange where doc in (211800344,211800389)
select * from billoper
select * from billpercent where doc in (211800344,211800389)

od.FUNC_BILL_ACCRUALADD

select * from BillSumType 
   
select * from enumtype
select * from OBJENUM where enumtype = 1145856239 and obj = 1221983186
select value from ENUMTYPEVALUE where classified in (select ENUMTYPEVALUE from OBJENUM where enumtype = (select classified from enumtype where constenum = -5000) and obj = 1221983186)
select * from billpercent where doc = 211805838

----------------------------------------------------------------------------------
declare
   nValue   objdesc.desctext%type;
begin
  select trim(OD.desctext) into nValue
   from objdesc OD, desclist DL
    where OD.doc = Context.CurrentDoc
     and OD.description = DL.classified
      and DL.constdesc = -1370;
  if nValue is not null then
    :nCondResult := 1;
  else
    :nCondResult := 0;
  end if;
exception
    when others then
      :nCondResult := 0;
end;

----------------------------------------------------------------------------------

create or replace function BillDPPercentSum_TCB(
/******************************************************************************
 Сумма процентов по векселю на заданную дату по указанной ставке
 Дата: 25/04/2013
 Автор: Панфилов М.С.
******************************************************************************/
   nBill       DT.Reference,            -- вексель
   dtPayDate   date,                    -- дата платежа
   DPPerc      Bill.Percent%type        --  процентная ставка по векселю
) return DT.Relation as

   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;
   
-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
-- dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;

begin
   dt_PayDate := trunc(dtPayDate);
   select PayDateVar, BillSum, BillCurrency,
          DPPerc, decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2, DPPerc
     into nPayDateVar, nBillSum, nBillCurr,
          nPercent, dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2, nSecondRate
     from Bill
    where Classified = nBill;

   --  для векселей "по предъявлению", у которых с даты составления или даты "не ранее" прошло более года
   if nPayDateVar = 1 and months_between(dtPercentTo, nvl(dtDate1, dtDrawDate)) >= 12 then
      dtPercentTo := add_months(nvl(dtDate1, dtDrawDate), 12);
   end if;

   if nPayDateVar != 1 and nPayDateVar != 2 then
      -- у векселей не по предъявлению % не бывает
      return null;
   elsif dtPercentTo <= dtPercentFrom then
      return 0;
   end if;
   if dtPercentFrom is null then
      return 0;
   end if;

   dtFirstRateTo := dtPercentTo;
   -- если есть вторая ставка
   if nvl(nSecondRate, 0) > 0 then
      if dtDate2 is not null and dt_PayDate > trunc(dtDate2) then
         dtFirstRateTo := dtDate2;
      end if;
      if dtDate2 is null and dtDate1 is not null and dt_PayDate > trunc(dtDate1) then
         dtFirstRateTo := dtDate1;
      end if;
   end if;
   -- Расчет суммы по первой ставке
   nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
   -- Расчет суммы по второй ставке
   if nvl(nSecondRate, 0) > 0 and dtFirstRateTo < dt_PayDate then
--      DateAddTime(dtPercentFrom, dtFirstRateTo, 1, 1);
      dtPercentFrom := dtFirstRateTo;
      nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
   end if;

   return nPercentSum;
end BillDPPercentSum_TCB;  

----------------------------------------------------------------------------------

create or replace procedure DPC_BillSumCorrection_TCB
/******************************************************************************
 Изменение суммы %% по векселю (коррекция %% для досрочного выкупа по ставке досрочного погашения)
 Дата: 25/04/2013
 Автор: Панфилов М.С.
******************************************************************************/
as
  psum           dt.Amount;
  pallsum        dt.Amount := 0;                -- вся сумма процентов по операции
  allsum         dt.Amount := 0;                -- вся сумма по операции
  sPerc          objdesc.desctext%type;         -- процентная ставка из доп.описания
  nPerc          billrange.percentsum%type;     -- процентная ставка из доп.описания
begin
      -- проверяем доп.описание
      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

dbms_output.put_line('DPC_BillSumCorrection_TCB ->');

begin

  -- если доп.описание есть
  if nPerc is not null then
  for rec in (select br.*, b.billsum from BillRange br, bill b where br.Doc=CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      -- вычислим сумму процентов по новой ставке nPerc
      psum := BillDPPercentSum_TCB(rec.bill,Context.OperDate,nPerc);
      update BillRange set percentsum = psum, rowprice = psum + rec.billsum where bill = rec.bill;
      pallsum := pallsum + psum;
      allsum := allsum + psum + rec.billsum;
      dbms_output.put_line('DPC_BillSumCorrection_TCB <- ' || psum);
    end loop;
    
  update billpercent set percentsum = pallsum where doc = Context.CurrentDoc;
  
  update BillOper set OperSum=allsum, SumFrom=allsum, SumTo=allsum where Doc=CONTEXT.CurrentDoc;
  
  end if;
  
exception
  when others then null;
end;

end DPC_BillSumCorrection_TCB;

----------------------------------------------------------------------------------
declare
   nPercSum      dt.Amount;                          -- начисленные проценты
   nPrePercSum dt.Amount;                          -- ранее начисленные проценты
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания
   bClassified     dt.Reference;
begin

nPrePercSum := nvl(BC.GetBillSum(bc.getbill, bill_p.SumTypeClassified(14)),0);

      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then
  nPercSum := BillDPPercentSum_TCB(bc.getbill,Context.OperDate,nPerc);
else  
  nPercSum := GetBillAccrualSum(bc.getbill,Context.OperDate);
end if;

  if nPercSum >= nPrePercSum then
    :nCondResult := 1;
  else
    :nCondResult := 0;
  end if;

exception
    when others then
      :nCondResult := 1;
end;
----------------------------------------------------------------------------------

create or replace function FUNC_Bill_AccrualAdd_TCB
/******************************************************************************
 Описание: Функция возвращает сумму процентов для доначисления по векселю (с проверкой ставки досрочного погашения при досрочном выкупе):
           >0 - надо доначислить проценты
           <0 - снять излишек процентов
 Автор: Панфилов М.С.
 Версия от: 25/04/2013
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
******************************************************************************/
return DT.Amount as
   nSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   nPercSum      dt.Amount;                          -- начисленные проценты
   nPrePercSum dt.Amount;                          -- ранее начисленные проценты
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания
   bClassified     dt.Reference;
begin

   dtAccrDate := nvl(dtAccrDate, s.ysdate);
   
   nPrePercSum := nvl(BC.GetBillSum(bc.getbill, bill_p.SumTypeClassified(14)),0);

      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then
  nPercSum := BillDPPercentSum_TCB(bc.getbill,Context.OperDate,nPerc);
else  
  nPercSum := GetBillAccrualSum(bc.getbill,Context.OperDate);
end if;
   
   nSum := nPercSum - nPrePercSum;
     
   -- запишем константную сумму (14) для вытаскивания в отчетах
   BC.SaveBillSum(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nSum);

   return nSum;
end FUNC_Bill_AccrualAdd_TCB; 

----------------------------------------------------------------------------------

od.FUNC_BILL_PREVYEARPERC_DELTA

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

select (5000000 - 4980965)/5 from dual
select * from account where classified = 177651662

select * from od.memoorder m where m.classified = 177651662
select * from doctype

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------





























----------------------------------------------------------------------------------
--01/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.FUNC_BILL_NEWPERCENT_DELTA
bill_p.SumTypeClassified

select * from od.BillSumType


select rowid, f.* from fx f where ticket in (2499920,2499921,2498195)
select * from tbl_ford32 where ticket in (2499920,2499921),2498195)

od.SP_SWA_PREPFOROTHERSYSTEMS(p_id,'CONV','DELETE');
----------------------------------------------------------------------------------
--02/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select* from doctree where classified in (210402507, 208873104) 

select* from doctree where classified in (208892188, 210425962)

select* from doctype where classified = 1000160977

select* from doctree where operdate > sysdate - 30 and category = 702 -- doctype = 1000237136

select* from doccategory

select * from sysfilial where code in (2,4,13,14)

----------------------------------------------------------------------------------
--04/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.DPC_TCB_DealSwift_MT399



-- Иные
-- 8
SELECT h.bill
,d.operdate
,b.series
,b.num
,OD.clientlabeltcb(b.maker) as issuer 
,r.rowprice
,g.issolo
,h.doc
,b.sysfilial
,f.label as branch
,h.status
FROM od.bill b
,od.billstatushistory h
,od.billoper o
,od.billrange r
,od.doctree d
,od.billgroup g
,od.filial f
WHERE r.bill = b.classified AND b.sysfilial = 2
AND o.doc = r.doc
AND r.doc = d.classified
AND d.classified = h.doc
AND f.sysfilial = b.sysfilial
AND b.maker<>1
AND h.bill = b.classified 
AND g.classified = b.billgroup
AND (h.status in (42,46) OR r.rowprice = b.billsum AND d.operdate >= b.date1 AND h.status = 8)
AND h.startdate >= to_date('121001','yymmdd')
AND h.startdate <= to_date('130407','yymmdd')

-- Регистр


select 
h.bill
,od.clientlabeltcb(b.maker) as issuer

,g.label
,nvl(o.docdate,(select min(v.operdate) from OD.docvisa v where v.doc = h.doc)) as docDate 
,b.series
,b.num
,d.operdate
,d.label dtlabel
,h.status
,g.issolo
,b.sysfilial
,f.label     as branch
,o.numdoc 
FROM od.bill b
,od.billstatushistory h
,od
.billoper o
,od.billrange r
,od.doctree d
,od.billgroup g
,od.filial f
WHERE r.bill = b.classified AND b.sysfilial = 2 and h.status = 8
AND o.doc = r.doc
AND r.doc = d.classified
AND d.classified = h.doc
AND f.sysfilial  = b.sysfilial
AND b.maker<>1
AND h.bill = b.classified 
AND g.classified = b.billgroup
AND 
(h.status = 6 
AND h.enddate >= to_date('121001','yymmdd')
AND h.startdate <= to_date('130407','yymmdd')
OR
h.status IN (8, 42, 46)
AND h.startdate >= to_date('121001','yymmdd')
AND startdate <= to_date('130407','yymmdd')
)


----------------------------------------------------------------------------------
-- Епанова из Перми накосячила с переучетом чужих векселей (вместо переучёта должны быть погашения чужих векселей)                                     ++
-- чтобы у Политовой сошелся отчет в Forts нужен update по статусам векселей                                                                           ++
-- update по 25 векселю ( с 01/10/2012 )                                                                                                               ++
----------------------------------------------------------------------------------
select * from bill where num = '0415513'
select * from billstatushistory where bill in (select classified from bill where num = '0415513')
select * from sysfilial 
-- IPI 47765 IPI 67594

update bill set status = 46 where status = 8 and sysfilial = 2 and classified in (select bill from billstatushistory where status = 8 and startdate >= to_date('121001','yymmdd'))

update billstatushistory set status = 46 where status = 8 and startdate >= to_date('121001','yymmdd') and bill in (select classified from bill where sysfilial = 2)
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

od.FUNC_BILL_NEWPERCENT_DELTA

od.FUNC_BILL_THISYEARPERC_DELTA

od.FUNC_BILL_PREVYEARPERC_DELTA

od.FUNC_BILL_OSTDISCNEVIPL

 od.func_bill_owndisc_discoff - od.func_bill_vipldisc;

od.FUNC_BILL_OSTVIPL
od.FUNC_BILL_REINCOME - -- списанный на расходы дисконт

od.FUNC_BILL_SUMDISCLASTYEAR

od.FUNC_BILL_DISCLASTYEAR
od.FUNC_BILL_DISCTHISYEAR
od.FUNC_BILL_RAZN
od.FUNC_BILL_NOM_OWNRED
od.FUNC_TCB_BILL_NAL

----------------------------------------------------------------------------------
--05/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doccategory where category in (702,703)
select * from billsumtype where consttype in (11,15)
select * from billsumtype where classified = 1042775368
select * from billrange where tax is not null

DECLARE
  namount dt.amount;
  nprice  dt.amount;
BEGIN

  namount := nvl(bc.getbillopersum(bc.getbill,3),0) - (nvl(bc.getbillopersum(bc.getbill, 1), 0) -
             nvl(bc.getbillsum(bc.getbill, 11), 0));

  dbms_output.put_line('nAmount= ' || namount);
  IF namount > 0 AND nvl(bc.getbillopersum(bc.getbill,3),0)< nvl(bc.getbillopersum(bc.getbill, 1), 0) THEN
    :ncondresult := 1;
  ELSE
    :ncondresult := 0;
  END IF;
END;
-----------------
DECLARE
  namount dt.amount;
  
BEGIN

  namount := nvl(bc.getbillopersum(bc.getbill,3),0) - (nvl(bc.getbillopersum(bc.getbill, 1), 0) -
             nvl(bc.getbillsum(bc.getbill, 11), 0));


  dbms_output.put_line('nAmount= ' || namount);
  IF namount = 0 AND nvl(bc.getbillopersum(bc.getbill,3),0) <> nvl(bc.getbillopersum(bc.getbill, 1), 0) THEN
    :ncondresult := 1;
  ELSE
    :ncondresult := 0;
  END IF;

END;
-----------------
DECLARE
  namount dt.amount;
  nprice  dt.amount;
BEGIN

  namount := nvl(bc.getbillopersum(bc.getbill,3),0)- (nvl(bc.getbillopersum(bc.getbill, 1), 0) -
             nvl(bc.getbillsum(bc.getbill, 11), 0));

  dbms_output.put_line('nAmount= ' || namount);
  IF namount < 0 THEN
    :ncondresult := 1;
  ELSE
    :ncondresult := 0;
  END IF;
END;

----------------------------------------------------------------------------------
--08/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.FXEvent_Doc

bbr.BBR_TCB_BILL_OPER_MSK
----------------------------------------------------------------------------------
-- в BBR_TCB_BILL_OPER_MSK столбцы 44,45 "проценты/дисконт за 2012 год" переделал в "проценты/дисконт за период"  (просила Филимонова)                             ++
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--09/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from od.curopermain

----------------------------------------------------------------------------------
--15/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- Филимонова накосячила с переучетом чужих векселей (вместо переучёта должны быть погашения чужих векселей)                                           ++
-- нужен update по статусам векселей (0031849)                                                                                                         ++
----------------------------------------------------------------------------------
select * from bill where num = '0031849'
select rowid, b.* from billstatushistory b where bill in (select classified from bill where num = '0031849')

update bill set status = 46 where classified = 1185102007

update billstatushistory set status = 46 where bill = 1185102007 

0 44 6 44 14 8/46
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------


SELECT SUBSTR (d.ticket,-7)
      ,d.dealdate
      ,get_bankcode(d.counterparty,1000104502) 
      ,clientlabel(d.counterparty)
      ,d.valuedate
      ,d.amountb
      ,getcurrencyname(d.currencyb)
      ,d.rate
      ,d.maturitydate
      ,d.amounts
      ,getcurrencyname(d.currencys)
 FROM deal d, doctree dt
WHERE d.doctype = 1047169221
   AND d.istimed = 2
   AND d.valuedate > td - 10
   AND d.doc = dt.classified AND dt.docstate not in (1000000037)

select * from docstate

Ресурс-Навигатор

SELECT t.ticket
      ,t.tradedate
      ,c.code_value
      ,ct.custname
      ,t.valuebuy
      ,t.buy 
      ,f_ccy_iso(t.instr_b)
      ,t.rate
      ,t.valuesell
      ,t.sell
      ,f_ccy_iso(t.instr_s)
      ,t.status
  FROM fx t
      ,customer ct
      ,(SELECT * FROM codes WHERE type_id = 53 ) c 
 WHERE /*t.valuebuy > td - 20
   AND t.sec_tradeaccount_id = 6062
      AND*/ t.cid = ct.id
      AND t.cid =c.entity_id(+)
      AND ct.id <> 32 and t.status not in (0,2)


----------------------------------------------------------------------------------
--16/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

report.tp_account_tcb

od.tp_account_tcb

od.tp_account_tcb.getAccountByTarget

od.tcb_rsrv.getRsrvElement
od.tcb_rsrv.getRsrvRestByRsrvElement


begin
  od.tcb_bki_mbk_proc(sysdate,8);
end;

od.fxevent_doc

   -- Проверяем счет платежа на наш банк
   -- В этом случае будет внутр. перевод. В поле Nostro должен быть второй счет.
   if recDT.AmountType in (1,2) then
      n_DocCat := 2;
      nOurAcc := recDT.Nostro;
   elsif (recDT.BeneficiaryBank = Pref.OurBank and nvl(recDT.IsExtPay, 0) = 0) then -- внутренний перевод если не указан внешний платеж
      n_DocCat := 1;
      
      

----------------------------------------------------------------------------------
--17/04/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from DealTransaction where Doc = Context.CurrentDoc;
select * into recTrType from DealTrType where Classified = recDT.TransactionType;

(recDT.BeneficiaryBank = Pref.OurBank and acccode(recDT.Nostro) not like '30109%' and recTrType.Sign = 1)
         or (recDT.BeneficiaryBank = Pref.OurBank and recTrType.Sign != 1)
         
select * from doctree where classified = 89503901 
select * from DealTrType     
select * from preference    
         
select * from DealTransaction recDT where recDT.doctype = 1047168747 /*and recDT.BeneficiaryBank != 1*/ 
and ( (recDT.Transactiontype in (1,3)) or (recDT.Transactiontype in (2,4) and acccode(recDT.Nostro) like '30109%') )

select dt.label, d.*, acccode(d.Nostro), d.transactiontype from DealTransaction d, doctree dt where d.doc = dt.classified and d.doctype = 1047168747 and ( LOWER(dt.label) like '%loro%' or LOWER(dt.label) like '%лоро%') 
and d.Transactiontype in (1,3)
MINUS


----------------------------------------------------------------------------------
-- наконец исправление замечания 41994 включено в официальный патч. после установки нужен update:                                                                 ++ 
-- протестить                                                                                                                                                     ++
-- прогнать на боевой                                                                                                                                             ++
----------------------------------------------------------------------------------
select dt.label, d.*, acccode(d.Nostro), d.transactiontype from DealTransaction d, doctree dt where d.doc = dt.classified and d.doctype = 1047168747 and substr(acccode(d.Nostro), 1, 5) = '30109' and d.doc not in (
select doc from DealTransaction recDT where recDT.BeneficiaryBank = 1 and recDT.doctype = 1047168747 and substr(acccode(d.Nostro), 1, 5) = '30109' 
and ( (recDT.Transactiontype in (2,4)) or (recDT.Transactiontype in (1,3) and acccode(recDT.Nostro) not like '30109%') )
)

-- 54 платежных инструкции
update DealTransaction set ISEXTPAY = 1 where doc in (
select d.doc from DealTransaction d, doctree dt where d.doc = dt.classified and d.doctype = 1047168747 and substr(acccode(d.Nostro), 1, 5) = '30109' and d.doc not in (
select doc from DealTransaction recDT where recDT.BeneficiaryBank = 1 and recDT.doctype = 1047168747 and substr(acccode(d.Nostro), 1, 5) = '30109' 
and ( (recDT.Transactiontype in (2,4)) or (recDT.Transactiontype in (1,3) and acccode(recDT.Nostro) not like '30109%') )
)
)
--
 


----------------------------------------------------------------------------------
--06/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- привязывал вручную срочные счета по форексным сделкам к цепочкам 

     select dt.Classified, dt.ValidToDate
       from DocTree dt, Reestr r
      where dt.Classified = r.ReestrInit
        and r.EndDate = TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')       --  Документ не закрыт
        and r.Type = 1          --  Остаток-реальный
        and r.DocSum != 0               --  Остаток ненулевой
        and r.AccountWithReestr = nAccWR
        and dt.ValidToDate < dtValidMin; 


select * from doctree where classified = 214022792

select * from od.account where doc = 214022792


     select a.Classified
       from Account a
      where a.Type in ( select Classified
                          from AccountType
                         where Category = 66 -- Срочные счета
                           and IsNeedReestr = 1 )           -- Признак ведения реестра по счету
        and a.Opened <= to_date('130501','yymmdd')
        and a.Closed  > to_date('130501','yymmdd')
        and a.SysFilial = 1 and a.classified = 214022792;
        
----------------------------------------------------------------------------------
--07/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
-- для Питера нужно поправить векселя                                                                                                                         ++
-- чтобы у Политовой сошелся отчет в Forts нужен update по статусу векселей для '0238219' и '0238220'                                                                      ++
-- и update векселедателя для 004949                                                                                                                          ++
----------------------------------------------------------------------------------
select * from bill where num = '0238219'
select * from bill where num = '0238220'
select * from billstatushistory where bill in (select classified from bill where num = '0238219')
select * from sysfilial 
-- IPI 47765 IPI 67594

update bill set status = 46 where status = 8 and classified in (select bill from billstatushistory where status = 8 and classified = 1206803512)
update billstatushistory set status = 46 where status = 8 and bill in (select classified from bill where classified = 1206803512)

update bill set status = 46 where status = 8 and classified in (select bill from billstatushistory where status = 8 and classified = 1206803997)
update billstatushistory set status = 46 where status = 8 and bill in (select classified from bill where classified = 1206803997)

select * from bill where num = '0238219'
select * from bill where num = '004949'
update bill set maker = 24471 where classified = 1202884107

update bill set maker = 26409 where classified = 1206803512
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--08/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_FXDeal_AccSet

od.deal_createaccount_tcb
od.GetReservAcc_REV_TCB

select distinct Account from od.ReservAttrForNormals where reservaccount in (select classified from account where code = '30126810100009740001')

----------------------------------------------------------------------------------
--13/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- после заведения в RN нового ККО или ДО сделки по ним в автомате начнут качаться только со следующего дня
select * from department where classified in (1012813432, 1012801276)
select * from tcb_crc32 t where t.classified = 215118784


-- Питер накосячил с переучетами дисконтных векселей, пришлось апдейтить                                                                                         ++
select * from doctree where classified = 203031298
select * from bill where num = '004949' -- 2928875,03
select * from billrange where bill in (select classified from bill where num = '004949') and doc = 203031298
select * from billoper where doc = 203031298
update billrange set rowprice = 2655663, priceinsum = 2655663, discount = 2928875.03 - 2655663 where bill in (select classified from bill where num = '004949') and doc = 203031298
update billoper set opersum = 2655663, sumto = 2655663, sumfrom = 2655663 where doc = 203031298;

select * from doctree where classified = 204464720
select * from billrange where /*bill in (select classified from bill where num = '004949') and*/ doc = 204464720
select * from billoper where doc = 204464720
update billrange set rowprice = 1005424.79, priceinsum = 1005424.79, discount = 5424.79 where /*bill in (select classified from bill where num = '004949') and*/ doc = 204464720
update billoper set opersum = 2010849.58, sumto = 2010849.58, sumfrom = 2010849.58 where doc = 204464720;

select * from doctree where classified = 204461788
select * from billrange where /*bill in (select classified from bill where num = '004949') and*/ doc = 204461788
select * from billoper where doc = 204461788
update billrange set rowprice = 1005424.79, priceinsum = 1005424.79, discount = 5424.79 where /*bill in (select classified from bill where num = '004949') and*/ doc = 204461788
update billoper set opersum = 2010849.58, sumto = 2010849.58, sumfrom = 2010849.58 where doc = 204461788;
----------------------------------------------------------------------------------
--14/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.fxevent_doc
DealTransaction 


SELECT h.bill
,t.label dealNum
,o.numdoc
,t.operdate
,h.status
,od.clientlabeltcb(o.client) as client
,b.billsum as face
,g.issolo
,b.series
,b.num
,od.clientlabeltcb(b.maker) as issuer
,r.rowprice as summa
,od.getcurrencyname(o.currencyfrom) as frCur
,od.getcurrencyname(o.currencyto) as toCur
,od.NationBankRate(o.currencyto,t.operdate)  as toRate 
,b.sysfilial ,f.label as branch ,nvl(o.docdate,(select min(v.operdate) from OD.docvisa v where v.doc = h.doc)) as docDate 
,o.postdate ,o.opldate ,o.factpostdate ,o.factopldate 
FROM od.bill b ,od.billstatushistory h ,od.billoper o ,od.billrange r ,od.doctree t ,od.billgroup g ,od.filial f 
WHERE r.bill = b.classified AND o.doc = r.doc AND r.doc = t.classified AND t.classified = h.doc AND f.sysfilial = b.sysfilial AND b.maker<>1 AND h.bill = b.classified AND g.classified = b.billgroup AND h.status IN ( 6, 8) AND h.startdate >= to_date('130212','yyMMdd') AND h.startdate <= to_date('130212','yyMMdd')

----------------------------------------------------------------------------------
--21/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree d where d.category = 702

9.10.13

select * from sysfilial

fx

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- задача 141169 от Герасимовой                                                                                                                                      ++
--- на best:      
---- в manager:                                                                                                                                                      
----- для "Выдачи векселей" добавить тип связанного объекта "Дочерние внутренние переводы 525/523" (только для МОСКВЫ !!!!!!!!!!!!)                                  ++
----- навесить на действие "Обработать" две обработки связанных объектов "Дочерние внутренние переводы 525/523" Создан -> Доступен в работе -> Исполнен              ++

----- для "Перенос векселей на счета к исполнению" добавить тип связанного объекта "Дочерние внутренние переводы 523/52406" (только для МОСКВЫ !!!!!!!!!!!!)         ++
----- навесить на действие "Исполнить" две обработки связанных объектов "Дочерние внутренние переводы 523/52406" Создан -> Доступен в работе -> Исполнен             ++                                          

--- проблема с правами в !!!!!!!!!!! DPC_DOCCHECKOPERDATE
--- согласовать с Прозоровой                                                                                                                                         ++
--- настроить на боевой                                                                                                                                              ++

---дополнительно настраивал 03/07/2013:
----- для "Изменение срочности векселя" добавить тип связанного объекта "Дочерние внутренние переводы 523/52301" (только для МОСКВЫ !!!!!!!!!!!!)                    ++
----- навесить на действие "Исполнить" две обработки связанных объектов "Дочерние внутренние переводы 523/52301" Создан -> Доступен в работе -> Исполнен             ++
---- поправил шаблон выбора векселей в операции "Досрочный выкуп собственного векселя" и "Погашение векселя", чтобы там по-умолчанию показывались векселя только в статусе "в обращении"  ++

--- нужен дополнительный отчет по автоматизированным операциям на основе bbr.BBR_EXECUTOR_REESTR_DEP                                                                 ++
--- исключить из DPC_UPDATE_CREATOR_TCB следующие типы документов: 
select * from doctype where classified in (1065488246,1065651113,1065672640,1065658588)
select * from doctype where classified = 1065523598
od.DPC_UPDATE_CREATOR_TCB

od.MAKEBILLEVERYDAY_TCB

od.DPC_DOCCHECKOPERDATE

select * from EntityMessage
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from DealSwapPayment where doc = 182178585 -- график платежей
select rowid, d.* from DealSwapInterest d where doc = 217676054 -- график процентных периодов
select * from od.Dealswappayperiod where interestperiod in (select classified from DealSwapInterest where doc = 217673359)
select * from v_DealSwapIntLog

select * from doctree where classified in (182178733, 182178860)
select * from obj where classified in (1180622900, 1180623295)

od.ut_dealaccrual
----------------------------------------------------------------------------------
--22/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doccategory where category = 722
od.DPC_CB_UPDATE_CREATOR_TCB

select (15000000*(0.0245+0.002955)*(to_date('06/05/2013','dd/mm/yyyy')-to_date('04/02/2013','dd/mm/yyyy')))/365 from dual

----------------------------------------------------------------------------------
--28/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил od.DPC_TCB_DealSwift_MT399                                                                                                                         ++
od.DPC_TCB_DealSwift_MT399
select od.clientaddress from 
select clientaddress(26237) from dual

select * from deal where doc = 217272607


----------------------------------------------------------------------------------
--29/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.DPC_CreatePercentAccountDoc
select * from docstate 
select * from od.CONSTANTS
select * from subsystem 
select * from doctree where classified = 194012298
select * from dealtransaction


create or replace procedure DPC_DealEventToState_Close_TCB
/**********************************************************************************
 Автор: Панфилов М.С. 
 Описание: Процедура для автоматического перевода всех событий по сделке с момента создания по опер.дату из состояния "Создан" в "Исполнен"
 Версия: 29.05.2013 Процедура может работать на документе "Депозитная сделка".
**********************************************************************************/
as
   nCategory         DocTree.Category%type;
   nDeal             DT.Reference;
begin
   select Category into nCategory from DocTree where Classified = Context.CurrentDoc;
   if nCategory = 908 then
      -- депозитная сделка
      nDeal := Context.CurrentDoc;
      -- ищем все дочерние события в статусе "Создан" с датой валютирования не больше опердаты 
      for dt in (select dt.* from dealtransaction dt, doctree d 
             where d.parent = nDeal and d.classified = dt.doc and d.category = 905 and /*d.entitystate = 1047170433*/ d.docstate = 1000000034 and dt.valuedate <= Context.OperDate)
      loop
        --DocProcessForChild(dt.doc,dt.valuedate,9,1000000035);
        dbms_output.put_line('classified= ' || dt.doc);
        update doctree set docstate = 1000000035, entitystate = 1047170430 where classified = dt.doc;
      end loop;
   end if;
end DPC_DealEventToState_Close_TCB;

create or replace procedure DPC_DealEventToState_Close_TC1
/**********************************************************************************
 Автор: Панфилов М.С. 
 Описание: Процедура для автоматического перевода события по сделке с момента создания по опер.дату из состояния в "Исполнен"
 Версия: 29.05.2013 Процедура может работать на документе "Событие сделки".
**********************************************************************************/
as
   nCategory       DocTree.Category%type;
   nDT             DT.Reference;
begin
   select Category into nCategory from DocTree where Classified = Context.CurrentDoc;
   if nCategory = 905 then
      -- событие сделки
      nDT := Context.CurrentDoc;

        update doctree set docstate = 1000000035, entitystate = 1047170430 where classified = nDT;
 
   end if;
end DPC_DealEventToState_Close_TC1;




update doctree set docstate = 1000000035 where classified = 182177586;

select * from doctree where classified in (182177586,182177727)
select * from entitystate where entityclass = 1047170421 classified = 1047170433

select * from entityclass where classified = 1047170421

 delete  from billaccount where account = 217403860 -- в Перми заглючил учет векселя - подтягивался счет 47408 вместо 47407 -> пришлось зачистить pact по векселю
select * from billaccount where account in (select classified from account where code = '47408810000100000019')
select * from billaccount where account = 217537588
--update billaccount set pact = null where account in (select classified from account where code = '47408810700100000018')
select * from billaccount where pact = 217403858

od.getbillaccount

select * from billaccount where bill = 1235844477
select * from account where classified = 109532378

select * from bill where num = '0324686'
-- select rowid, f.* from fx f where ticket = 2551253 откатывал по просьбе Анучина
----------------------------------------------------------------------------------
--30/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

SELECT   DT.Classified,SUBSTR( DocTypeLabel( DT.DocType ), 1, 50 ), DT.Label, DT.DocType, ' ', ' ', DT.OperDate, null, DT.DealDate, DT.ValueDate, DT.MaturityDate, substr( DealerCode( DT.Dealer ), 1, 50 ), null, substr( ClientLabel( DT.CounterParty ), 1, 50 ), substr( ClientLabel( DT.ProfitCentr ), 1, 50 ), DT.ExternalRef, substr( CompetitorLabel( DT.Market ), 1, 50 ), null, DT.Ticket, substr( CurrencyISO( DT.CurrencyB ), 1, 3 ), substr( FmtDocSum( DT.AmountB, DT.CurrencyB ), 1, 50 ), DT.AmountB, DT.InterestRate, null, /*L.Label,*/ null, null,  substr( ObjAttrCheck.GetOneDesc( DT.Classified, ObjAttrCheck.DescClass( 54 ) ), 1, 254 ), 
DT.OperDate, SUBSTR( UserPseudoName( DT.OperID ), 1, 50 ), DT.OperCause,
    SUBSTR(EntityStateLabel( DT.EntityState ), 1, 50), DT.Description, SUBSTR( UserPseudoName( DT.AuthorID ), 1, 50 ), SUBSTR( CategoryLabel( DT.Category ), 1, 50 ), 
 0, EntityStateColor( DT.EntityState ), DT.DocState, DT.DocType, DT.Category  
 FROM  V_DealDeposit DT
   WHERE 1 = 1
    AND  DT.OperDate >= TO_DATE( '2013-01-01-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
    AND DT.OperDate < TO_DATE( '2013-05-31-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
    AND (EXISTS (SELECT Doc FROM WorkFlow
            WHERE Doc = DT.Classified
                AND WorkPlace = 1047766549)
        OR Bit_Proc.CheckBit(DT.IsHidden, 3) != 1)
    AND DT.DocType IN ( 1179850206 ) AND ROWNUM <= 100 
 ORDER BY 40 
 
sys.
deal1158

-- запуск Траншей МБК / правил od.tcb_set_57d_payreq                                                                                                            ++
-- проблема с отбором траншей с КЛ в общем отборе CtrlF5 "Детали" => написал в НА => зарегистрировали замечание 46785, планируют исправить 18/06/2013 =>        
-- планируют исправить Замечание №46785 исправлено. Результатом исправления явился общий объект SL_DEAL.APL32 версии 5.03.18 
-- Замечание запланировано на включение в сборку 5.0х.хххх - 31.08.2013г 31/08/2013                                                                             ++
-- нет отбора КЛ в общем отборе CtrlF5                                                                                                                          
-- если  по траншу в один день и процентный платеж и ручная амортизация, то процентный график строится без учета в ОД этой ручной амортизации
-- (проблема в процедуре od.dealdep_proc.FillDealDepInterest) => написал в НА => зарегистрировали замечание 46796 => прислали временный скрипт 46796.sql 
-- => конечный скрипт deal1158.sql                                                                                                                              ++
-- аккуратно прогнать на боевой скрипт deal1158.sql                                                                                                             ++
-- написать процедуру и повесить на событие депозитной сделки в статусе "Создан", чтобы меняла дату валютирования SPEC_setvaluedate_tcb                         ++
-- неадекватное поведение графиков после удаления одной регулярной амортизации (пример: сделка 1988284) => нужно просто правильно оформить (через доп.согл)     ++
-- криво отображается текущий остаток на главной форме DEALDEPOSIT.AMOUNTREST => из-за кривых реестров
-- (по траншам решили делать счета 313* реестровыми, чтобы было одинаково, как и для обычных МБК сделок)                                                        ++
-- при старте Транша привлечения создаются события требования (+), хотя должны быть обязательства (-), спасает принудительное перестроение графика, 
-- но при принудительном перестроении графика не прописывается счет контрагента по перечислению процентов (делал update по всем кривосозданным событиям)
-- => подвинул процедуру dpc_dealtrans_settransacc вниз на "Утверждении" "Траншей" в manager + написал в НА (пока поправил DPC_DepositDeal_Events, потом вернуть) 
-- => зарегистрировали замечание 46852 => конечный скрипт deal1159.sql (+ deal1106.sql)                                                                         ++
-- назначения платежей                                                                                                                                          ++
---- по начислению процентов: процедура DealBegProcDate некорректна, если проценты начисляются в один день, а уплачиваются позже                                
---- по уплате процентов: нужны теги <дата начала предыдущего периода начисления процентов>, <номер кредитной линии транша> <дата открытия кредитной линии транша>
---- по уплате ОД 
---- => написал в НА про доп. теги в DEAL_GetPaymentPurpose => зарегистрировали замечание 46876 => прислали скрипт deal1164.sql => накатил 13/06/2013 
---- + дописать самому DealBegProcDate2, DPC_TCB_DESC_FOR_DILING и DEAL_GetPaymentPurpose !!!

od.DEAL_GetPaymentPurpose
od.DPC_TCB_DESC_FOR_DILING      

select * from deal d where d.creditline is not null

create or replace function DealBegProcDate2(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления даты начала предыдущего периода начисления процентов по траншу.
-- Автор: Пнафилов М.С. (на основе DealBegProcDate)
-- Версия: 14.04.2011
--         10.06.2013 адаптирована для сделок траншей МБК (Зам. № 46876)
--         13.06.2013 Панфилов М.С.
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference  -- идентификатор сделки
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null or nIsTransh = 1 then
      --это не депозитная сделка, не транш
      return null;
   end if;
      -- дата начала предыдущего периода начисления процентов по траншу
      select bd into dtPercbegdate from 
          (SELECT trunc(bd) as bd,
                  row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
              FROM (select DISTINCT trunc(OperDate) as bd, doc from DealSwapInterestLog) b
             WHERE doc = nDoc) x where x.rang = 2;
   return dtPercBegDate;
end DealBegProcDate2;

create or replace function DEAL_GetPaymentPurpose
/******************************************************************************
 Автор: Цветков В.
 Описание: Получение шаблона строки назначения платежа из PAYMENTPURPOSE по ключу и раскрытие макросов
 24.06.2010 по заданию 2161-У.
 Версия:
 13.11.2010 Доработка 31804: function DEAL_GetPaymentPurpose -
                Исправлено раскрытие макроса <DocOperDate> и <DealDate>(формат)
 19.04.2011 Новые тэги
 16.05.2011 Тэг <TICKET> (тикет сделки)
 27.05.2011 вместо nDoc должен быть nDeal в вызове BEGPROCDATE и в процедуре
            LoadDealNettingRec.
 12.12.2012 добавлен тэг BEGACCRDATE - дата начала начисления процентов (Зам. № 44161, AGN)
 13.06.2013 Панфилов М.С. добавлены тэги <CLLabel>, <CLVALUEDATE>, <BEGPROCDATE2>
 ******************************************************************************/
(  sTemplateCode  DT.Text,        -- Код строки-шаблона
   nDeal          DT.Reference,   -- Сделка
   nDoc           DT.Reference,   -- Документ
   sExtraText     DT.Text         -- Дополнительный текст
)
return DT.Text as
   sPurpose       DT.Text;
   recDeal        Deal%rowtype;
   recDocTree     DocTree%rowtype;
   recDealReserv  DealReserv%rowtype;
   recDealROLL    Deal%rowtype;
   recDealDeposit DealDeposit%rowtype;
   recDealNetting DealNetting%rowtype;
   recDealTrans   DealTransaction%rowtype;
   recDocTreeCL   DocTree%rowtype;
   recDealCL      Deal%rowtype;
   --
   sCurrTag       Dt.Text;
   sDTFMT         constant Dt.Label := 'DD/MM/YYYY';
   sDTFMT1        constant Dt.Label := 'DD.MM.YY';
   dtDateTemp     Date;
   --
   procedure LoadDealRec as
      cursor c is select * from Deal where Doc = nDeal;
   begin
      if recDeal.Doc is null then
         open c;
         fetch c into recDeal;
         close c;
      end if ;
   end LoadDealRec;
   --
   procedure LoadDocRec as
      cursor c is select * from DocTree where Classified = nDoc;
   begin
      if recDoctree.Classified is null then
         open c;
         fetch c into recDocTree;
         close c;
      end if ;
   end LoadDocRec;
   --
   procedure LoadDealReservRec as
      cursor c is select * from DealReserv where Doc = nDoc;
   begin
      if recDealReserv.Doc is null then
         open c;
         fetch c into recDealReserv;
         close c;
      end if ;
   end LoadDealReservRec;
   --
   procedure LoadDealRollRec as
      cursor c is select * from Deal where Doc =
         (select Deal from DealRollover where Doc = nDeal);
   begin
      if recDealRoll.Doc is null then
         open c;
         fetch c into recDealRoll;
         close c;
      end if ;
   end LoadDealRollRec;
   --
   procedure LoadDealDepositRec as
      cursor c is select * from DealDeposit where Doc = nDeal;
   begin
      if recDealDeposit.Doc is null then
         open c;
         fetch c into recDealDeposit;
         close c;
      end if ;
   end LoadDealDepositRec;
   --
   procedure LoadDealNettingRec as
      cursor c is select * from DealNetting where Doc = nDeal;--nDoc;
   begin
      if recDealNetting.Doc is null then
         open c;
         fetch c into recDealNetting;
         close c;
      end if ;
   end LoadDealNettingRec;
   --
   procedure LoadDealTransRec as
      cursor c is select * from DealTransaction where Doc = nDoc;
   begin
      if recDealTrans.Doc is null then
         open c;
         fetch c into recDealTrans;
         close c;
      end if ;
   end LoadDealTransRec;
   --
   procedure LoadDocCLRec as
      cursor c is select * from DocTree where Classified = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDocTreeCL.Classified is null then
         open c;
         fetch c into recDocTreeCL;
         close c;
      end if ;
   end LoadDocCLRec;
   --
   procedure LoadDealCLRec as
      cursor c is select * from Deal where Doc = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDealCL.Doc is null then
         open c;
         fetch c into recDealCL;
         close c;
      end if ;
   end LoadDealCLRec;
   --
begin
    begin
        select value into sPurpose from dealpaymentpurpose where fullname =  sTemplateCode;
    exception when NO_DATA_FOUND then
        --raise_application_error(-20000, 'Шаблон не найден. Код ' || sTemplateCode) ;
        tm_proc.RaiseError(42212, sTemplateCode);
    end;

--   dbms_output.put_line('1 ' || spurpose);

   sCurrTag := '<DealLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('2 ' || spurpose);

   sCurrTag := '<DealDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDeal.DealDate); --to_char(recDeal.DealDate,'DD.MM.YYYY'));
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT));
   end if ;

--   dbms_output.put_line('3 ' || spurpose);

   sCurrTag := '<ExtraText>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag, sExtraText);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocDescription>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Description);
   end if ;

--   dbms_output.put_line('5 ' || spurpose);

   sCurrTag := '<DocOperDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDocTree.OperDate);
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT));
   end if ;

--   dbms_output.put_line('6 ' || spurpose);

   sCurrTag := '<RiskGroup>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        if recDocTree.Category = 914 then
            LoadDealReservRec;
            sPurpose := replace(sPurpose, sCurrTag, PactRiskGrouplabel(NVL(recDealReserv.RiskGroup, recDealReserv.OldRiskGroup)));
        else
            sPurpose := replace(sPurpose, sCurrTag, '');
        end if;
   end if ;

--   dbms_output.put_line('7 ' || spurpose);

   sCurrTag := '<COUNTERPARTY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDeal.CounterParty));
--dbms_output.put_line('8 ' || spurpose);
   end if ;

   sCurrTag := '<TICKETROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, recDealRoll.Ticket);
--dbms_output.put_line('9 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealRoll.CounterParty));
--dbms_output.put_line('10 ' || spurpose);
   end if ;

   sCurrTag := '<ROLLDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealDepositRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealDeposit.RollOverStartDate,sDTFMT));
--dbms_output.put_line('11 ' || spurpose);
   end if ;


   sCurrTag := '<OPERDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT1));
--dbms_output.put_line('12 ' || spurpose);
   end if ;

   sCurrTag := '<EXTRACT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Extract);
--dbms_output.put_line('13 ' || spurpose);
   end if ;

   sCurrTag := '<TRANSACTDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT1));
--dbms_output.put_line('14 ' || spurpose);
   end if ;

   sCurrTag := '<VALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealNetting.ValueDate,sDTFMT1));
--dbms_output.put_line('15 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYNET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealNetting.CounterParty));
--dbms_output.put_line('16 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARYBANK>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.BeneficiaryBank));
--dbms_output.put_line('17 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.Beneficiary));
--dbms_output.put_line('18 ' || spurpose);
   end if ;

   sCurrTag := '<BEGPROCDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate(nDeal),sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;
   -- дата начала начисления %%
   sCurrTag := '<BEGACCRDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      dtDateTemp := trunc(DealBegProcDate(nDeal)); -- дата последнего начисления %%
      if dtDateTemp > recDeal.ValueDate + 1 then
         dtDateTemp := dtDateTemp + 1;
      else
         dtDateTemp := recDeal.ValueDate + 1;
      end if;
      sPurpose := replace(sPurpose, sCurrTag, to_char(dtDateTemp,sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONAMOUNT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        recDealTrans.Amount);
--dbms_output.put_line('20 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealTrans.ValueDate,sDTFMT));
--dbms_output.put_line('21 ' || spurpose);
   end if ;

   sCurrTag := '<DOCTREEDOCVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDocTree.DocValueDate,sDTFMT));
--dbms_output.put_line('22 ' || spurpose);
   end if ;

    --тикет сделки (Deal.TICKET)
   sCurrTag := '<TICKET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, recDeal.Ticket);
   end if ;
   
   --кредитная линия по траншу (Deal.CREDITLINE.Label)
   sCurrTag := '<CLLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocCLRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTreeCL.Label);
   end if ;
   
   --дата начала кредитной линии по траншу (Deal.CREDITLINE.VALUEDATE)
   sCurrTag := '<CLVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealClRec;
        sPurpose := replace(sPurpose, sCurrTag, to_char(recDealCL.ValueDate,sDTFMT));
   end if ;
   
   --дата начала предыдущего периода начисления %% по траншу 
   sCurrTag := '<BEGPROCDATE2>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate2(nDeal),sDTFMT));
   end if ;

   return SUBSTR(sPurpose,1,254);

end DEAL_GetPaymentPurpose;

CREATE OR REPLACE PROCEDURE DPC_TCB_DESC_FOR_DILING AS
-----------------------------------------------------------------------------------
-- Заполнение назначения платежа в событиях сделок.
-- 16/05/2011 Панфилов М.С. - добавлено назначение для налога на доходы нерезидентов
-- 27/08/2012 Панфилов М.С. - добавлены назначения для траншей МБК
-- 13/12/2012 Панфилов М.С. - теперь назначения по начислению процентов за один день и за несколько - разные
-- 13/06/2013 Панфилов М.С. - новые назначения для траншей МБК привлечения (после запуска функционала "Транши МБК")
-----------------------------------------------------------------------------------

  ndoc             dt.reference;
  sdesc            dt.description;
  sacccode         VARCHAR2(10);
  nclient          dt.reference;
  nvo              NUMBER;
  nvotext          VARCHAR2(15);
  scred            dt.description;
  recdoctreeparent doctree%ROWTYPE;
  recdeal          deal%ROWTYPE;
  recdealtr        dealtransaction%ROWTYPE;
  sdealtype        dealtype.label%TYPE;
  nisreceive       dealdeposit.isreceive%TYPE;
  nint             dealaccintention.constintention%TYPE;
  dtdate           DATE;
  vclientname      dt.label;

  recDocTree       doctree%ROWTYPE;
  sRowID           RowID;
  sTicket          VARCHAR2(50);
  sclient          dt.description;
  startdealdate    DATE;
  enddealdate      DATE;
  nIntReceive      DT.ConstValue := 15;
  nIntPlace        DT.ConstValue := 16;
  rAccMain         DealAcc.tAcc;
  dtpercbegdate    DATE;                               -- начало %% интервала
  dtpercenddate    DATE;                               -- конец  %% интервала

  boacc            DT.Label;
  cl               dt.reference;

BEGIN
  IF CONTEXT.SubSystem <> 9 THEN
    RETURN;
    END IF;

   sRowID := Context.DocRowID;
   select * into recDocTree from DocTree where RowID = sRowID for update;
   if recDocTree.Parent is null then
      return;
   end if;

  SELECT d.category
    INTO ndoc
    FROM doctree d
   WHERE d.classified = CONTEXT.currentdoc;
  SELECT dt.*
    INTO recdoctreeparent
    FROM doctree dt
   WHERE dt.classified = parentdoc(CONTEXT.currentdoc);
dbms_output.put_line('sdesc000  ='||sdesc);
--ELSIF ndoc = 5 AND recdoctreeparent.category = 913 AND recdoctreeparent.doctype = 1033718051
dbms_output.put_line('ndoc  ='||ndoc);
dbms_output.put_line('recdoctreeparent.category  ='||recdoctreeparent.category);
dbms_output.put_line('recdoctreeparent.doctype  ='||recdoctreeparent.doctype);
  IF ndoc = 70 AND recdoctreeparent.category IN (901, 902) THEN
dbms_output.put_line('sdesc0001  ='||sdesc);
    -- Срочные сделки

    SELECT substr(acccode_tcb(bo.account), 1, 3)
      INTO sacccode
      FROM bankoper bo
     WHERE bo.doc = CONTEXT.currentdoc;
    IF sacccode IN (930, 933) THEN
      -- Для открытия
            sdesc := DEAL_GetPaymentPurpose('\FOREX\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    ELSE
      -- Для закрытия
            sdesc := DEAL_GetPaymentPurpose('\FOREX\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    END IF;

  ELSIF ndoc = 905 THEN
    -- Для событий 
		
    SELECT *
      INTO recdealtr
      FROM dealtransaction
     WHERE doc = CONTEXT.currentdoc;  
		
    -- Если событие включено в неттинг или пролонгировано, то не обрабатываем
    IF recdealtr.isnetting != 0 THEN
      RETURN;
    END IF;    
	   IF recdoctreeparent.category <> 903 THEN
		SELECT t.counterparty, t.creditline                                 -- перенес из секции ниже (901,903) т.к. признак резидентности
        INTO nclient, cl                                                -- клиента нужен еще в друших местах 13/06/2013 добавил КЛ
        FROM deal t
       WHERE t.doc = recdoctreeparent.classified;
      nvo := isclresident(nclient);
		 END IF;
dbms_output.put_line('sdesc01  ='||sdesc);
    IF recdoctreeparent.category IN (901, 913) THEN
dbms_output.put_line('sdesc02  ='||sdesc);
      IF recdoctreeparent.category IN (901, 913) AND recdealtr.currency = 1000001275 THEN
      IF nvo = 0 THEN
        sdesc := DEAL_GetPaymentPurpose('\FOREX\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      ELSE
        sdesc := DEAL_GetPaymentPurpose('\FOREX\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
      ELSIF recdoctreeparent.category IN (901, 913) AND recdealtr.currency != 1000001275 THEN
        sdesc := DEAL_GetPaymentPurpose('\FOREX\5', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
    END IF;
dbms_output.put_line('sdesc02  ='||sdesc);
   -- Депозит

   if recDocTreeParent.Category = 908 then
      -- вид сделки (депозит/кредит) определить по наименованию
      select lower(DealTypeLabel(D.DealType)), DD.IsReceive
         into sDealType, nIsReceive
         from Deal D, DealDeposit DD
         where D.Doc = recDocTree.Parent and DD.Doc = D.Doc;

      -- определить по счету, это осн. сумма или %
      select min(AI.ConstIntention) into nInt
         from DealAccount DA, DealAccIntention AI
         where DA.Doc = recDocTree.Parent and DA.AccIntention =  AI.Classified
            and DA.Account in (select Account from DealTrAccount where Doc = recDocTree.Classified and Amount != 0);

   IF recdoctreeparent.doctype in (1047168347,1047168245) THEN   -- собственно депозитная сделка
      if instr(sDealType, 'кредит') > 0 or instr(sDealType, 'овердр') > 0 THEN
dbms_output.put_line('sdesc0  ='||sdesc);
      if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
                 elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
dbms_output.put_line('sdesc1  ='||sdesc);
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary  in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
         elsif nInt in (18, 58) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR  nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
                 end if;
dbms_output.put_line('sdesc2  ='||sdesc);
      end if;
      else
      if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\5', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\7', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\8', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (18, 58) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\7', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      end if;
      end if;
   ELSIF recdoctreeparent.doctype in (1179850206,1179850377) THEN   -- транши МБК                   
   
   dbms_output.put_line('nIsReceive  ='||nIsReceive||'; nInt ='||nInt);
   
   if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\21', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
                 elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\22', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\23', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\24', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            dbms_output.put_line('sdesc21  ='||sdesc);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            --sdesc := DEAL_GetPaymentPurpose('\MBC\22', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            if cl is not null then                                  -- 13/06/2013 Панфилов М.С.
              sdesc := DEAL_GetPaymentPurpose('\MBC\32', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            else
              sdesc := DEAL_GetPaymentPurpose('\MBC\33', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            end if;
            IF (recdealtr.beneficiary  in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
            END IF;
            dbms_output.put_line('sdesc22  ='||sdesc);
         elsif nInt in (18, 58) then
            -- sdesc := DEAL_GetPaymentPurpose('\MBC\23', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            if cl is not null then                                  -- 13/06/2013 Панфилов М.С.
              sdesc := DEAL_GetPaymentPurpose('\MBC\30', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            else
              sdesc := DEAL_GetPaymentPurpose('\MBC\31', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            end if;
            
            IF (recdealtr.beneficiary in (24763,63979263) OR  nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
            END IF;
            dbms_output.put_line('sdesc23  ='||sdesc);
         end if;
dbms_output.put_line('sdesc2  ='||sdesc);
      end if;
   
   END IF;
   end if;
    -- Неттинг

    IF recdoctreeparent.category = 903 THEN
      SELECT t.counterparty
        INTO nclient
        FROM dealnetting t
       WHERE t.doc = recdoctreeparent.classified;

      IF recdealtr.currency = 1000001275 THEN
        nvo := isclresident(nclient);
        IF nvo = 0 THEN
            sdesc := DEAL_GetPaymentPurpose('\NETTING\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        ELSE
            sdesc := DEAL_GetPaymentPurpose('\NETTING\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        END IF;

        IF getobjectcode(nclient, 5) = 'NCCB' THEN
          sdesc := DEAL_GetPaymentPurpose('\NETTING\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        END IF;
      ELSE
        sdesc := DEAL_GetPaymentPurpose('\NETTING\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
    END IF;

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 901 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\FOREX\7', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 903 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\NETTING\7', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 908 THEN
    -- Для плановых поступлений
    
    if getdoctype(recdoctreeparent.PARENT) in (1047168347,1047168245) then             
    sdesc := DEAL_GetPaymentPurpose('\MBC\12', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
    elsif getdoctype(recdoctreeparent.PARENT) in (1179850206,1179850377) then                           -- 27/08/2012 Панфилов М.С.
    sdesc := DEAL_GetPaymentPurpose('\MBC\26', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
    end if;
    
  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 913 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\1', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 903 THEN
    -- Для внутренних платежей

    sdesc := DEAL_GetPaymentPurpose('\NETTING\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 901 THEN

    sdesc := DEAL_GetPaymentPurpose('\FOREX\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 913 THEN

    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND getdoccategory(recdoctreeparent.PARENT) = 908 AND recdoctreeparent.doctype = 1047177856 THEN

    sdesc := DEAL_GetPaymentPurpose('\MBC\9', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  /*ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND getdoccategory(recdoctreeparent.PARENT) = 908 AND recdoctreeparent.doctype != 1047177856 THEN

        select acccode(ACCOUNT) into boacc from bankoper where doc = recDocTree.Classified;                     -- 16/05/2011 Панфилов М.С.

    IF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1047168347) or (recdoctreeparent.doctype = 1047168245) THEN
        sdesc := DEAL_GetPaymentPurpose('\MBC\10', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    ELSE
        sdesc := DEAL_GetPaymentPurpose('\MBC\11', recdoctreeparent.classified,  CONTEXT.currentdoc, null);     -- 16/05/2011 Панфилов М.С.
    END IF;
  */

  ELSIF ndoc = 5 AND recdoctreeparent.category = 913 AND recDocTree.doctype = 1033718051 THEN      -- 30/06/2011 Панфилов М.С.
dbms_output.put_line('sdesc3  ='||sdesc);
    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
dbms_output.put_line('sdesc4  ='||sdesc);
  ELSIF (ndoc = 11 or ndoc = 12) AND recdoctreeparent.category = 905  THEN      -- 12/08/2011 Панфилов М.С.
dbms_output.put_line('sdesc5  ='||sdesc);
    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\3', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
dbms_output.put_line('sdesc6  ='||sdesc);
  ELSIF ndoc = 5 AND recdoctreeparent.category = 908 AND recdoctreeparent.doctype != 1047177856 THEN            -- 27/05/2011 Панфилов М.С.
        select acccode(ACCOUNT) into boacc from bankoper where doc = recDocTree.Classified;                     -- 16/05/2011 Панфилов М.С.
    IF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1047168347) or (recdoctreeparent.doctype = 1047168245) THEN
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\10', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\27', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    ELSIF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1179850377) or (recdoctreeparent.doctype = 1179850206) THEN -- 27/08/2012 Панфилов М.С.
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\25', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\28', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    ELSE  
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\11', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\29', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    END IF;

  ELSE
    sdesc := '';
  END IF;

  UPDATE doctree t
     SET t.description = sdesc
   WHERE t.classified = CONTEXT.currentdoc;


   UPDATE doctree
   SET description = sdesc
   WHERE classified IN (SELECT classified
                              FROM doctree
                             WHERE PARENT = CONTEXT.currentdoc);

END dpc_tcb_desc_for_diling;


SELECT OperDate,
row_number () OVER (ORDER BY (OperDate) DESC) dr
FROM DealSwapInterestLog
WHERE doc = 217546511 

select bd into dtPercbegdate from 
(SELECT trunc(bd) as bd,
row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
FROM (select DISTINCT trunc(OperDate) as bd, doc from DealSwapInterestLog) b
WHERE doc = nDoc) x where x.rang = 2

select * from 
(SELECT trunc(bd),
row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
FROM (select DISTINCT trunc(Begdate) as bd, account from Balance) b
WHERE account = 186733736) x where x.rang = 2

OperDate - 1 <> 0;

select * from DealSwapInterestLog WHERE doc = 217706066

select DA.Account,DA.rsAccount
        --into nAccount,nRSAccount
        from DealAccount DA, DealAccIntention DAI
       where DA.Doc = 217706066
         and DA.AccIntention = DAI.Classified
         and DAI.ConstIntention = decode(1, 1, 18, 17)
         
select* from balance where account = 186733736
select * from doctree where classified = 217645254

-- 23                                                                                                             
INSERT INTO DEALPAYMENTPURPOSE (classified,parent,code,label,description,fullname,updatedrole,value,isvalue)
VALUES (Classified.nextval, 1131587467, '30', 'Шаблон30', null, '\MBC\30', null, 'Проценты за предоставленный МБК к договору от <CLVALUEDATE> № <CLLabel> с <BEGPROCDATE2> по <BEGPROCDATE> (транш от <TRANSACTDATE>). НДС не облагается.', 1); 
    
INSERT INTO DEALPAYMENTPURPOSE (classified,parent,code,label,description,fullname,updatedrole,value,isvalue)
VALUES (Classified.nextval, 1131587467, '31', 'Шаблон31', null, '\MBC\31', null, 'Проценты за предоставленный МБК к договору от <TRANSACTDATE> № <DealLabel> с <BEGPROCDATE2> по <BEGPROCDATE>. НДС не облагается.', 1); 
-- 22    
INSERT INTO DEALPAYMENTPURPOSE (classified,parent,code,label,description,fullname,updatedrole,value,isvalue)
VALUES (Classified.nextval, 1131587467, '32', 'Шаблон32', null, '\MBC\32', null, 'Возврат кредита в соответствии с Договором от <CLVALUEDATE> № <CLLabel> (транш от <TRANSACTDATE>) в соответствии графиком погашения. НДС не облагается.', 1);

INSERT INTO DEALPAYMENTPURPOSE (classified,parent,code,label,description,fullname,updatedrole,value,isvalue)
VALUES (Classified.nextval, 1131587467, '33', 'Шаблон33', null, '\MBC\33', null, 'Возврат кредита в соответствии с Договором от <TRANSACTDATE> № <DealLabel> в соответствии графиком погашения. НДС не облагается.', 1);
-- нужно сделать отдельную процедуру, чтобы просто толкать события UT_DealAccrual_EveryDay00_TCB                                                                ++ 
-- неверная генерация номеров счетов для транша по процентам и ОД 
-- (пример: сделка 03062013: надо *03* - номер транша в рамках линии; а не *08* - номер документа в рамках дня) всё ОК, донастроил параметр на DPC_SETDOCLABEL  ++
-- затираются счета контрагенов в событиях по сделкам при перестроении графиков => повесил dpc_dealtrans_settransacc в manager после пересоздания событий       ++

od.DPC_FillDealDepInterest
od.DPC_FillDealDepPaymentForSave
od.DPC_DealDep_Events
od.DPC_DealDep_Events

od.tcb_set_57d_payreq
od.dealdep_proc.FillDealDepInterest
od.DPC_DepositDeal_Events

od.dpc_dealtrans_settransacc

SELECT DISTINCT dp.doc FROM dealpactpayreq dp, doctree dt WHERE dp.doc = dt.classified and dp.payreq = 181839724 and dt.docstate != 1000000037

select * from doctree where classified in (217642130, 181834813)
select * from doctype where classified = 1047124628

SELECT  /*+ INDEX(DT IX_DOCTREE_23) */ DT.Classified,SUBSTR( DocTypeLabel( DT.DocType ), 1, 50 ), DT.Label, DT.DocType, ' ', ' ', DT.OperDate, null, DT.DealDate, DT.ValueDate, DT.MaturityDate, substr( DealerCode( DT.Dealer ), 1, 50 ), null, substr( ClientLabel( DT.CounterParty ), 1, 50 ), substr( ClientLabel( DT.ProfitCentr ), 1, 50 ), DT.ExternalRef, substr( CompetitorLabel( DT.Market ), 1, 50 ), null, DT.Ticket, substr( CurrencyISO( DT.CurrencyB ), 1, 3 ), substr( FmtDocSum( DT.AmountB, DT.CurrencyB ), 1, 50 ), DT.AmountB, DT.InterestRate, null, L.Label, null, null,  substr( ObjAttrCheck.GetOneDesc( DT.Classified, ObjAttrCheck.DescClass( 54 ) ), 1, 254 ), 
DT.OperDate, SUBSTR( UserPseudoName( DT.OperID ), 1, 50 ), DT.OperCause,
    SUBSTR(EntityStateLabel( DT.EntityState ), 1, 50), DT.Description, SUBSTR( UserPseudoName( DT.AuthorID ), 1, 50 ), SUBSTR( CategoryLabel( DT.Category ), 1, 50 ), 
 0, EntityStateColor( DT.EntityState ), DT.DocState, DT.DocType, DT.Category  
 FROM  V_DealDeposit DT
   WHERE 1 = 1
    AND  DT.OperDate >= TO_DATE( '2013-05-29-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
    AND DT.OperDate < TO_DATE( '2013-05-31-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
    AND (EXISTS (SELECT Doc FROM WorkFlow
            WHERE Doc = DT.Classified
                AND WorkPlace = 1047766549)
        OR Bit_Proc.CheckBit(DT.IsHidden, 3) != 1)
    AND DT.DocType IN ( 1179850206 ) AND ROWNUM <= 100 
 ORDER BY 40 

od.DPC_FillDealDepInterest

----------------------------------------------------------------------------------
--31/05/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

function CorrectAmortShedule(
   ---------------------------------------------------------------------------------------------------------------------------
   -- Описание:   Коррекция расписания амортизации (с учетом ручной амортизации)
   -- Возвращает: признак коррекции расписания.
   -- Параметры:  dtDateFrom - дата начала коррекции
   -- Автор:      А. Галкин
   -- Версия:    28.12.2012 - коррекция расписания амортизации с учетом даты возврата номинала (Дор. № 12407, AGN)
   --            31.05.2013
   ---------------------------------------------------------------------------------------------------------------------------
      dtDateFrom  in  Date
   ) return boolean
   as
      dtaSchedule     DT.DateType;
      bCorrect        boolean := false;
      nInd            DT.Counter;
      nSkip           DT.Status;
      dtTemp          Date;
      dtPrev          Date;
      nEndAmort       DT.Status := 0; -- признак наличия даты возврата номинала в расписании амортизации
      nAmort          DT.Status := 0; -- признак наличия периодической амортизации
      -- сортировка массива
      procedure loc_SortData as
         dtTemp      Date;
         nFlag       DT.Status := 1;
      begin
         -- пузырек
         while nFlag = 1 loop
            nFlag := 0;
            for ind in nvl(dtaSchedule.First, 0) .. nvl(dtaSchedule.Last - 1, -1)
            loop
               if dtaSchedule(ind) > dtaSchedule(ind + 1) then
                  nFlag := 1;
                  dtTemp := dtaSchedule(ind);
                  dtaSchedule(ind) := dtaSchedule(ind + 1);
                  dtaSchedule(ind + 1) := dtTemp;
               end if;
            end loop;
         end loop;
      end loc_SortData;
   begin
      dbms_output.put_line('<< CorrectAmortShedule Start dtDateFrom='||dtDateFrom);
      dtaSchedule := GetShedule(nPeriod_Amort);
      --
      for k in nvl(dtaSchedule.first, 0)..nvl(dtaSchedule.Last, -1)
      loop
         dbms_output.put_line('№ ='||k||' Date='||dtaSchedule(k));
         nAmort := 1;
      end loop;
      dbms_output.put_line('----------------');
      --
      for recAm in (select ValueDate  -- даты ручной амортизации
                      from DealSwapPayment
                     where Doc = recDeal.Doc
                       and PaymentType = 4 and IsEdit = 1 and ValueDate >= dtDateFrom
                  group by ValueDate
                  order by ValueDate asc
                    )
      loop
         nInd := null; nSkip := 0;
         for k in nvl(dtaSchedule.first, 0)..nvl(dtaSchedule.Last, -1)
         loop
            -- поиск индекса вставки ручной амортизации
            if dtaSchedule(k) = recAm.ValueDate then
               -- не требуется вставка,существует периодическая амортизация на дату
               nSkip := 1;
               exit;
            elsif recAm.ValueDate < dtaSchedule(k) or not(dtaSchedule.exists(k+1)) then
               nInd := k;
               exit;
            end if;
         end loop;
         dbms_output.put_line('Finded Ind='||nInd);
         if nSkip = 0 then
            dbms_output.put_line('Skip = 0');
            if nInd is null then
               dbms_output.put_line('<<nInd is null');
               dtaSchedule(dtaSchedule.Count) := recAm.ValueDate;
               dbms_output.put_line('<<dtaSchedule INS recAm.ValueDate='||recAm.ValueDate);
            else
               -- подвинем расписание
               for k in nInd..dtaSchedule.Last
               loop
                  dtTemp := dtaSchedule(k);
                  if k = nInd then
                     dtaSchedule(k) := recAm.ValueDate;
                  else
                     dtaSchedule(k) := dtPrev;
                  end if;
                  dtPrev := dtTemp;
                  if k = dtaSchedule.Last then
                     dtaSchedule(k+1) := dtPrev;
                     exit;
                  end if;
               end loop;
            end if;
         end if;
         bCorrect := true;
      end loop;
      loc_SortData;
      -- проверка на наличие даты возврата номинала(ее может не быть, т.к. амортизация может быть ручная)
      for k in nvl(dtaSchedule.first, 0)..nvl(dtaSchedule.Last, -1)
      loop
         dbms_output.put_line('№ ='||k||' Date='||dtaSchedule(k));
         if dtaSchedule(k) = recDeal.MaturityDate then
            nEndAmort := 1;
            exit;
         end if;
      end loop;
      if (bCorrect or nAmort = 1) and nEndAmort = 0 then
         dtaSchedule(dtaSchedule.Last+1) := recDeal.MaturityDate;
      end if;
      dbms_output.put_line('<< CorrectAmortShedule End');
      if (bCorrect) or (nAmort = 1 and nEndAmort = 0) then
         SaveShedule(nPeriod_Amort, dtaSchedule);
      end if;
      return bCorrect;
   end CorrectAmortShedule;
   
   

select c.* -- C.Classified -- into idGenIntention
             from EntityPropValue EPV, GenIntention C
            where EPV.PropType = 5
              --and EPV.PropValue = Message.idClass
              and C.Classified = EPV.Context

od.DPC_EditDealGenIntention

select * from doctype where classified in (1179850377,1179850206)

od.DPC_TCB_DESC_FOR_DILING
od.DEAL_GetPaymentPurpose

od.DealBegProcDate
select * from deal where doc = 217645254

select DealBegProcDate(217624644) from dual
----------------------------------------------------------------------------------
--03/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.dpc_tcb_setpaymentreference
od.SPEC_ChangeBillOper_TCB
select * from dealtransaction

select * from doctree where classified = 218185148

od.UT_DealAccrual_EveryDayFT_TCB

CREATE OR REPLACE PROCEDURE SPEC_setvaluedate_tcb
/**********************************************************************************
Описание: процедура изменяет дату валютирования события сделки
Автор: Панфилов М.С.
Дата: 03/06/2013
Параметры: NewDate новая дата
**********************************************************************************/
( nDoc        dt.Reference,  
  NewDate     date
 )
as
   nDocCat   dt.ConstValue;
begin
  
if NewDate is not null then
  select d.category into nDocCat from doctree d where classified = nDoc;
  if nDocCat = 905 then -- событие сделки
     UPDATE dealtransaction set valuedate = NewDate where doc = nDoc;
  end if;
end if;

end SPEC_setvaluedate_tcb;












create or replace procedure UT_DealAccrual_EveryDay00_TCB(
/*******************************************************************************
 Автор: Панфилов М.С. 03.06.2013 (на основе UT_DealAccrual_EveryDayFT_TCB)
 Описание:  Просто толкаем события


 Версия:
   06.07.2001 Расчет процентов ведется на заданную дату, а проводка делается на S.YSDATE.
   02.10.2001 Добавлена проверка на c_access.GetFilial, ограничение по датам из сделки.
   10.10.2001 В последний рабочий день месяца начисления делаются с учетом выходных.
   29.09.2004 Для EDO переделан основной запрос.
   08.02.2006 Поправлено условие отбора сделок, верно учитывается состояние документа.
   13.04.2007 Добавлен учет возможного изменения базовой процентной ставки в течение дня.
   30.05.2008 При сдвиге интервала в последний рабочий день месяца учитывается дата окончания сделки.
   06.06.2008 Не начислять проценты по сделкам, которые открыты в день, когда делается начисление.
   03.09.2008 Начисление по сделкам с датой начала = последнему рабочему дню месяца.
   21.05.2009 В зависимости от ключа начисление может осуществляться ежедневно/ежемесячно.
   05.10.2011 Добавлен запуск процедуры логирования. Добавлена блокировка.(Дор.11198, dvp)
   16.03.2012 Блокировка сделок в зависимости от значения параметра nLockMode (зам.37133, tmy).
   06.06.2011 Для депозитов до востребования вместо MaturityDate используется дата расчета (зам.40924, tmy)
   29.06.2012 (Дор. № 10561, AGN)
   05.09.2012 Исправлено вычисление последнего рабочего дня месяца (зам.42331, tmy)
   04.12.2012 для траншей МБК события пересоздаются с даты начала перерасчета %% (Зам. № 44062, AGN)
********************************************************************************/
   dtAccrualDate  date,  -- дата расчета
   nLog           DT.Status default 1,   -- вести логирование 0/1 нет/да
   nLockMode      DT.Status default 1    -- блокировать сделки перед обработкой 0/1 нет/да
) is
   dtToDate       date := trunc(dtAccrualDate);
   dtToDateTemp   date;
   nAllSum        DT.Amount;        -- общая сумма %
   nIsReceive     DT.ConstValue;
   nCurrency      DT.Reference;
   nIsLastDay     DT.Status := 0;
   dtMaturityDate date;
   nJ             DT.Quantity := 0;
   sProcLabel     dt.Description := 'UT_DealAccrual';
   sOperation     DT.Label := 'DealInterestRate';
   sDocLabel      dt.Label;
   sTextMess      dt.Description;
   sCrlf          constant DT.Label := CHR(13)||CHR(10);
   nLockStatus    DT.Status := 0;
   naDeal         DT.ClassType;
   naGenInt       DT.ClassType;
   nLockErr       DT.Status := 0;
   nGenInt932     DT.Reference := Constants.GetGenIntention(932);
   nGenInt933     DT.Reference := Constants.GetGenIntention(933);

   flag           DT.Status := 0; -- в графике начисления процентов по сделке есть дата расчета

   cursor curDeals is
   select DT.Classified, DT.GenIntention
     from EntityMethod EM, EntityPropValue EPV, EntityState ES, DocTree DT
    where EM.SQLNAME = 'DEALACCRUAL'
      and EPV.PropValue = EM.Classified and EPV.PropType = 1
      and EPV.EntityState = ES.Classified
      and DT.DocType = ES.EntityClass and Dt.EntityState = ES.Classified
      and DT.SysFilial = 1
      and exists (select null from Deal d, DealDeposit dd
                   where d.Doc = DT.Classified
                     and d.ValueDate - nIsLastDay < trunc(dtAccrualDate)
                     and (sysdate <= d.MaturityDate or d.MaturityDate is null)
                     and d.DealDate <= (select s.ysdate from dual)
                     and dd.doc = d.doc and dd.istransh = 1)                    -- 21/12/2012 Панфилов М.С. - тут смотрим только транши МБК
      and exists (select null from DealSwapPayment DSP, Doctree DCT             -- 21/12/2012 Панфилов М.С. - тут смотрим только те сделки, у которых есть "созданные" события по процентам на даты <= дата расчета
                   where DSP.Doc = DT.Classified
                     and DSP.Classified = DCT.OperObj
                     and DCT.Parent = DSP.Doc
                     and DSP.VALUEDATE <= trunc(dtAccrualDate)
                     and DSP.Paymenttype = 0
                     and DCT.DocState = Constants.State_Open)
      and exists (select null from DealAccount DA, DealAccintention DAI
                   where DA.AccIntention = DAI.Classified
                     and DA.Doc = DT.Classified
                     and DAI.ConstIntention in (17, 18))
                     ;
   --  разблокировка сделок
   procedure LockReleas(
      naDealIn  DT.ClassType  -- массив сделок
   ) is
   begin
      if naDealIn.count > 0 then
         for n in naDealIn.first..naDealIn.last loop
            teller_proc.lock_release(naDealIn(n));
         end loop;
      end if;
   end LockReleas;
begin
   if dtToDate is null then
      tm_proc.RaiseError(42007);
   end if;

   -- начисление производится только НЕ в последний день месяца.
   /*if Registry.GetValue('\Deal\Deposit\NoDailyAccrual') = 1 and dtToDate != PreWorkDay(last_day(dtToDate) + 1) then
      tm_proc.RaiseError(42153);
   end if;*/
   -- откроем LOG
   Dbl_Log('', '', 0, 3, null, sOperation, sProcLabel, nLog);
   -- в последний рабочий день месяца расширяем интервал до конца месяца
   if DPGeneral.GetIntervalValue(dtToDate, last_day(dtToDate) + 1, 2) <= 1 then
      dtToDate := last_day(dtToDate);
      nIsLastDay := 1;
   end if;
   --
   dtToDateTemp := dtToDate;
   if nLockMode = 1 then
      sTextMess :=  'Блокировка сделок. Дата расчета <'|| to_char(dtAccrualDate, 'dd.mm.yyyy hh24:mi:ss')  || ')';
      Dbl_Log(sTextMess, sTextMess, 35, 3, null, sOperation, sProcLabel, nLog);
   end if;
   for recDeals in curDeals loop
      if nLockMode = 1 then
         -- блокируем сделку
         teller_proc.doc_lock(recDeals.Classified, nLockStatus);
      end if;
      if nLockStatus = 0 then
         nJ := nJ + 1;
         naDeal(nJ) := recDeals.Classified;
         naGenInt(nJ) := recDeals.GenIntention;
      else
         nLockErr := 1;
         sTextMess := 'Не удалось заблокировать сделку ' || DocTreeLabel(recDeals.Classified)||'('||recDeals.Classified||')';
         Dbl_Log(sTextMess, sTextMess, 121, 5, recDeals.Classified, sOperation , sProcLabel, nLog);
         exit;
      end if;
   end loop;
   if nLockMode = 1 then
      Dbl_Log('Блокировка сделок.','Блокировка сделок.', 45, 3, null, sOperation, sProcLabel, nLog);
   end if;
   if nLockErr = 1 or (nLockErr = 0 and nJ = 0) then
      if nLockErr = 1 then
      -- Разблокируем сделки
         LockReleas(naDeal);
      elsif nLockErr = 0 and nJ = 0 then
         sTextMess := 'Не найдено ни одного транша МБК на дату <' ||dtToDate|| '>';
         Dbl_Log(sTextMess, sTextMess, 121, 3, null, sOperation, sProcLabel, nLog);
      end if;
   else
      -- сделки заблокированы
      sTextMess := '<Дата расчетов>='|| to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
                   '<Интерв расчетов>='|| to_char(dtToDate, 'dd.mm.yyyy') || sCrlf ||
                   '<траншей МБК>=' ||nJ;
      Dbl_Log(sTextMess, 'Сформирован  набор из ' || nJ || ' траншей МБК на дату <' ||dtToDate|| '>',
              35, 101, null, '', sProcLabel, nLog);
      for nJ in naDeal.first..naDeal.last loop
         flag := 0;
         sTextMess := 'Обработка транша МБК <' ||DocTreeLabel( naDeal(nJ))||'> (' ||  naDeal(nJ) || ')';
         Dbl_Log(sTextMess, sTextMess,  35, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
         select MaturityDate into dtMaturityDate from Deal where Doc = naDeal(nJ);
         dtToDate := least(dtToDateTemp, nvl(dtMaturityDate, dtToDateTemp));
         nAllSum := null;
         /*if naGenInt(nJ) in (nGenInt932, nGenInt933) then
            -- пересчет графиков и событий по сделке транша МБК
            DealDep_proc.FillDealDepInterest(naDeal(nJ));
            FillDealDepPaymentForSave(naDeal(nJ));
            DealDep_proc.DealDepEvents(naDeal(nJ), dtToDate, null, 2);
         else
            -- Если изменилась базовая процентная ставка необходимо скорректировать сумму в событиях
            SetDealInterestRate(idDoc => naDeal(nJ) ,
                                nLog => nLog );
         end if;

         select count(classified) into flag from DealSwapInterest where doc = naDeal(nJ) and enddate = dtToDate; -- ищем в графике начисления процентов дату расчета

         if dtToDate != PreWorkDay(last_day(dtToDate) + 1) and flag != 0 then -- 21/12/2012 Панфилов М.С. - начисление производится только НЕ в последний день месяца
         CreatePercentAccountDoc(nDoc => naDeal(nJ),                          -- (в последний день месяца для начисления процентов сначала нужно запускать od.UT_DealAccrual)
                                 dtDate => dtToDate ,
                                 nAllSum => nAllSum,
                                 nIsReceive => nIsReceive,
                                 nCurrency => nCurrency,
                                 dtOperDate_ => S.YSDATE,
                                 nLog => nLog);

         end if;*/
         -- толкаем события траншей МБК с ValueDate <= текущей
         for rec in (select DCT.* from DealSwapPayment DSP, Doctree DCT             -- 21/12/2012 Панфилов М.С. - тут смотрим только "созданные" события по процентам на даты <= дата расчета
                   where DSP.Doc = naDeal(nJ)
                     and DSP.Classified = DCT.OperObj
                     and DCT.Parent = DSP.Doc
                     and DSP.VALUEDATE <= trunc(dtAccrualDate)
                     and DSP.Paymenttype = 0
                     and DCT.DocState = Constants.State_Open)
         loop
           od.docprocessforchild(rec.classified,S.YSDATE,1,Constants.State_Start,false); -- 27/03/2013 Панфилов М.С. - добавлен пятый параметр = false, чтобы можно было обрабатывать чужие события
         end loop;

         Dbl_Log(sTextMess, sTextMess, 45, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
      end loop;
      if nLockMode = 1 then
         -- Разблокируем сделки
         LockReleas(naDeal);
      end if;
      Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   end if;
   -- закроем LOG
   Dbl_Log('<Дата расчетов>=' || to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
           '<траншей МБК>=' ||nJ , '', 1, 3, null, sOperation, sProcLabel, nLog);
exception when OTHERS then
   if nLockMode = 1 then
      -- Разблокируем сделки
      LockReleas(naDeal);
   end if;
   Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   Dbl_Log('', '', 1, 3, null, sOperation, sProcLabel, nLog);
   raise;
end UT_DealAccrual_EveryDay00_TCB;













od.dpc_dealtrans_settransacc
select * from dealdeposit where doc = 217887957
select * from GenIntention where classified =1000104503
od.DPC_DepositDeal_Events
select * from DealSwapPayment where Doc = 200110891 and rownum = 1;

select Constants.GetGenIntention(901) from dual







-- нужно проставить beneficiaryaccount по всем кривосозданным событиям  из-за косяка +/-                                                                            ++
select dt.* from dealtransaction dt, doctree d
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2443819')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503
               
update dealtransaction set beneficiaryaccount = '47426810800000000000' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2443819')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)


1948046                                              47427810700541002304
1988284                                              47427810000541003304
2181231                                              47427810000542002304
2188440                                              47427810300542003304
2192755                                              47427810600542004304

update dealtransaction set beneficiaryaccount = '47427810700541002304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '1948046')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)

update dealtransaction set beneficiaryaccount = '47427810000541003304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '1988284')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)
               
update dealtransaction set beneficiaryaccount = '47427810000542002304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2181231')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)

update dealtransaction set beneficiaryaccount = '47427810300542003304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2188440')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)
               
update dealtransaction set beneficiaryaccount = '47427810600542004304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2192755')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)



2197322                                              47427810900542005304
2174724                                              47427810700542001304
2292671                                               47427810800542008304
2348839_1                                         47427810700542014304
2395471_1                                         47427810500542023304
2422783                                              47427810300542032304
2287702                                              47427810500542007304
2302228                                              47427810100542009304
2344795                                              47427810500542010304
2347476                                              47427810800542011304
--10
2347852                                              47427810100542012304
2348743                                              47427810400542013304
2352125                                              47427810000542015304
2357492                                              47427810300542016304
2361453                                              47427810600542017304



------------------------------------------------------------------------------------------------------------------------------------------------               
               
update dealtransaction set beneficiaryaccount = '47427810900542005304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2197322')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)   
               
update dealtransaction set beneficiaryaccount = '47427810700542001304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2174724')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810800542008304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2292671')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810700542014304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2348839_1')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810500542023304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2395471_1')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810300542032304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2422783')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810500542007304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2287702')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810100542009304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2302228')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)      
                   
update dealtransaction set beneficiaryaccount = '47427810500542010304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2344795')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810800542011304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2347476')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

--10--------------------------------------------------------------------------------------------------------------------------------------------
               
update dealtransaction set beneficiaryaccount = '47427810100542012304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2347852')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)   
               
update dealtransaction set beneficiaryaccount = '47427810400542013304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2348743')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810000542015304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2352125')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810300542016304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2357492')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810600542017304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2361453')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810900542018304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2364212')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810200542019304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2376263')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810600542020304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2380734')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)      
                   
update dealtransaction set beneficiaryaccount = '47427810900542021304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2387191')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810200542022304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2390559')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

2364212                                              47427810900542018304
2376263                                              47427810200542019304
2380734                                              47427810600542020304
2387191                                              47427810900542021304
2390559                                              47427810200542022304
--20
2396522                                              47427810800542024304
2399469                                              47427810100542025304
2401384                                              47427810400542026304
2405804                                              47427810700542027304
2412108                                              47427810000542028304
2417415                                              47427810300542029304
2418716                                              47427810700542030304
2420219                                              47427810000542031304
2422313                                              47427810600542033304
2423121                                              47427810900542034304
--30


--20--------------------------------------------------------------------------------------------------------------------------------------------

               
update dealtransaction set beneficiaryaccount = '47427810800542024304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2396522')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)   
               
update dealtransaction set beneficiaryaccount = '47427810100542025304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2399469')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810400542026304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2401384')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810700542027304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2405804')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503)          

update dealtransaction set beneficiaryaccount = '47427810000542028304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2412108')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810300542029304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2417415')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810700542030304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2418716')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810000542031304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2420219')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);     
                   
update dealtransaction set beneficiaryaccount = '47427810600542033304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2422313')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810900542034304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2423121')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

--30--------------------------------------------------------------------------------------------------------------------------------------------
               
update dealtransaction set beneficiaryaccount = '47427810000543001304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2437031')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);   
               
update dealtransaction set beneficiaryaccount = '47427810300543002304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2441285')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810600543003304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2443819')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810900543004304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2445710')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810200543005304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2446584')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810500543006304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2450046')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810800543007304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2455420')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);         

update dealtransaction set beneficiaryaccount = '47427810100543008304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2457376')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);      
                   
update dealtransaction set beneficiaryaccount = '47427810400543009304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2459730')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810800543010304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2460862')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

--40--------------------------------------------------------------------------------------------------------------------------------------------

2437031                                              47427810000543001304
2441285                                              47427810300543002304
2443819                                              47427810600543003304
2445710                                              47427810900543004304
2446584                                              47427810200543005304
2450046                                              47427810500543006304
2455420                                              47427810800543007304
2457376                                              47427810100543008304
2459730                                              47427810400543009304
2460862                                              47427810800543010304
--40
2465291                                              47427810100543011304
2468481                                              47427810400543012304
2469765                                              47427810700543013304
2471056                                              47427810000543014304
2472147                                              47427810300543015304
2473327                                              47427810600543016304
2520773                                              47427810500543019304
2540994                                              47427810800543023304
2515311                                              47427810900543017304
2518719                                              47427810200543018304
--50
2522771                                              47427810900543020304
2538655                                              47427810500543022304
2544685                                              47427810100543024304
2545807                                              47427810400543025304
2547991                                              47427810700543026304
2550293                                              47427810000543027304
2537416                                              47427810200543021304
               
update dealtransaction set beneficiaryaccount = '47427810100543011304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2465291')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);   
               
update dealtransaction set beneficiaryaccount = '47427810300543002304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2468481')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810700543013304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2469765')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810000543014304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2471056')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810300543015304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2472147')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810600543016304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2473327')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810500543019304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2520773')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810800543023304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2540994')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);      
                   
update dealtransaction set beneficiaryaccount = '47427810900543017304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2515311')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810200543018304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2518719')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

--50--------------------------------------------------------------------------------------------------------------------------------------------

               
update dealtransaction set beneficiaryaccount = '47427810900543020304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2522771')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);  
               
update dealtransaction set beneficiaryaccount = '47427810500543022304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2538655')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810100543024304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2544685')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);         

update dealtransaction set beneficiaryaccount = '47427810400543025304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2545807')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810700543026304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2547991')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810000543027304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2550293')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);          

update dealtransaction set beneficiaryaccount = '47427810200543021304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2537416')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1000104503);              

--60--------------------------------------------------------------------------------------------------------------------------------------------


-- по ОД

2174724                                                              32009810900542001304
2181231                                                              32009810200542002304
2188440                                                              32009810500542003304
2192755                                                              32009810800542004304
2197322                                                              32009810100542005304

select * from dealtransaction where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2174724')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1056942143)

update dealtransaction set beneficiaryaccount = '32009810900542001304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2174724')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1056942143);  

update dealtransaction set beneficiaryaccount = '32009810200542002304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2181231')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1056942143); 

update dealtransaction set beneficiaryaccount = '32009810500542003304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2188440')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1056942143); 
 
update dealtransaction set beneficiaryaccount = '32009810800542004304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2192755')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1056942143); 
 
update dealtransaction set beneficiaryaccount = '32009810100542005304' where doc in (select dt.doc from dealtransaction dt, doctree d, deal dtt
              where dt.doc = d.classified and d.parent in (select doc from deal where ticket = '2197322')
               and d.docstate = 1000000034 and dt.transactiontype = 2
               and d.genintention = 1056942143); 
               
               
-- оптимизация запросов в BBR_TCB_BILL_OPER_MSK по задаче IPI 143130 (убрть trunc с дат в циклах, если trunc(dt.OperDate)<=(y), то y+1)                               ++
-- + открыл доступ для всех филиалов на блок 7      

bbr.BBR_TCB_BILL_OPER_MSK

----------------------------------------------------------------------------------
--05/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
 
od.DPC_SetAccDepartFromPact_TCB
select distinct doctype from deal
select * from doctype where classified = 1179850206
select * from dealdeposit where doc in (select doc from deal where doctype = 1179850206) -- все првлеченные транши

select * from dealdeposit

SELECT c.classified,cn.label naim,c.operdate,c.amount,
substr(CurrencyISO(c.Currency),1,50),st.label amounttype,c.percent, substr(nvl(DoctreeLabel(c.cppayreq), '?'),1,50), c.description
     FROM Commisionadd c, commisionnaim cn, commisionsumtype st
     Where c.Doc = 217887957 and c.naim=cn.classified(+) and c.amounttype = st.classified(+) Order By OperDate Asc

-- убираем реестровость со счета
select * from account where code = '31308810200000033340'
select * from account where code = '31309810100000103340'
select * from account where code = '31307810003340083313' -- последний транш

select * from accountwithreestr where account = 218323229
delete accountwithreestr where account = 218323229
select * from reestr where classified = 1238071494
delete reestrdoc where accountwithreestr = 1238071494
select * from od.nostroconnectedacc where account = 218323229
select * from od.dealaccount where account = 218323229
update dealaccount set rsaccount = null where account = 218323229

----------------------------------------------------------------------------------
--07/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select d.* from devreestr d where userid = 'SUPER' order by classified desc

----------------------------------------------------------------------------------
--11/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

   procedure DEVReestrInsert_WS(
   /********************************************************************************
   Автор    : Соколов В.Н.
   Описание : Запись в реестр ДЭВ веб-сервиссом
   Версия   : 16.04.2012
   Изменения: 03.05.2012 Проверка подписей делается в разрезе филиалов
              14.06.2012 Ищем исправляемый ДЭВ в разрезе типа ДЭВ
              13.08.2012 Раскодирование файла из кодировки base64 производим частями
              01.10.2012 Заполняем Дату документа, даже для недокументарных отчетов
   ********************************************************************************/
      sDevType           DT.Label,       -- код типа ДЭВ
      sDevSource         DT.Label,       -- код источника типа ДЭВ
      sFileName          DT.Description, -- название файла
      sContent           CLOB,           -- файл
      nDoc               DT.Reference,   -- ссылка на документ
      sDocLabel          DT.Label,       -- наименование документа
      dtDocOperDate      DATE,           -- дата
      sUserId            DT.Label,       -- пользователь
      nSysFilial         DT.ConstValue,  -- филиал
      sSign              DT.Text         -- список пользователей, с простыми подписями.
   )
   as
      nDevType          DT.Reference;
      nClassified       DT.Reference;
      nClassifiedParent DT.Reference;
      sFileNameResult   DT.Description;
      sClob             CLOB;
      sContentTemp      CLOB;
      sContentTemp1     CLOB;
      nOffset           DT.Counter;
      nNextLength       DT.Counter;
      nSubstrLength     DT.Counter:=16000;
      sTemp             DT.Text;
      sSignEncoded      DT.Text;
      nCount            DT.Counter;
      nCount1           DT.Counter;
      nCount2           DT.Counter;
      dtSignTime        DATE;
      sUserSign         DT.Label;
      nExists           DT.Status;
      nLastSignType     DT.Status;
      nLastSignGroup    DT.Reference;
      bExist            DT.Status;
      nDEVItem          DT.Reference;
      nGenFixDev        DT.Status;
      nGenFixDevWithDel DT.Status;
      nDevReestr        DT.Reference;
   begin
      sFileNameResult := sFileName;
      nDevType := GetDevTypeByCodeAndSource(sDevType, sDevSource);
      nGenFixDev :=0;
      nGenFixDevWithDel:=0;
      -- поиск исправляемого ДЭВ
      if nvl(nDoc, 0)!=0 then
         begin
            select Classified, DEVItem
              into nClassifiedParent, nDEVItem
              from DEVReestr
             where Doc = nDoc
               and FixDev is null
               and Type = nDevType
               and rownum = 1;
            begin
               if nDEVItem is not null then
                  select count(*)
                    into nCount
                    from doctree DT, DocState DS
                   where DT.Classified = nDEVItem
                     and DT.DocState   = DS.Classified
                     and DS.ConstState not in  (0, 5); -- кроме состоянии создан и удален
                  if nCount > 0 then
                     nGenFixDev:=1;
                  end if;
               else
                  select max(Classified)
                    into nDevReestr
                    from DEVReestr
                   where Doc = nDoc
                     and FixDev  = nClassifiedParent
                     and Type = nDevType
                     and rownum = 1 ;
                  if nDevReestr is not null then
                     nGenFixDevWithDel:=1;
                  end if;
               end if;
            end;
         exception
            when no_data_found
               then
                  nDEVItem := null;
                  nClassifiedParent := null;
         end;
      end if;
      if nGenFixDev = 1 or nGenFixDevWithDel = 1 then
         --генерим имя исправительного файла
          GetDEVFileName(sysdate, 2, nDevType , nDoc ,sUserId, sFileName, 0, sFileNameResult);
          if nGenFixDevWithDel = 1 then
            delete from ObjSignature
              where Obj = nClassifiedParent;
            delete from DevReestr
              where Classified = nClassifiedParent;
          end if;
      elsif nClassifiedParent is not null then
         delete from ObjSignature
          where Obj = nClassifiedParent;
         delete from DevReestr
          where Classified = nClassifiedParent;
      end if;


      select classified.nextval into nClassified from dual;

      --sClob := convert(utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(sContent) )), 'CL8MSWIN1251');
      dbms_lob.createtemporary(sContentTemp, true, dbms_lob.session);
      dbms_lob.createtemporary(sContentTemp1, true, dbms_lob.session);
      sContentTemp := sContent;
      while dbms_lob.getlength(sContentTemp)>0
      loop
         nOffset := dbms_lob.instr(sContentTemp, ';');
         if nvl(nOffset, 0)=0 then
           sClob := sClob || convert(utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(sContentTemp) )), 'CL8MSWIN1251');
           sContentTemp :='';
         else
           sClob:= sClob ||  convert(utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(dbms_lob.substr(sContentTemp,  dbms_lob.instr(sContentTemp, ';')-1, 1 ) ))), 'CL8MSWIN1251');
           nNextLength :=dbms_lob.getlength(sContentTemp)-dbms_lob.instr(sContentTemp, ';')+1;
           if  nNextLength > nSubstrLength  then
             sContentTemp1:='';
             nOffset := 0;
              while nOffset<= nNextLength  loop
                sContentTemp1 := sContentTemp1 ||   ltrim(dbms_lob.substr(sContentTemp, nSubstrLength , dbms_lob.instr(sContentTemp, ';')+1+ nOffset));
                nOffset := nOffset + nSubstrLength;
              end loop;
              sContentTemp := sContentTemp1;
           else
              sContentTemp := ltrim(dbms_lob.substr(sContentTemp, dbms_lob.getlength(sContentTemp)-dbms_lob.instr(sContentTemp, ';')+1 , dbms_lob.instr(sContentTemp, ';')+1));
           end if;
         end if;
      end loop;

      sSignEncoded := convert(utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(sSign))),  'CL8MSWIN1251');
--decode(dtDocOperDate, to_date('04.05.2012','dd.mm.yyyy'), null,dtDocOperDate)
      insert into DEVReestr  (Classified, UploadDate,Type, FileContent, FileName, IsControl, FixDev, Doc, DocDate, UserID,  IsSign, DEVItem, SysFilial, Doclabel)
        values (nClassified, sysdate, nDevType, sClob, sFileNameResult, null, null, decode(nDoc, 0, null, nDoc), dtDocOperDate , sUserId, null, decode(nGenFixDev, 1, null, nvl(nDEVItem, null)),nSysFilial,  decode(nDoc, 0, '', sDocLabel));

      nCount := nvl(Content.UnPackNumber('Count', sSignEncoded),0);
      for nIndex in 1..nCount loop
         sTemp := Content.UnPackHierarchy(nIndex, sSignEncoded);
         dtSignTime := Content.UnPackDate('SignTime', sTemp);
         sUserSign := Content.UnPackString('UserId', sTemp);
         -- проверяем нет ли тут уже подписей этого пользовател
         select count(*)
           into nCount1
           from objSignature
          where Obj = nClassified
            and Wrong = 0
            and UserId = sUserSign
            and UnskilledSign=1;
         if nCount1 = 0 then
            insert into ObjSignature(Obj,ObjType, TableName, FileName, SignTime, UserID,  Signature, Wrong, Cert, AttachedSign, UnskilledSign)
               values(nClassified, 1, 'DEVReestr',sFileNameResult, dtSignTime, sUserSign,  sUserSign, 0, null, 0, 1);
         end if;
      end loop;
      -- проверяем наличие хотя бы одной подписи во всех группах для простых подписей
      begin
         bExist := CheckAllSignExists(nClassified, 1, 0);
         if CheckAllSignExists(nClassified, 0, 1) = 1 then
             update DEVReestr
              set IsSign = 1
             where Classified = nClassified;
         end if;
      end;

      if nGenFixDev = 1 then
         update DEVReestr
            set FixDev = nClassified
          where Classified = nClassifiedParent;
      end if;
      if nGenFixDevWithDel = 1 then
         update DEVReestr
            set FixDev = nClassified
          where Classified = nDevReestr;
      end if;

   end DEVReestrInsert_WS;


----------------------------------------------------------------------------------
--13/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DealDep_proc.CreateDepSheduleOfPayments
od.DealDeposit_CalcPercent
od.GetDealDepositPercent_sm

select * from DealSwapPayPeriod
select * from DealSwapInterest


----------------------------------------------------------------------------------
--14/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- векселя под кредитные программы для Перми IPI 143297                                                                                                            ++
-- дал права филиалам на отчет "Справка о векселе" (BBR_TCB_BILLINFO)                                                                                              ++
-- добавил параметр "Первый векселедержатель" и проверку "только ддля типа отчета Журнал" BBR_TCB_BILL_OPER_MSK                                                    ++
-- тестит Епанова  

bbr.BBR_TCB_BILL_OPER_MSK
payee
----------------------------------------------------------------------------------
--17/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.getbillaccount
od.dealdep_proc.CreateDepSheduleOfPayments
od.deal_getpaymentpurpose

od.bus_obj
od.DPC_TCB_CONVUNLOAD

select * from TCB_CRC32 where classified in (219906089, 219906301, 219906002)  --dtsend > sysdate - 1
select * from doctree where classified = 219905311

select rowid, t.* from TCB_CRC32 t order by lastdtchange desc

-- криво были привязаны кассовые счета в подразделениях к ККО 19/1 (Андрянов)
SELECT PARENT
                      FROM department
                     WHERE classified in
                              (SELECT dp
                                 FROM dpaccount
                                WHERE ACCOUNT IN (SELECT ACCOUNT
                                                    FROM bankoper
                                                   WHERE doc = 219906301))
                                                   
                                                   select * from account where classified = 210638167
                                                   
                                                   
        
                                                   
                                                   select * from department where classified = 1221383526
                                                   
----------------------------------------------------------------------------------
--20/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from bill where num = '0021080'

select dt.* -- max(dt.OperDate) -- into dtOldDate
    from BillRange br, BillOper bo, DocTree dt
   where br.Bill in (select classified from bill where num = '0029934') and br.doc=dt.classified and bo.doc=br.doc --and dt.docstate=Constants.State_Close 
      and dt.Category in (702,711)
      
      select * from doccategory where category = 702
      select* from doctree where classified = 217409344


-- правил BBR_TCB_BILL_OPER_MSK (по просьбе Епановой) - dt.OperDate<=EndDate+1 в двух основных циклах                                                         ++
      

bbr.BBR_TCB_BILL_OPER_MSK
od.rate(Rate(bo.OperCurrency,1000001275,pref.exchmatrix,bl.drawdate))

od.DPC_CheckAccBalDoctype_TCB

select * from doctype where classified = 1000133503
select * from generalacctree where classified =1000031783

od.DEAL_CREATEACCOUNT_TCB

-- не мог сгенериться счет требований по процентам 47427* под депозитной сделкой у Хейзе => был закрыт договор                                                 ++

----------------------------------------------------------------------------------
--21/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил od.tcb_set_57d_payreq по просьбе Хейзе                                                                                                               ++

SELECT /*cl1.code*/ * FROM clbankrel cl1 WHERE cl1.clbank = cur.beneficiarybank AND cl1.relation = 1000002508
select * from accounttype where classified = 1000002508
select * from account where classified = 126368
od.TCB_SET_57D_PAYREQ

CREATE OR REPLACE PROCEDURE TCB_SET_57D_PAYREQ
--Нечаев А.М.
--процедура, которая в плат инструкциях по обязат и треб в рублях проставляет нужный текст для использования позже в МТ300
--Внимание и для требований и для бязательств подставляется счёт с одним назначением 1000105419 (Расчеты по конверсионным сделкам (А) Forex) 
--23.07.2010 добален анализ всех возможных вариантов заполнения
--Панфилов М.С. 12.01.2011 затираем первую строку, если там только '/'
--Панфилов М.С. 11.02.2011 если инструкция используется только для МБК, то не проставляем в 57D клиентский счет
--Панфилов М.С. 22.06.2013 у счетов может быть история
AS
  vacc      Varchar2(25);
  nOnlyMBC  number;
BEGIN
  --dpc_veto;
	--raise_application_error(-20000,'++nam'||SQLERRM);
  -- Test statements here  
  FOR cur IN (
 SELECT 
       nvl(t.beneficiaryaccount,
           (SELECT acccode(da.account)
              FROM dealaccount da
             WHERE (da.doc = de.doc)
               AND da.accintention = 1000105419
               AND da.currency = 1000001275)) beneficiaryaccount       
      ,acccode_tcb(t.nostro)  loro_acc
      ,cl1.code our_acc
      ,t.currency
      ,t.doc
      ,t.beneficiarybankname 
			,t.beneficiarybank
      ,t.transactiontype
  FROM dealtransaction t
      ,doctree         d
      ,clbankrel       cl1
      ,dealpact        de
 WHERE t.doctype = 1047168747
   AND t.doc = d.classified
   AND cl1.clbank = 1
   AND cl1.relation = 1000002508
   AND cl1.closedate IS NULL   
	 AND de.doc IN (SELECT DISTINCT dp.doc FROM dealpactpayreq dp, doctree dt WHERE dp.doc = dt.classified and dp.payreq = t.doc and dt.docstate != 1000000037) -- 30/05/2013 Панфилов М.С. "IN" -- 07/09/2011 Панфилов М.С.
	 AND t.doc = context.CurrentDoc
	 )
   LOOP   
	  IF cur.beneficiarybankname IS NULL THEN
	  
	  nOnlyMBC := 0; 
	  begin
	  select count(payreq) into nOnlyMBC from dealpactpayreq where payreq = cur.doc and category != 908; 
	  exception when others then nOnlyMBC := 0;
	  end;
	  	    
	  if nOnlyMBC != 0 then
	  
	   IF cur.transactiontype=1 THEN 
		  IF cur.currency=1000001275 THEN--требования, значит проставляем реквизиты нашего банка 
			  UPDATE dealtransaction t SET t.beneficiarybankname='/'||cur.beneficiaryaccount||chr(13)||chr(10)||' BIC: '||Get_BankCode(1,7)||' INN: '||Get_BankCode(1,20)||chr(13)||chr(10)||' K/S:'||cur.our_acc/*acccode(Pref.NostroAccount)*/ WHERE t.doc=cur.doc;
		  ELSE --валюта не заполняем
			  UPDATE dealtransaction t SET t.beneficiarybankname='' WHERE t.doc=cur.doc;
			END IF; --требования	
		 ELSE --обязательства
		  IF cur.currency=1000001275 THEN--требования, значит проставляем реквизиты нашего банка 
			  IF substr(cur.loro_acc,1,5)='30109' THEN --ЛОРО
				   UPDATE dealtransaction t SET t.beneficiarybankname='/'||cur.loro_acc||chr(13)||chr(10)||'WITH JSB TRANSCAPITALBANK' WHERE t.doc=cur.doc;
				ELSE    
				   BEGIN 
					   SELECT cl1.code INTO vacc FROM clbankrel cl1 WHERE cl1.clbank = cur.beneficiarybank AND cl1.relation = 1000002508 AND context.OperDate >= cl1.opendate and context.OperDate < nvl(cl1.closedate,TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')); --Панфилов М.С. 22.06.2013
					 EXCEPTION
					   WHEN OTHERS THEN  
						   vacc := 'XXXXXXXXXXXXXXXXXXXX'	 ; 
					 END;		 
				   UPDATE dealtransaction t SET t.beneficiarybankname='/'||cur.beneficiaryaccount||chr(13)||chr(10)||' BIC: '||Get_BankCode(cur.beneficiarybank,7)||' INN: '||Get_BankCode(cur.beneficiarybank,20)||chr(13)||chr(10)||' K/S:'||vacc  WHERE t.doc=cur.doc;	
				END IF;
		  ELSE --валюта
			  IF substr(cur.loro_acc,1,5)='30109' THEN --ЛОРО
				   UPDATE dealtransaction t SET t.beneficiarybankname='/'||cur.loro_acc||chr(13)||chr(10)||'WITH JSB TRANSCAPITALBANK' WHERE t.doc=cur.doc;
				ELSE
			     UPDATE dealtransaction t SET t.beneficiarybankname='' WHERE t.doc=cur.doc; 
				END IF;	 
			END IF; --обязательства	
     END IF;
     
     else                   --Панфилов М.С. 11.02.2011 если инструкция только для МБК
     
     IF cur.transactiontype=1 THEN 
		  IF cur.currency=1000001275 THEN--требования, значит проставляем реквизиты нашего банка 
			  UPDATE dealtransaction t SET t.beneficiarybankname=' BIC: '||Get_BankCode(1,7)||' INN: '||Get_BankCode(1,20)||chr(13)||chr(10)||' K/S:'||cur.our_acc/*acccode(Pref.NostroAccount)*/ WHERE t.doc=cur.doc;
		  ELSE --валюта не заполняем
			  UPDATE dealtransaction t SET t.beneficiarybankname='' WHERE t.doc=cur.doc;
			END IF; --требования	
		 ELSE --обязательства
		  IF cur.currency=1000001275 THEN--требования, значит проставляем реквизиты нашего банка 
			  IF substr(cur.loro_acc,1,5)='30109' THEN --ЛОРО
				   UPDATE dealtransaction t SET t.beneficiarybankname='/'||cur.loro_acc||chr(13)||chr(10)||'WITH JSB TRANSCAPITALBANK' WHERE t.doc=cur.doc;
				ELSE    
				   BEGIN 
					   SELECT cl1.code INTO vacc FROM clbankrel cl1 WHERE cl1.clbank = cur.beneficiarybank AND cl1.relation = 1000002508 AND context.OperDate >= cl1.opendate and context.OperDate < nvl(cl1.closedate,TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')); --Панфилов М.С. 22.06.2013
					 EXCEPTION
					   WHEN OTHERS THEN  
						   vacc := 'XXXXXXXXXXXXXXXXXXXX'	 ; 
					 END;		 
				   UPDATE dealtransaction t SET t.beneficiarybankname=' BIC: '||Get_BankCode(cur.beneficiarybank,7)||' INN: '||Get_BankCode(cur.beneficiarybank,20)||chr(13)||chr(10)||' K/S:'||vacc  WHERE t.doc=cur.doc;	
				END IF;
		  ELSE --валюта
			  IF substr(cur.loro_acc,1,5)='30109' THEN --ЛОРО
				   UPDATE dealtransaction t SET t.beneficiarybankname='/'||cur.loro_acc||chr(13)||chr(10)||'WITH JSB TRANSCAPITALBANK' WHERE t.doc=cur.doc;
				ELSE
			     UPDATE dealtransaction t SET t.beneficiarybankname='' WHERE t.doc=cur.doc; 
				END IF;	 
			END IF; --обязательства	
     END IF;
     
     end if;
     	  
	 END IF;
	 --Панфилов М.С. 12.01.2011
	 UPDATE dealtransaction t SET t.beneficiarybankname = substr(t.beneficiarybankname,4) WHERE t.doc=cur.doc and substr(t.beneficiarybankname,0,3) = '/'||chr(13)||chr(10);
   END LOOP;
end;

od.accountcode
od.getpactaccprod
od.accrestin
od.GetPactAccount

od.GetPactClient
od.GetPactProduct
od.GetProductAccValue

----------------------------------------------------------------------------------
--24/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- переносили выдачу векселя 0026854 с 21/06 на 24/06 с Ремпель                                                                                                ++

select * from DEPOACCOUNT where code = 'ТКВ0002SPR05004461' 

od.DPC_DROPDEPOACCOUNT


-- поправил od.DPC_TCB_DealSwift_MT399 (отписать в задаче IPI 61109) просила Хейзе (для сбера)                                                                 ++
od.DPC_TCB_DealSwift_MT399

select * from dealtransaction where doctype = 1047168747 and infoagentbank is not null
select * from doctree where classified = 220818460



----------------------------------------------------------------------------------
--25/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DEAL_CREATEACCOUNT

bbr.BBR_MT320N_TCB
select * from deal where doc = 221026766

-- поправить od.TCB_CLIENTRESIDENT, чтобы дня нерезидентов счета с нуля хоть как-то генерились =>  задача от Хейзе IPI 146253                                     ++
od.TCB_CLIENTRESIDENT


-- При добавлении счетов в портфель в модуле "Фондовые операции" для некоторых назначений счета не отбираются (у Политовой) =>
-- => зарегистрировали в НА замечание 47158 => перевели на замечание 47016, обещают исполнить 26/06/2013 => обещают исполнить 05/07/2013 =>    
-- обещают исполнить 09/08/2013 => 20/08/2013 прислали новый модуль и кучу скриптов => решили пока не ставить => накачено с патчами в декабре 2013                ++

SELECT DT.A_Classified, DT.Code, DT.A_Label, SUBSTR( CurrencyISO( DT.Currency ), 1, 3 ), SUBSTR( AccTypeLabel( DT.Type ), 1, 50 ), SUBSTR( ClientLabel( DT.Client ), 1, 50 ), NULL, NULL, SUBSTR(EntityStateLabel( DT.EntityState ), 1, 50), NULL,
DT.Classified, DT.DocType, DT.Currency, AccForNE( DT.A_Classified ), DT.ReestrType, DT.IsActiveInOper, DT.PairAccount, DT.SortAcc, NULL
FROM  V_DocAccount DT  
  WHERE DT.DocType IN (1014341675,1018027239,1000249246,1015067559,1015067661,1015067485,1011980465,1011980561,1015067763,1015067411,1000133503,1014341614,1014341553,1015067340,1011980609,1011980513,1014341868,1014341797)
    AND DT.Type IN (
        SELECT Classified FROM AccountType
        WHERE Category = 2)
    AND  DT.Type = 1000002506 
  ORDER BY SortAcc /*2*/ ASC
  
  select * from accounttype where classified = 1000002506


-- 47407/47408 неправильно открываются счета в Перми при учете векселей                                                                                           -- 
od.getbillaccount
select * from BillAccIntention where 

select * into recInt from BillAccIntention where Classified = nIntention;

select IsActive, ConstAccType, IsService  --into nIsActive, nConstAccType, nIsService
        from AccountType
       where Classified = 1000134024
----------------------------------------------------------------------------------
--26/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
deal_getpaymentpurpose
od.DPC_DepositDeal_Events

SHEIN_VV.V_CLIENT_TCB
SHEIN_VV.v_objassoc
SHEIN_VV.V_Doctree_Client

SELECT * -- Classified, Label
 FROM CommisionSumType 
  
  ORDER BY 2
  
od.DPC_DealDepCommiss_Events
od.DealDepInterestRS
od.DealDepPaymentRS
od.DealCommisRS

select * from Commisionadd
select * from deal
DealCommisRS
od.dealcommisrs

----------------------------------------------------------------------------------
-- комиссии по траншам МБК
-- привязал в manager для траншей привлечения/размещения для операций "Пересчет графика платежей" и "Пересчет событий по графикам" DPC_DealDepCommiss_Events         ++
-- комиссии через типы сумм не генерятся (сразу ругается на отсутствие суммы + потом нет функционала) => написал в НА 23/06/2013 => зарегистрировали замечание 47179                      
-- => 28/06/2013 прислали скрипт deal1173.sql !!! => всёравно осталась куча вопросов, написал в НА 04/07/2013 => зарегистрировали замечание 47316 => 
-- исполнять не хотят                                                                                                                                                --

----------------------------------------------------------------------------------
od.DealDepInterestRS
od.DPC_DealDepCommiss_Events

select * from od.filial

select * from sysfilial



----------------------------------------------------------------------------------
--27/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from v$version 

select * from zayavka order by datedownload
--delete from zayavka

SELECT * FROM NLS_DATABASE_PARAMETERS

marko common osok d9kf87rgd
  
/*
CREATE TABLE "OSOK"."ZAYAVKA" 
   (	"CLASSIFIED" NUMBER(11,0) NOT NULL ENABLE, 
	"FAMILY" VARCHAR2(100) DEFAULT NULL, 
	"NAME" VARCHAR2(100) DEFAULT NULL, 
	"PATR" VARCHAR2(100) DEFAULT NULL, 
	"BIRTHDAY" VARCHAR2(100) DEFAULT NULL, 
	"PHONE" VARCHAR2(100) DEFAULT NULL, 
	"EMAIL" VARCHAR2(100) DEFAULT NULL, 
	"SUMM" VARCHAR2(100) DEFAULT NULL, 
	"PERIOD" VARCHAR2(100) DEFAULT NULL, 
	"NATIONALITY" VARCHAR2(100) DEFAULT NULL, 
	"REGION_OF_RESIDENCE" VARCHAR2(100) DEFAULT NULL, 
	"REGION_OF_EMPLOYMENT" VARCHAR2(100) DEFAULT NULL, 
	"FORM" VARCHAR2(100) DEFAULT NULL, 
	"SENIORITY" VARCHAR2(100) DEFAULT NULL, 
	"SENIORITY_ALL" VARCHAR2(100) DEFAULT NULL, 
	"STATUS" NUMBER(11,0) DEFAULT 0, 
	"DATEDOWNLOAD" DATE DEFAULT NULL, 
	"EXT_ID" NUMBER(11,0) DEFAULT NULL, 
	"DATEUNLOAD" DATE DEFAULT NULL, 
	"VSUMM" NUMBER(12,2) DEFAULT 0, 
	"VPERIOD" NUMBER(4,0) DEFAULT 0, 
	"VBIRTHDAY" DATE DEFAULT NULL, 
	"VREGION1" NUMBER(11,0) DEFAULT NULL, 
	"VREGION2" NUMBER(11,0) DEFAULT NULL, 
	"VFORM" NUMBER(11,0) DEFAULT NULL, 
	 PRIMARY KEY ("CLASSIFIED")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK" ;
  CREATE UNIQUE INDEX "OSOK"."SYS_C0080166" ON "OSOK"."ZAYAVKA" ("CLASSIFIED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK" ;
  ALTER TABLE "OSOK"."ZAYAVKA" ADD PRIMARY KEY ("CLASSIFIED")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK"  ENABLE;
  ALTER TABLE "OSOK"."ZAYAVKA" MODIFY ("CLASSIFIED" NOT NULL ENABLE);
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."CLASSIFIED" IS 'идентификатор';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."SUMM" IS 'желаемая суммма кредита';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."PERIOD" IS 'желаемый срок кредита';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."NATIONALITY" IS 'гражданство';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."REGION_OF_RESIDENCE" IS 'регион проживания';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."REGION_OF_EMPLOYMENT" IS 'регион трудоустройства';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."FORM" IS 'форма подтверждения ежемесячного дохода';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."SENIORITY" IS 'стаж на текущем месте работы';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."SENIORITY_ALL" IS 'общий трудовой стаж';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."STATUS" IS '0 - загружена из вне; 1 - прошла проверку (готова к выгрузке); 2 - выгружена в mssql';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."DATEDOWNLOAD" IS 'время загрузки';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."DATEUNLOAD" IS 'время выгрузки';

CREATE OR REPLACE TRIGGER zayavka_tr
BEFORE INSERT
ON OSOK.ZAYAVKA 
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
tmpVar NUMBER;
BEGIN
   tmpVar := 0;

   SELECT zayavka_sq.NEXTVAL INTO tmpVar FROM dual;
   :NEW.classified := tmpVar;
   
   :NEW.datedownload := CURRENT_TIMESTAMP;

   EXCEPTION
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END ZAYAVKA_TR;
*/

select * from od.accounttype where classified in (1115822612,1116866141,1115824708,1116864125)
select * from doctree where doctype = 1065660049

----------------------------------------------------------------------------------
-- запросы для Миши по сделкам МБК                                                                                                                                ++
-- запрос по ставкам                                                                                                                                              ++
-- дописать реестровость                                                                                                                                          ++
select * from deal
od.tcb_bki_mbk_proc
select * from dealtype where consttype = 13
select * from docstate where



select doc as "ID сделки в Афине", ticket as "тикет", counterparty as "ID клиента", amountb as "Сумма сделки", valuedate as "Дата начала сделки", repaydate as "Дата фактического погашения" from (
    select d.* from deal d where dealtype in (select classified from dealtype where consttype in (11,12,13,14)) /*and counterparty = od.rec_banks.classified*/
            --and dDate >= valuedate and dDate <= MATURITYDATE
            --and not EXISTS (select doc from dealrollover where dealtransaction is not null connect by prior deal = doc start with deal = d.doc) -- 24/01/2012 Панфилов М.С. - сделки, которые пролонгировались не берем (берём только конечную сделку из цепочки пролонгаций)
            and Exists (select classified from doctree where classified = d.doc and docstate not in (1000000037/*Constants.State_Rollback*/,1000000034))-- 03/07/2012 Панфилов М.С. - чтобы удаленные сделки не попадали 
) 



where doc = 221377912

select * from dealtype where consttype in (11,12,13,14)
----------------------------------------------------------------------------------
--28/06/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------



-- все счета по сделке
select account as "ID счета в Афине", doc as "ID сделки в Афине", acccode(account), (select label from dealaccintention where classified = d.accintention) as "Назначение счета" from dealaccount d where doc = /*nDealID --*/221377912



select * from account where classified in (
53820019,
119038779,
36452490
)
select * from dealaccintention where classified in (10001054245,1000105425)
select * from dealaccount where accintention in (10001054245,1000105425)



-- весь od.bbook по сделке (если счета реестровые, то надо смотреть по реестрам, а реестры для МБК ведутся в Афине сейчас криво)
select distinct * from bbook b where b.debaccount in (
select account from dealaccount d where d.accintention in (select classified from dealaccintention where constintention in (15,16,17,18)) and doc = /*nDealID --*/209250460
and d.rsaccount is null -- смотрим только нереестровые счета
)
union
select * from bbook b where b.credaccount in (
select account from dealaccount d where d.accintention in (select classified from dealaccintention where constintention in (15,16,17,18)) and doc = /*nDealID --*/209250460
and d.rsaccount is null -- смотрим только нереестровые счета
)
union
-- этот кусок для реестровых счетов
select * from bbook where parent in (
    select dt.parent from reestrdoc rd, doctree dt where dt.classified = rd.doc and rd.doc in
    (
    select doc from reestrdoc where reestrinit in
    (
    select doc from reestrdoc rd where initdoc in
    (
    select /*nDealID --*/209250460 from dual
    --union
    --select deal from dealrollover connect by prior deal = doc start with doc = /*nDealID --*/209250460
    ) and doc in (select rsaccount from dealaccount where doc = rd.initdoc and rsaccount is not null and accintention in (select classified from dealaccintention where constintention in (15,16,17,18)))
    ) --and docsum > 0
    ) 
      --and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and doctype = 1047177856)
      --and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and description like 'Пролонгация%')
)




select od.reestrrestout(224679515,td) from dual

select da.DOC as CONTRACTID,
       dtr.label as CONTRACTNUMBER,
       accrestin(da.account, to_date('01082013', 'ddmmyyyy'), 5, 0) as RESTRUB, --сейчас  берем остаток на счете
       od.reestrrestout()
       DE.AMOUNTB deliverysum --сумма выдачи
  from dealaccount da
inner join deal de
    on de.doc = da.doc
   and trunc(DE.DEALDATE) <= to_date('31072013', 'ddmmyyyy')
   and trunc(DE.MATURITYDATE) > to_date('31072013', 'ddmmyyyy')
inner join dealdeposit dd
    on dd.doc = de.doc
inner join doctree dtr
    on dtr.classified = de.doc
inner join account a
    on a.doc = da.account
   and a.code = '31307810800000001029'
   and dtr.category not in (925, 911) --исключаем копии документов МБК
   
   select od.reestrrestout((select classified from doctree where parent = 224679515),td) from dual
   

select * from bbook where parent in (
    select dt.parent from reestrdoc rd, doctree dt where dt.classified = rd.doc and rd.doc in
    (
    select doc from reestrdoc where reestrinit in
    (
    select doc from reestrdoc rd where initdoc in
    (
    select /*nDealID --*/223446535 from dual
    --union
    --select deal from dealrollover connect by prior deal = doc start with doc = /*nDealID --*/209250460
    ) and doc in (select rsaccount from dealaccount where account = (select classified from account where code = '31307810800000001029') )
    ) --and docsum > 0
    ) 
      --and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and doctype = 1047177856)
      --and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and description like 'Пролонгация%')
)   
   
   

select * from dealaccount where account in (select classified from account where code = '31307810800000001029')

select * from bbook where parent in (
221163864,
221390619,
221395440,
221395441
)
select * from doctree where classified in (
221390760,
221399424,
221400451,
221220256
)
select * from reestr where reestrinit in (221139078,221139083)
select * from doctree where classified = 310033
select * from doctype where classified = 1000135307 
select * from dealdeposit where doc = /*nDealID --*/221377912
select * from deal where doc = /*nDealID --*/221377912

select * from dealdeposit where doc = /*nDealID --*/217781095
select * from deal where doc = /*nDealID --*/217781095


-- ставки по сделкам МБК (пока без плавающих, т.к. в Афину МБК с плавающими ставками ещё не заводили и как будут заводить пока не ясно)
select dd.interestrate as "%, Ставка", d.valuedate as "c", d.maturitydate as "по" from dealdeposit dd, deal d where dd.doc = /*nDealID --*/221377912
and d.doc = dd.doc and dd.interestrate is not null
union
select rate, min(startdate), max(enddate) from DealSwapInterest where doc = /*nDealID --*/221377912 group by rate order by 1



od.SPEC_DealDepFixRate
select * from DealSwapInterest where doc = 217781095
select * from od.dealswa

----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--01/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 221709359
select* from billaccount where bill in (select classified from bill where num like '002381_')
select * from balance where account in (select classified from account where code = '52303810900300023824' )

od.deal_getpaymentpurpose

select DealBegProcDate2(218374903) from dual

select * from dealdeposit where doc = 218374903

select bd /*into dtPercbegdate*/ from
          (SELECT trunc(bd) as bd,
                  row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
              FROM (select DISTINCT trunc(OperDate) as bd, doc from DealSwapInterestLog) b
             WHERE doc = 218374903) x where x.rang = 2
             
             select * from DealSwapInterestLog WHERE doc = 218374903
             
             select * from doccategory 
             
             select * from billaccount where account in (select classified from account where code = '52501810500300019195')
             
----------------------------------------------------------------------------------
-- проблема с модулем "Векселя" при Выдаче набора процентных векселей с датой начала начисления процентов => 01/07/2013 написал в НА => 
-- зарегистрировали замечание 47250 => 03/07/2013 ответили, исполнять не хотят => обновить модуля и протестить снова на athena3 =>    
-- поправить Dpc_Bill_SetPercentDate_tcb                                                                                                                          --
----------------------------------------------------------------------------------

od.Dpc_Bill_SetPercentDate_tcb
od.DPC_EditGuidBill

----------------------------------------------------------------------------------
-- проблема по Траншам МБК с назначением платежа по уплате процентов (нет даты "с") => поправить DealBegProcDate2 (учесть варианты, когда уже была только одна дата учета
-- процентов, и, когда учетов вообще не было)                                                                                                                     ++
od.DealBegProcDate2
-- проблема по Траншам МБК с назначением платежа по начислению процентов                                                                                          ++
od.DealBegProcDate
---- протестить 
-- проблема с пятью траншами МБК (напр. с 24/04/2013) - начисляются проценты, а не должны.                                                                        
-- проблема с закрытием кредитной линии od.DPC_DEALLIMIT_CLOSE                                                                                                    
---- удаляем привязку счета лимита КЛ от транша с КЛ (потом нужно сделать допсоглашение уже без линии) 
---- => Ледовская сказала, что отвязывать ничего не нужно и делать доп.соглашение тоже не нужно, а просто нужно убрать проверку в od.DPC_DEALLIMIT_CLOSE
---- => правил od.DPC_DEALLIMIT_CLOSE => НАПИСАТЬ В НА ПО ВКЛЮЧЕНИЮ В ОФФ ПАТЧИ!!!                                                                                +-
---- сделать назначение платежа "Списание неиспользованного остатка по линии № от "                                                                               ++                                                                              
INSERT INTO DEALPAYMENTPURPOSE (classified,parent,code,label,description,fullname,updatedrole,value,isvalue)
VALUES (Classified.nextval, 1131587467, '34', 'Шаблон34', null, '\MBC\34', null, 'Списание неиспользованного остатка по линии № <CLLabel> от <CLVALUEDATE>', 1); 
---- поправить od.DPC_TCB_DESC_FOR_DILING                                                                                                                         ++
---- сделать новый тип документа Внебалансовый кредит (Дилинг) и навесить на него.......................                                                          --
---- сделать новый тип документа Внебалансовый дебет (Дилинг)                                                                                                     --
----------------------------------------------------------------------------------

od.DPC_DEALLIMIT_CLOSE  

CREATE OR REPLACE PROCEDURE DPC_TCB_DESC_FOR_DILING AS
-----------------------------------------------------------------------------------
-- Заполнение назначения платежа в событиях сделок.
-- 16/05/2011 Панфилов М.С. - добавлено назначение для налога на доходы нерезидентов
-- 27/08/2012 Панфилов М.С. - добавлены назначения для траншей МБК
-- 13/12/2012 Панфилов М.С. - теперь назначения по начислению процентов за один день и за несколько - разные
-- 13/06/2013 Панфилов М.С. - новые назначения для траншей МБК привлечения (после запуска функционала "Транши МБК")
-- 02/07/2013 Панфилов М.С. - новые назначения для Внебалансовых кредитов под КЛ МБК
-----------------------------------------------------------------------------------

  ndoc             dt.reference;
  sdesc            dt.description;
  sacccode         VARCHAR2(10);
  nclient          dt.reference;
  nvo              NUMBER;
  nvotext          VARCHAR2(15);
  scred            dt.description;
  recdoctreeparent doctree%ROWTYPE;
  recdeal          deal%ROWTYPE;
  recdealtr        dealtransaction%ROWTYPE;
  sdealtype        dealtype.label%TYPE;
  nisreceive       dealdeposit.isreceive%TYPE;
  nint             dealaccintention.constintention%TYPE;
  dtdate           DATE;
  vclientname      dt.label;

  recDocTree       doctree%ROWTYPE;
  sRowID           RowID;
  sTicket          VARCHAR2(50);
  sclient          dt.description;
  startdealdate    DATE;
  enddealdate      DATE;
  nIntReceive      DT.ConstValue := 15;
  nIntPlace        DT.ConstValue := 16;
  rAccMain         DealAcc.tAcc;
  dtpercbegdate    DATE;                               -- начало %% интервала
  dtpercenddate    DATE;                               -- конец  %% интервала

  boacc            DT.Label;
  cl               dt.reference;

BEGIN
  IF CONTEXT.SubSystem <> 9 THEN
    RETURN;
    END IF;

   sRowID := Context.DocRowID;
   select * into recDocTree from DocTree where RowID = sRowID for update;
   if recDocTree.Parent is null then
      return;
   end if;

  SELECT d.category
    INTO ndoc
    FROM doctree d
   WHERE d.classified = CONTEXT.currentdoc;
  SELECT dt.*
    INTO recdoctreeparent
    FROM doctree dt
   WHERE dt.classified = parentdoc(CONTEXT.currentdoc);
dbms_output.put_line('sdesc000  ='||sdesc);
--ELSIF ndoc = 5 AND recdoctreeparent.category = 913 AND recdoctreeparent.doctype = 1033718051
dbms_output.put_line('ndoc  ='||ndoc);
dbms_output.put_line('recdoctreeparent.category  ='||recdoctreeparent.category);
dbms_output.put_line('recdoctreeparent.doctype  ='||recdoctreeparent.doctype);
  IF ndoc = 70 AND recdoctreeparent.category IN (901, 902) THEN
dbms_output.put_line('sdesc0001  ='||sdesc);
    -- Срочные сделки

    SELECT substr(acccode_tcb(bo.account), 1, 3)
      INTO sacccode
      FROM bankoper bo
     WHERE bo.doc = CONTEXT.currentdoc;
    IF sacccode IN (930, 933) THEN
      -- Для открытия
            sdesc := DEAL_GetPaymentPurpose('\FOREX\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    ELSE
      -- Для закрытия
            sdesc := DEAL_GetPaymentPurpose('\FOREX\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    END IF;

  ELSIF ndoc = 905 THEN
    -- Для событий

    SELECT *
      INTO recdealtr
      FROM dealtransaction
     WHERE doc = CONTEXT.currentdoc;

    -- Если событие включено в неттинг или пролонгировано, то не обрабатываем
    IF recdealtr.isnetting != 0 THEN
      RETURN;
    END IF;
	   IF recdoctreeparent.category <> 903 THEN
		SELECT t.counterparty, t.creditline                                 -- перенес из секции ниже (901,903) т.к. признак резидентности
        INTO nclient, cl                                                -- клиента нужен еще в друших местах 13/06/2013 добавил КЛ
        FROM deal t
       WHERE t.doc = recdoctreeparent.classified;
      nvo := isclresident(nclient);
		 END IF;
dbms_output.put_line('sdesc01  ='||sdesc);
    IF recdoctreeparent.category IN (901, 913) THEN
dbms_output.put_line('sdesc02  ='||sdesc);
      IF recdoctreeparent.category IN (901, 913) AND recdealtr.currency = 1000001275 THEN
      IF nvo = 0 THEN
        sdesc := DEAL_GetPaymentPurpose('\FOREX\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      ELSE
        sdesc := DEAL_GetPaymentPurpose('\FOREX\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
      ELSIF recdoctreeparent.category IN (901, 913) AND recdealtr.currency != 1000001275 THEN
        sdesc := DEAL_GetPaymentPurpose('\FOREX\5', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
    END IF;
dbms_output.put_line('sdesc02  ='||sdesc);
   -- Депозит

   if recDocTreeParent.Category = 908 then
      -- вид сделки (депозит/кредит) определить по наименованию
      select lower(DealTypeLabel(D.DealType)), DD.IsReceive
         into sDealType, nIsReceive
         from Deal D, DealDeposit DD
         where D.Doc = recDocTree.Parent and DD.Doc = D.Doc;

      -- определить по счету, это осн. сумма или %
      select min(AI.ConstIntention) into nInt
         from DealAccount DA, DealAccIntention AI
         where DA.Doc = recDocTree.Parent and DA.AccIntention =  AI.Classified
            and DA.Account in (select Account from DealTrAccount where Doc = recDocTree.Classified and Amount != 0);

   IF recdoctreeparent.doctype in (1047168347,1047168245) THEN   -- собственно депозитная сделка
      if instr(sDealType, 'кредит') > 0 or instr(sDealType, 'овердр') > 0 THEN
dbms_output.put_line('sdesc0  ='||sdesc);
      if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
                 elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
dbms_output.put_line('sdesc1  ='||sdesc);
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary  in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
         elsif nInt in (18, 58) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR  nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
                 end if;
dbms_output.put_line('sdesc2  ='||sdesc);
      end if;
      else
      if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\5', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\7', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\8', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (18, 58) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\7', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      end if;
      end if;
   ELSIF recdoctreeparent.doctype in (1179850206,1179850377) THEN   -- транши МБК

   dbms_output.put_line('nIsReceive  ='||nIsReceive||'; nInt ='||nInt);

   if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\21', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
                      END IF;
                 elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\22', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\23', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\24', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            dbms_output.put_line('sdesc21  ='||sdesc);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            --sdesc := DEAL_GetPaymentPurpose('\MBC\22', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            if cl is not null then                                  -- 13/06/2013 Панфилов М.С.
              sdesc := DEAL_GetPaymentPurpose('\MBC\32', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            else
              sdesc := DEAL_GetPaymentPurpose('\MBC\33', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            end if;
            IF (recdealtr.beneficiary  in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
            END IF;
            dbms_output.put_line('sdesc22  ='||sdesc);
         elsif nInt in (18, 58) then
            -- sdesc := DEAL_GetPaymentPurpose('\MBC\23', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            if cl is not null then                                  -- 13/06/2013 Панфилов М.С.
              sdesc := DEAL_GetPaymentPurpose('\MBC\30', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            else
              sdesc := DEAL_GetPaymentPurpose('\MBC\31', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            end if;

            IF (recdealtr.beneficiary in (24763,63979263) OR  nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO99090}'||sdesc ;
            END IF;
            dbms_output.put_line('sdesc23  ='||sdesc);
         end if;
dbms_output.put_line('sdesc2  ='||sdesc);
      end if;

   END IF;
   end if;
    -- Неттинг

    IF recdoctreeparent.category = 903 THEN
      SELECT t.counterparty
        INTO nclient
        FROM dealnetting t
       WHERE t.doc = recdoctreeparent.classified;

      IF recdealtr.currency = 1000001275 THEN
        nvo := isclresident(nclient);
        IF nvo = 0 THEN
            sdesc := DEAL_GetPaymentPurpose('\NETTING\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        ELSE
            sdesc := DEAL_GetPaymentPurpose('\NETTING\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        END IF;

        IF getobjectcode(nclient, 5) = 'NCCB' THEN
          sdesc := DEAL_GetPaymentPurpose('\NETTING\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        END IF;
      ELSE
        sdesc := DEAL_GetPaymentPurpose('\NETTING\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
    END IF;

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 901 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\FOREX\7', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 903 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\NETTING\7', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 908 THEN
    -- Для плановых поступлений

    if getdoctype(recdoctreeparent.PARENT) in (1047168347,1047168245) then
    sdesc := DEAL_GetPaymentPurpose('\MBC\12', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
    elsif getdoctype(recdoctreeparent.PARENT) in (1179850206,1179850377) then                           -- 27/08/2012 Панфилов М.С.
    sdesc := DEAL_GetPaymentPurpose('\MBC\26', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
    end if;

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 913 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\1', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 903 THEN
    -- Для внутренних платежей

    sdesc := DEAL_GetPaymentPurpose('\NETTING\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 901 THEN

    sdesc := DEAL_GetPaymentPurpose('\FOREX\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 913 THEN

    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND getdoccategory(recdoctreeparent.PARENT) = 908 AND recdoctreeparent.doctype = 1047177856 THEN

    sdesc := DEAL_GetPaymentPurpose('\MBC\9', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  /*ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND getdoccategory(recdoctreeparent.PARENT) = 908 AND recdoctreeparent.doctype != 1047177856 THEN

        select acccode(ACCOUNT) into boacc from bankoper where doc = recDocTree.Classified;                     -- 16/05/2011 Панфилов М.С.

    IF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1047168347) or (recdoctreeparent.doctype = 1047168245) THEN
        sdesc := DEAL_GetPaymentPurpose('\MBC\10', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    ELSE
        sdesc := DEAL_GetPaymentPurpose('\MBC\11', recdoctreeparent.classified,  CONTEXT.currentdoc, null);     -- 16/05/2011 Панфилов М.С.
    END IF;
  */

  ELSIF ndoc = 5 AND recdoctreeparent.category = 913 AND recDocTree.doctype = 1033718051 THEN      -- 30/06/2011 Панфилов М.С.
dbms_output.put_line('sdesc3  ='||sdesc);
    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
dbms_output.put_line('sdesc4  ='||sdesc);
  ELSIF (ndoc = 11 or ndoc = 12) AND recdoctreeparent.category = 905  THEN      -- 12/08/2011 Панфилов М.С.
dbms_output.put_line('sdesc5  ='||sdesc);
    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\3', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
dbms_output.put_line('sdesc6  ='||sdesc);
  ELSIF ndoc = 5 AND recdoctreeparent.category = 908 AND recdoctreeparent.doctype != 1047177856 THEN            -- 27/05/2011 Панфилов М.С.
        select acccode(ACCOUNT) into boacc from bankoper where doc = recDocTree.Classified;                     -- 16/05/2011 Панфилов М.С.
    IF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1047168347) or (recdoctreeparent.doctype = 1047168245) THEN
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\10', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\27', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    ELSIF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1179850377) or (recdoctreeparent.doctype = 1179850206) THEN -- 27/08/2012 Панфилов М.С.
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\25', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\28', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    ELSE
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\11', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\29', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    END IF;

  ELSIF ndoc = 75 AND recdoctreeparent.category = 928 THEN -- внебалансовые кредиты под КЛ МБК -- Панфилов М.С. 02/07/2013 
        sdesc := DEAL_GetPaymentPurpose('\MBC\34', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
  ELSE
    sdesc := '';
  END IF;

  UPDATE doctree t
     SET t.description = sdesc
   WHERE t.classified = CONTEXT.currentdoc;


   UPDATE doctree
   SET description = sdesc
   WHERE classified IN (SELECT classified
                              FROM doctree
                             WHERE PARENT = CONTEXT.currentdoc);

END dpc_tcb_desc_for_diling;

-- удаляем привязку счета лимита КЛ от транша с КЛ (потом нужно сделать допсоглашение уже без линии) 
-- => Ледовская сказала, что отвязывать ничего не нужно и делать доп.соглашение тоже не нужно, а просто нужно убрать проверку в od.DPC_DEALLIMIT_CLOSE
select * from od.dealaccount where doc = 221557792 and accintention = 1000234597
delete from od.dealaccount where doc = 221557792 and accintention = 1000234597

select * from dealaccintention
select * from DEALPAYMENTPURPOSE
select * from doctree where classified = 222151503

----------------------------------------------------------------------------------
--02/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * /*bd into dtPercbegdate*/ from
          (SELECT trunc(bd) as bd,
                  row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
              FROM (select DISTINCT trunc(OperDate) as bd, doc from DealSwapInterestLog 
                    union
                    select trunc(d.valuedate), d.doc from deal d
                    ) b
             WHERE doc = /*221083813 217677727*/ 222347809) x --where  x.rang = 2
select * from deal where doc = 221083813

od.Dealbegprocdate
             
create or replace function DealBegProcDate2(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления даты начала предыдущего периода начисления процентов по траншу.
-- Автор: Панфилов М.С. (на основе DealBegProcDate)
-- Версия: 14.04.2011
--         10.06.2013 адаптирована для сделок траншей МБК (Зам. № 46876)
--         13.06.2013 Панфилов М.С.
--         03/07/2013 Панфилов М.С. - теперь учтен вариант, когда уже была только одна дата начисления процентов.
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference  -- идентификатор сделки
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
     dbms_output.put_line(' ppp0 dtPercBegDate  ='||dtPercBegDate);
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null or nIsTransh = 0 then
      --это не депозитная сделка
      return null;
   end if;
   if nIsTransh = 1 then
      -- дата начала предыдущего периода начисления процентов по траншу
      select bd into dtPercbegdate from
          (SELECT trunc(bd) as bd,
                  row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
              FROM (select DISTINCT trunc(OperDate) as bd, doc from DealSwapInterestLog
                    union
                    select trunc(d.valuedate), d.doc from deal d
                   ) b
             WHERE doc = nDoc) x where x.rang = 2;
   end if;
   return dtPercBegDate;
end DealBegProcDate2;
create or replace function DealBegProcDate(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления предыдущей даты начисления процентов по депозитной сделке.
-- Автор: Цветков В.
-- Версия: 14.04.2011
--         10.06.2013 адаптирована для сделок траншей МБК (Зам. № 46876)
--         03/07/2013 Панфилов М.С. - теперь учтен вариант, когда начислений процентов ещё не было.
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference  -- идентификатор сделки
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null then
      --это не депозитная сделка
      return null;
   end if;
   --
   if nIsTransh = 1 then
      -- последняя дата учета процентов по сделке.
      select nvl(max(OperDate),d.valuedate) into dtPercbegdate
        from DealSwapInterestLog ds, deal d
      where ds.Doc = nDoc and d.doc = ds.doc;
   else
      select DA.Account,DA.rsAccount
        into nAccount,nRSAccount
        from DealAccount DA, DealAccIntention DAI
       where DA.Doc = nDoc
         and DA.AccIntention = DAI.Classified
         and DAI.ConstIntention = decode(nIsReceive, 1, 18, 17);
      --
      if nRSAccount is null then
         select max(BegDate) into dtPercbegdate
           from Balance
          where Account = nAccount
            and EndDate > dtStartdealdate
            and Type = 1
            and EndTurn = 0
            and trunc(BegDate) < trunc(EndDate);
           -- order by EndDate ASC;
      else
         select max(BegDate) into dtPercbegdate
           from Reestr
          where ReestrInit = nRSAccount
            and EndDate > dtStartdealdate
            and Type = 1
            and trunc(BegDate) < trunc(EndDate);
      end if;
   end if;
   return dtPercBegDate;
end DealBegProcDate;



od.DealBegProcDate
----------------------------------------------------------------------------------
--03/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.Dpc_Bill_SetPercentDate_tcb

Bill_p.sm_bill


select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     --into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = 222347809
      and D.doc = DD.doc(+)

----------------------------------------------------------------------------------
--05/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.Dpc_Bill_SetPercentDate_tcb
od.DPC_EditGuidBill

----------------------------------------------------------------------------------
--08/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from workplace where classified = 1000360288
od.bus_obj
resman.pkg_tcb
select * from doctype@to_athena

select * from TCB_SWIFT_MT950_TO_ATH

declare
begin
  dbms_output.put_line('001');
od.create_docs_by_mt950;
  dbms_output.put_line('002');
end;

select * from TCB_SWIFT_MT950_TO_ATH where  upper(msg_) like '%ZACISLENIE%V%RAMKAH%PROVEDENIA%'

SELECT t.id
                    ,t.amount
                    ,t.tran
                    ,t.valuedate
                    ,t.msg_
                    ,t.instrument_id
                FROM tcb_swift_mt950_to_ath@to_rn t
               WHERE t.status = 0
               
               
               RESMAN.TR_TRANSACTIONS_BD
               
select * from doctree
764105

-- править od.create_docs_by_mt950 (просила Бароева), скрипт ниже                                                                                     
CREATE OR REPLACE PROCEDURE create_docs_by_mt950 AS
  ncurr         VARCHAR2(10);
  sdoclabel     dt.label;
  idaccountfrom dt.reference;
  idaccountto   dt.reference;
  scurr         dt.reference;
  iddoc         dt.reference;
  sdoc          dt.reference;   
	sDesc          VARCHAR2(200); 
	sMonth        VARCHAR2(200); 
BEGIN
  dbms_output.put_line('003');
  FOR cur IN (SELECT t.id
                    ,t.amount
                    ,t.tran
                    ,t.valuedate
                    ,t.msg_
                    ,t.instrument_id
                FROM tcb_swift_mt950_to_ath@to_rn t
               WHERE t.status = 0)
  LOOP 
    
  dbms_output.put_line('id: ' || cur.id);

    SELECT decode(cur.instrument_id,329, 'RUR', 324, 'EUR', 318, 'USD')
      INTO ncurr
      FROM dual; 
    IF ncurr <> 'RUR' THEN
       /*RETURN;*/ exit;                                                -- 08/07/2013 Панфилов М.С. по задаче IPI 145533
    END IF;
    IF /*ncurr = 'USD' THEN
      IF cur.tran = 'C' THEN
        IF upper(cur.msg_) LIKE '%VISA%INT%L%BASE%II%' THEN
          idaccountfrom := getaccbycode_tcb(30114840300000000027);
          idaccountto   := getaccbycode_tcb(30232840200001000024); 
          sDesc:= 'Расчеты по системе VISA' ;
        END IF;
      ELSIF cur.tran = 'D' THEN
        IF upper(cur.msg_) LIKE '%VISA%INT%L%BASE%II%' THEN
          idaccountfrom := getaccbycode_tcb(30233840500001000024);
          idaccountto   := getaccbycode_tcb(30114840300000000027); 
          sDesc:= 'Незавершенные расчеты с ПС VISA';
        END IF;
      END IF;
    ELSIF */ncurr = 'RUR' THEN
      IF cur.tran = 'C' THEN
        IF upper(cur.msg_) LIKE
           '%ZACISLENIE%V%RAMKAH%PROVEDENIA%' THEN
          idaccountfrom := getaccbycode_tcb('30110810600001000051');
          idaccountto   := getaccbycode_tcb('30233810200001000024');
          sDesc:= 'Зачисление в рамках проведения расчетов между участниками расчетов VISA отчет VSS от '||(cur.valuedate-1);
        ELSIF upper(cur.msg_) LIKE '%PROC.%ZA%' THEN
          idaccountfrom := getaccbycode_tcb('30110810600001000051');
          idaccountto   := getaccbycode_tcb('47427810300001000024');   
          SELECT DECODE (to_char(td,'mm'),02,'Январь',03,'Февраль',04,'Март',05,'Апрель',06,'Май',07,'Июнь',08,'Июль',09,'Август',10,'Сентябрь',11,'Октябрь',12,'Ноябрь',01,'Декабрь') INTO sMonth FROM dual  ;
          sDesc:= 'Проценты за '||sMonth||' '||to_char(cur.valuedate,'yyyy')||'г. согласно Договора №285 от 21/09/2011г.' ;
        ELSIF upper(cur.msg_) LIKE
              '%SPISANIE%V%RAMKAH%PROVEDENIA%' THEN
          idaccountfrom := getaccbycode_tcb('30110810900001000052');
          idaccountto   := getaccbycode_tcb('30110810600001000051');
          sDesc:='Списание в рамках проведения расчетов между участниками расчетов VISA отчет VSS от '||cur.valuedate;
        END IF;
      ELSIF cur.tran = 'D' THEN
        IF upper(cur.msg_) LIKE '%VAQE%MT202%RUR%' THEN
          idaccountfrom := getaccbycode_tcb('70606810610002520201');
          idaccountto   := getaccbycode_tcb('30110810600001000051'); 
          sDesc:= 'Списание суммы комиссии за телекоммуникационные расходы';
        ELSIF upper(cur.msg_) LIKE
              '%SPISANIE%V%RAMKAH%PROVEDENIA%' THEN
          idaccountfrom := getaccbycode_tcb('30233810200001000024');
          idaccountto   := getaccbycode_tcb('30110810900001000052'); 
          sDesc:='Списание в рамках проведения расчетов между участниками расчетов VISA отчет VSS от '||cur.valuedate;
        END IF;
      END IF;
/*    ELSIF ncurr = 'EUR' THEN
      IF cur.tran = 'C' THEN
        IF upper(cur.msg_) LIKE '%VISA%INTERNATIONAL%SERVICE%' THEN
          idaccountfrom := getaccbycode_tcb('30114978200001000027');
          idaccountto   := getaccbycode_tcb('30232978800001000024');
          sDesc:= 'Незавершенные расчеты с ПС VISA';
        END IF;
      ELSIF cur.tran = 'D' THEN
        IF upper(cur.msg_) LIKE '%VISA%INTERNATIONAL%SERVICE%' THEN
          idaccountfrom := getaccbycode_tcb('30232978800001000024');
          idaccountto   := getaccbycode_tcb('30114978200001000027'); 
          sDesc:= 'Незавершенные расчеты с ПС VISA';
        END IF;
      END IF;*/
    END IF;
    
    c_access.SetWorkPlace(1000360288);
    c_access.SetFilial(1);  
    getdoctreelabel(1000135409, 5, NULL, cur.valuedate, NULL, NULL, 0, sdoclabel);
    scurr := getcurrency_isoalph(ncurr);
    iddoc := createinternaltransfer(1000135409, -- тип документа  --внутренний перевод
                                    '', -- назначение генерации
                                    '', -- родительский документ
                                    1, -- подсистема
                                    1000002516, -- Род операции
                                    sdoclabel, -- Номер документа
                                    idaccountfrom, -- Счет дебета
                                    cur.amount, -- Сумма
                                    scurr, -- Валюта платежа
                                    idaccountto, -- Счет кредита
                                    cur.amount, -- Сумма после конверсии
                                    scurr, -- Валюта после конверсии
                                    1011980095, -- Схема конверсии
                                    1, -- курс обмена
                                    NULL, -- базовая валюта
                                    NULL, -- валюта котировки
                                    NULL, -- множитель базовой валюты
                                    sDesc, -- Назначение платежа
                                    cur.valuedate, -- Дата
                                    0, -- признак зак. оборотов
                                    cur.valuedate, -- Дата валютирования.
                                    NULL, -- Код назначения движения ден. средств
                                    NULL, -- Код направления движения ден. средств
                                    '', -- приоритет платежа
                                    FALSE, -- признак проверки прав
                                    '', -- номер пачки
                                    '', -- дата платежа
                                    '', -- очередность платежа
                                    NULL, -- RsFrom
                                    NULL, -- RsTo
                                    '',
                                    NULL, -- idNotblObj
                                    NULL, -- idDocObj
                                    NULL, -- idDocInitObj
                                    1);
                                    
                                     dbms_output.put_line('id2: ' || cur.id);
                                    
    BEGIN
      BEGIN
        SELECT t.classified
          INTO sdoc
          FROM doctree t
         WHERE t.classified = iddoc;
      EXCEPTION
        WHEN no_data_found THEN
          NULL;
      END;
      IF sdoc IS NOT NULL THEN
        UPDATE tcb_swift_mt950_to_ath@to_rn t
           SET t.status = 1
              ,t.ath_class = sDoc
         WHERE t.id = cur.id;
      END IF;
    END;
   dbms_output.put_line(iddoc);
  END LOOP;
  /*
     update doctree set AuthorWP = nWorkPlace, 
                    AuthorID = sExecutor
       where Classified = idDoc;
  */
  
  update doctree set AUTHORID = 'BAROEVA_IT' where classified = idDoc;                 -- 08/07/2013 Панфилов М.С. по задаче IPI 145533 

END create_docs_by_mt950;





od.CreatePercentAccountDoc
od.dpc_CreatePercentAccountDoc

select *from desclist
select* from desclist where classified =  1143737811
od.DealGetCommis
od.CMP_DEALPERCENTSUMM





      select ABS (DTA.Amount), D.CounterParty
        --into nOperSumm.Amount, nClient
        from DealTrAccount DTA,
             DocTree DT,
             DealAccount DA,
             DealAccintention DAI,
             Deal D
       where DTA.Doc = 221029648 -- 221026766
         and DT.Classified = DTA.Doc
         and DT.Parent = DA.Doc
         and DA.Account = DTA.Account
         and DA.AccIntention = DAI.Classified
         --and DAI.ConstIntention in (18, 58, 21)
         and D.Doc = DT.Parent;
         
         select * from DealAccintention where constintention in (17)
         
-- правил вычисляемый объект od.CMP_DealPercentSumm и подвязал к макетам дилинговых договоров новую комиссию по Размещенным кредитам (54707)               ++
----------------------------------------------------------------------------------
--09/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.srp_accountspersonal_forts
select * from codesystem where classified = 1000011322

SELECT rowid, bc.*
                  FROM bankcode bc
                 WHERE  codesystem = 1000011322 /*and code = '588'*/ and client in (select classified from client where doctype != 1000000441)

insert into 3611426



select * from client where label like '%ICAP%'
select * from client where classified = 25542
select * from doctype where classified in (
1000000441,
1000133055)

select * from client where classified in (
27208394,
27208352
)

----------------------------------------------------------------------------------
-- закачка счетов по сделкам с ц.б. из FortsBO в Афину (для небанка нерезедента "ICAP" связываемся через фиктивный рег. номер банка = 3611426) для Политовой     ++
----------------------------------------------------------------------------------

od.DPC_TCB_CreateBillAcc

select * from 

select* from sysfilial 

delete from billaccount where bill in (select classified from bill where num = '0021709')

select* from billaccintention where classified = 1011996343

select * from billrepayinterval
select * from repayinterval

select * from 
od.dpc_tcb_desc_for_diling

begin
select od.DealBegProcDate(217687523) from dual;
end;

DealBegProcDate2

RESMAN.TR_TRANSACTIONS_BD
----------------------------------------------------------------------------------
--10/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- чтобы банкнотные сделки переходили в состояние "Исполнен" после исполнения всех дочерних документов, добавил в manager для "Событий банкнотных сделок"
-- на действие "Исполнить" DPC_PROCESSLINKOBJECT, и добавил на обработке связанных объектов для исполнения родительской банкнотной сделки условие
-- "Все дочерние исполнены?"                                                                                                                                      ++
-- чтобы транши МБК переходили в состояние "Исполнен" после исполнения всех дочерних документов, добавил в manager для "Событий сделок" в обработке
-- связанных объектов исполнение родительских траншей                                                                                                             ++



select * from bill where num = '0331473'
select * from bill where num = '0418569'
update bill set isinoper = 0 where num = '0331473'
update bill set isinoper = 0 where num = '0418569'

select * from bill where classified in (
select bill from billaccount where account in (select classified from account where code in ( 
'52301810300000000000',
'52304810300000027080',
'52304810900200026398',
'52306978100000015200'))
)

select * from sysfilial
select * from filial

----------------------------------------------------------------------------------
--11/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проблемы с валютными траншами МБК
--- Индексы для плавающих ставок МБК загружаются из RN в Афину со смещением в один день => выставил в dbms_jobs 2526287 время загрузки 16:03 => проверить =>
--- отписал в задачу                                                                                                                                              ++
od.get_transfert_rate_tcb
--- поправить поле 72 для валютной платежки по комиссии od.dpc_tcb_set_deal_purpose (скрипт ниже) доработать получение даты по события сделки => отписал в задачу ++
od.dpc_tcb_set_deal_purpose
--- счета 313* и 47427* по РосБанку открылись с неправильными хвостами => так и должно быть => отписал в задачу                                                   ++                                                                                         --
od.DPC_FXDeal_AccSet

select * from doccategory

select * from doctype where classified in(
1047168245,
1047168347,
1179850206,
1179850377)

select * from accounttype where classified in(1056398023,1056391379)
select * from accounttype where classified in(1000064947,1000064955)

select * from billstatushistory where bill in (
select * from bill where classified in 
(1204346571
,1111847390
,1111847393
,1111847396
,1111847428
,1111847464
,1111847467
,1111847470
,1111847473
,1111847476
,1200090989
,1216994208
,1200090116)
)
1204346571

select * from bill b where sysfilial = (select sysfilial from filial where b.maker = client) --9852
select * from bill b

select (select sysfilial from filial where b.maker = client), b.* from bill b where classified in 
(1204346571
,1111847390
,1111847393
,1111847396
,1111847428
,1111847464
,1111847467
,1111847470
,1111847473
,1111847476
,1200090989
,1216994208
,1200090116) and sysfilial = (select sysfilial from filial where b.maker = client)


----------------------------------------------------------------------------------
--12/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.CLSDAY_MARKET_ACCOUNTING

select * from portfolioaccount where security = 1163517610 -- trunc(begdate) = trunc(sysdate-7)
select sysdate from dual
select * from deposecurity where classified = 1163517610

od.DPC_CreateTransactionsByRepo
select * from doctree where classified = 221234265
select * from doctype where classified = 1016571671
od.Dpc_Tradecalctotalsum
od.TransactionCommis
od.Editportfolioaccount
od.DPC_CheckPortfolioLinkAcc 

select /*+ INDEX(PA cU_PortfolioAccount_All) */
    PA.Classified,
    PA.Security, substr( SecurityLabel( PA.Security ), 1, 50 ) SecurityLabel,
    PA.Currency, C.CodeISOAlph CurrencyCode, PA.ContractCurr, substr( CurrencyISO(PA.ContractCurr),1,3),
    PA.AccIntention, AI.Label IntentionLabel,
    PA.Market, substr( CompetitorLabel( PA.Market ), 1, 50 ) MarketLabel,
    PA.Account,
    substr( decode( PA.IsDepoAcc, 0, AccountCode( PA.Account ), 1, DepoAccountCode( PA.Account ), 2, DepoAccountCode( PA.Account ), 3, DepoCode( PA.Account )), 1, 50 ) AccountCode,
    PA.IsDepoAcc,
    PA.CompetitorType, CT.Label, PA.OperationType, ConstantLabel( PA.OperationType, 'PortfolioAccount','OperationType' ),
    PA.SecurityType, SecurityTypeLabel( PA.SecurityType ), PA.IsResident, decode( PA.IsResident, 0, 'нерезидент', 1, 'резидент', '' ),
    PA.TradeSession, PA.TradeClearingAccount, TCA.Code, ETV.Classified, ETV.Label,
    decode(PA.BegDate, Min_Date, null, PA.BegDate), decode(PA.EndDate, Max_Date, null, PA.EndDate),
    to_number(null), '', to_number(null), ''
  from PortfolioAccount PA, Currency C, AccIntention AI,
          ClientType CT, TradeClearingAccount TCA, EnumTypeValue ETV
  where PA.Portfolio = 1033589735 and PA.TradeClearingAccount=TCA.Classified(+)
     and PA.AccIntention = AI.Classified
     and PA.Currency = C.Classified(+)
     and AI.AccCategory in ( select Category from DocCategory )
     and PA.CompetitorType = CT.Classified(+)      
     and PA.EnumValue = ETV.Classified(+)
  order by AI.AccCategory, IntentionLabel, SecurityLabel, CurrencyCode, MarketLabel, PA.EndDate

----------------------------------------------------------------------------------
--15/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_FXDEAL_CONV 

select * from dealaccount where doc = 108451978

select * from dealaccintention 1156809336

-- древняя сделка с ПФИ не вставала в День1, пришлось подвязать счет прям к сделке для Бакумцевой                                                           ++
insert into DealAccount value 
(select doc, 1156809336, 1000001275, 155753344, null, 0, contextvalue, startdate, enddate, null, null, null, null, null from DealAccount where doc = 108451978 and account = 155752391)

-- сделал статус "отрпавлено в БЭК-офис" по сделке 2590555 в RN для Бакумцевой                                                                              ++

-- меняем для трех Ярославских векселей срок платежа (+ если позвонят, то надо будет поправить старые суммы в billsum)                                      ++
update bill set paydatevar = 1 where num in ('0021196','0021197','0021198')
select * from bill where num in ('0021196','0021197','0021198')

select * from billsum where bill in (
select classified from bill where num in ('0021196','0021197','0021198')
)

select* from repayinterval where classified in (
1011996328,
1011996326)

select * from billsum where bill = 1241786408
select * from billsum where bill = 1241786292


od.makebillaccrual
----------------------------------------------------------------------------------
--16/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- запрос для Волкорезова М.С. (связь "Перевод из другого банка" с "Депозитной сделкой МБК") => выявили проблему по депозитным сделкам привлечения - по ним 
-- ВСЕГДА кривой реестр по счету ОД => посоветовал активировать вопрос к Ледовской про квитовку "переводов из другого банка (руб)"                             ++

select * from deal


select * from doctree where classified = 222524761
-- вал
select * from doctree where classified = 221801065
select * from doctype where classified = 1000161029
select * from doctype where classified = 1047168245
select * from doctree where classified = 221793386

-- для переводов из другого банка (вал)

select od.mainparentdoc(classified)/*депозитная сделка*/ from doctree where obj = 221801065/*перевод из другого банка (вал)*/

-- для переводов из другого банка (руб) такой связки через квитовку нет. И сделку можно вычислить через счет или реестр по счету, если счет реестровый.  


select * from account where code = '31302810200000002733'

select dtr.*, dtr.classified, dtr.label
  from dealaccount dt
inner join deal de
    on de.doc = dt.doc
   and trunc(DE.DEALDATE) <= '28.05.2013'
   and trunc(DE.MATURITYDATE) > '28.05.2013'
inner join dealdeposit dd
    on dd.doc = de.doc
inner join doctree dtr
    on dtr.classified = de.doc
   and dtr.category not in (925, 911)
inner join account a
    on a.doc = dt.account
   and a.code = '31302810200000002733'
   
   

-- этот кусок для реестровых счетов
select * from bbook where parent in (
    select dt.parent from reestrdoc rd, doctree dt where dt.classified = rd.doc and rd.doc in
    (
    select doc from reestrdoc where reestrinit in
    (
    select doc from reestrdoc rd where initdoc in
    (
    /*select*/ /*nDealID --*/217264543 /*from dual*/
    --union
    --select deal from dealrollover connect by prior deal = doc start with doc = /*nDealID --*/209250460
    ) and doc in (select rsaccount from dealaccount where doc = rd.initdoc and rsaccount is not null and accintention in (select classified from dealaccintention where constintention in (15,16,17,18)))
    ) --and docsum > 0
    ) 
      --and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and doctype = 1047177856)
      --and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and description like 'Пролонгация%')
)   
   


select d.operdate, r.* from reestrdoc r, doctree d where accountwithreestr = 1116805260 and d.classified = r.classified
select d.operdate, r.* from reestrdoc r, doctree d where accountwithreestr = 1116825419 and d.classified = r.classified

select * from accountwithreestr where account = 6942372
select * from accountwithreestr where account = 118185358
select * from doctree where classified = 217277869
select * from doctree where classified = 217264734
select * from doctype where classified = 1000161094
select * from doctype where classified = 1000135223
   
select * from doctree where classified =118242711
   
select dt.*, b.*
  from doctree dt
inner join BBOOK b
    on b.parent = dt.classified
      --  and b.debaccount = 20100062
   and b.credaccount = 6942372
   and trunc(b.operdate) = to_date('28.05.2013', 'dd.mm.yyyy')
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--17/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from fx

select * from f_get_form701_test_new
select * from tbl_form701_tcb
f_get_form701_test_new

----------------------------------------------------------------------------------
-- нужно поправить форму 701 для Бакумцевой => тестят                                                                                                             ++
-- исходник:
CREATE OR REPLACE FUNCTION f_get_form701_test_new
 (PTD DATE
 ,PROLL_CLT_MIO CHAR
 ,vfilial_id in integer
 )
 RETURN TBL_FORM701_TCB
 IS
 vTICKET FLOAT;
 vinstr_B integer;
 vinstr_S integer;
 vCBNUM VARCHAR2(5);
 vCSNUM VARCHAR2(5);
 vVALUEBUY DATE;
 vVALUESELL DATE;
 vCUSTID varchar2(150);
 vBOURSE VARCHAR2(10);
 vBIK VARCHAR2(200);
 vBUY FLOAT;
 vSELL FLOAT;
 vRATE FLOAT;
 vTRADERNAME VARCHAR2(40);
 vCLIENT VARCHAR2(70);
 vRESID CHAR(1);
 vMINAMOUNT FLOAT;
 vGROUPID INTEGER;
 vSWAP_ID INTEGER;
 vSWAP VARCHAR2(5);
 vFILIAL VARCHAR2(5);
 vRESIDENT VARCHAR2(5);
 vDEPARTMENT VARCHAR2(5);
 vBANK VARCHAR2(5);
 vBICINT VARCHAR2(20);
 vEXCL_F701 VARCHAR2(5);
 vCOUNT_C INTEGER;
 vNUM_TMP VARCHAR2(5);
 vCB_NALTYPE VARCHAR2(5);
 vCS_NALTYPE VARCHAR2(5);
 vCOUNTRY_NAME VARCHAR2(70);
 vCOUNTRY_CODE_ VARCHAR2(20);
 vAMOUNT_TMP_USD FLOAT;
 vREGN VARCHAR2(10);
 vRATE_TEMP FLOAT;
 tbl TBL_FORM701_TCB := TBL_FORM701_TCB();
 vcid  number;
BEGIN
 vCOUNT_C := 0;
 FOR Cur IN (SELECT  fx.ticket,fx.tradedate, valuebuy, valuesell, c.custid, fx.cid, buy, sell, rate, instr_b, instr_s, swap_id, swap,
                     DECODE(f_deal_ismezhportfol(fx.ticket, 'FX', fx.sec_tradeaccount_id, fx.cid), 1, 'True', 'False') AS DEPARTMENT -- saj department
										 ,DECODE(F_CUST_INROLE(c.ID, 'BRCH', c.SEC_ROLES), 1, 'True', 'False') AS filial  
									   ,(SELECT f.typeinput FROM protocol_fx f WHERE f.id = ( SELECT MIN(t.ID) FROM protocol_fx t WHERE t.ticket = fx.ticket)) typeinput 	-- ,fx.typeinput srb 28.09.2011 Т.к. после ручного редактирования сделки typeinput становиться равным 0
										 ,NVL((SELECT co.code_value FROM CODES co WHERE co.entity_id=c.id AND co.type_id=455 AND rownum = 1),'RTRS') comm
               FROM  fx, customer c, nostro n_ta,cfu p
							-- , sec_tmp_account_loro tmp-- nam 31.09.2009
              WHERE (fx.tradedate          =   pTD)
								AND fx.sec_tradeaccount_id IN
										 (666, 667, 668, 672, 680, 695, 723, 790, 846, 1709, 3250, 3349, 3352, 3370, 3390, 4314, 4340, 4414, 4415, 4557, 4558)							
                --AND fx.sec_tradeaccount_id=tmp.account_id--nam 31.09.2009
								and fx.sec_tradeaccount_id=n_ta.accpointer
                and p.id  = n_ta.cfu_id
                AND (n_ta.FILIAL_ID       =   VFILIAL_ID)
                AND n_ta.INCL_701_FORM='True'
                and c.id(+)= fx.cid   
						--		AND fx.ticket=1777838
                AND (n_ta.accpointer(+) =   fx.sec_tradeaccount_id)
								AND decode(BITAND(c.sec_roles,4),0,'False','True')='False' 
                AND (n_ta.filial_id     <>  fx.cid) -- исключаем межпортфельные сделки
/*SELECT ticket
      ,valuebuy
      ,valuesell
      ,c.custid
      ,fx.cid
      ,buy
      ,sell
      ,rate
      ,instr_b
      ,instr_s
      ,swap_id
      ,swap
      ,decode(f_deal_ismezhportfol(fx.ticket, 'FX', fx.sec_tradeaccount_id, fx.cid),
              1,
              'True',
              'False') AS department -- saj department
      ,c.filial
			,'FX'
  FROM fx
      ,customer c
      ,nostro n_ta
      ,portfol p
 , sec_tmp_account_loro tmp-- nam 31.09.2009
 WHERE (tradedate = pTD)
       AND fx.sec_tradeaccount_id=tmp.account_id--nam 31.09.2009
   AND fx.sec_tradeaccount_id = n_ta.accpointer
   AND p.portfid = n_ta.portfid
   AND (n_ta.filial_id = 222)
   AND p.incl_701_form = 'True'
   AND c.id(+) = fx.cid
   AND (n_ta.accpointer(+) = fx.sec_tradeaccount_id)
   AND (n_ta.filial_id <> fx.cid)
UNION
SELECT
       t.ticket
			,t.valuedate valuebuy
      ,t.maturity  valuesell
			,c.custid
			,c.id
      ,decode(t.tran, 'T', t.amount, t.amount + t.interest) buy
			,decode(t.tran, 'P', t.amount + t.interest, t.amount) sell
      ,to_number(t.rate, '99D9999')  rate
      ,decode(t.tran, 'T', t.instrument_id, t.instrument_id) instr_b
			,decode(t.tran, 'P', t.instrument_id, t.instrument_id) instr_s
			,NULL swap_id
			,NULL swap
      ,'False' AS department -- saj department
      ,c.filial
			,'DEPO'
  FROM dp t, customer c,nostro n_ta
      ,portfol p
 , sec_tmp_account_loro tmp-- nam 31.09.2009
 WHERE t.tradedate = pTD
   AND p.portfid = n_ta.portfid
	 AND t.sec_tradeaccount_id=tmp.account_id--nam 31.09.2009
   AND (n_ta.filial_id = 222)
   AND p.incl_701_form = 'True'
   AND c.id(+) = t.cid
   AND (n_ta.accpointer(+) = t.sec_tradeaccount_id)
   AND (n_ta.filial_id <> t.cid)	*/
            )
       LOOP
   vcid:=Cur.cid;
   vTICKET := Cur.ticket;
   vVALUEBUY := Cur.tradedate;
   vVALUESELL := Cur.valuesell;
   vCUSTID := Cur.custid;
   vBUY := Cur.buy;
   vSELL := Cur.sell;
   vRATE := Cur.rate;
   vinstr_B := Cur.instr_b;
   vinstr_S := Cur.instr_s;
   vSWAP_ID := Cur.swap_id;
   vSWAP    := Cur.SWAP;
   vDEPARTMENT := Cur.Department;
   if vswap not in ('BS','SB') then
      vSWAP_ID:=-1;
   end if;

   BEGIN
     SELECT DECODE(F_CUST_INROLE(c.ID, 'BANK', c.SEC_ROLES), 1, 'True', 'False') AS BANK,
            NVL(bicdom, ''), bicint,
            decode(BITAND(c.sec_roles,4),0,'False','True') as department,
            DECODE(F_CUST_INROLE(c.ID, 'BRCH', c.SEC_ROLES), 1, 'True', 'False') AS FILIAL,
            DECODE(F_CUST_INROLE(c.ID, 'RZDT', c.SEC_ROLES), 1, 'True', 'False') AS RESIDENT,
            NVL(n.country_name, '?'), NVL(regn, ''),n.code_
      INTO vBANK, vBIK, vBICINT, vDEPARTMENT, vFILIAL, vRESIDENT, vCOUNTRY_NAME, vREGN, vCOUNTRY_CODE_
       FROM customer c , countries n
      WHERE c.id=vCID  and n.id(+) = c.country_id;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       vDEPARTMENT := 'False';
       vFILIAL := 'False';
       vRESIDENT := 'True';
       vBANK := 'True';
       vBIK := null;
       vREGN := null;
       vCOUNTRY_NAME := '';
   END;



--
   if vBIK = '' then
     vBIK := null;
   end if;
   if vREGN = '' then
     vREGN := null;
   end if;
--
   IF (vRESIDENT = 'True') THEN
     vCOUNTRY_NAME := 'RUSSIA';
   END IF;
   IF ((vCOUNTRY_NAME IS NULL) OR (vCOUNTRY_NAME = '')) THEN
     vCOUNTRY_NAME := '?';
   END IF;
   IF (vRESIDENT = 'True') THEN
     vRESID := 'R';
   ELSE
     vRESID := 'N';
   END IF;
--   IF ((vREGN = '') AND (vBIK <> '')) THEN
   IF ((vREGN is null) AND (vBIK is not null)) THEN
     BEGIN
       SELECT REGN INTO vREGN FROM BANKS WHERE BIK=vBIK;
     EXCEPTION
       WHEN NO_DATA_FOUND THEN
         NULL;
     END;
   END IF;
   IF (vBANK = 'False') THEN
     vBIK := '';
     vCLIENT := 'K';
   ELSE
     vClient := '';
     IF (NOT (vREGN IS NULL)) THEN
--     IF (vREGN <> '') OR (NOT (vREGN IS NULL)) THEN
       vBIK := vREGN;
     END IF;
   END IF;

   --"	Графа 11 должна содержать значения K (латинскoе) или D или B (латинскoе), если ее длина равна 1, или должен быть указан трехзначный цифровой код страны.
   if f_parameter_str('FORM701_INCLIENT_SECT_C_CODE','False')='True' then
     vclient:=vCOUNTRY_CODE_;
   end if;

   BEGIN
     SELECT NVL(iso_digv, -1), NVL(nal_type, 'False') INTO vNUM_TMP, vCB_NALTYPE FROM ccy_all WHERE instrument_id=vinstr_B;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       vNUM_TMP := -1;
       vCB_NALTYPE := 'False';
   END;
   vCBNUM := vNUM_TMP;
   BEGIN
     SELECT NVL(iso_digv, -1), NVL(nal_type, 'False') INTO vNUM_TMP, vCS_NALTYPE FROM ccy_all WHERE instrument_id=vinstr_S;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       vNUM_TMP := -1;
       vCS_NALTYPE := 'False';
   END;
   vCSNUM := vNUM_TMP;
   SELECT NVL(MAX(excl_f701), 'False') INTO vEXCL_F701 FROM ccypair WHERE (((instr1=vinstr_B) AND (instr2=vinstr_S)) OR ((instr1=vinstr_S) AND (instr2=vinstr_B)));
   IF ((pTD >= to_date('01.05.2002', 'dd.mm.yyyy')) AND (vCLIENT = 'K')) THEN
     IF ((vCB_NALTYPE = 'True') OR (vCS_NALTYPE = 'True')) THEN
       vEXCL_F701 := 'True';
     END IF;
   END IF;
   IF ((vDEPARTMENT = 'False') AND (vEXCL_F701 = 'False')) THEN
      vBUY := NVL(vBUY, 0);
      VSELL := NVL(vSELL, 0);
      IF ((vRESIDENT = 'False') AND (vBANK = 'True')) THEN
        vBIK := vBICINT;
        IF ((vBIK IS NULL) OR (vBIK = '')) THEN
          SELECT MAX(english1) INTO vBIK FROM customer WHERE id=vCID;
          IF ((vBIK IS NULL) OR (vBIK = '')) THEN
            vBIK := vCUSTID;
          END IF;
          vBIK := vBIK||', '||vCOUNTRY_NAME;
        END IF;
      END IF;
      vBUY  := vBUY/1000;
      vSELL := vSELL/1000;
      vBOURSE := '';  
		  IF cur.typeinput=1 THEN
				IF cur.comm<>'PHONE' THEN 
					 vBOURSE := 'RTRS';
				ELSE
					 vBOURSE := 'PHONE'; 
				END IF;
			END IF;  
      IF (vCUSTID = 'MICEX') OR (vCUSTID = 'NCCB') THEN
        vBOURSE := 'MMVB';
				vBIK := '';
      END IF;
      IF (vCUSTID = 'SICE') THEN
        vBOURSE := 'SMVB';
      END IF;
      IF (vBUY > vSELL) THEN
        vMINAMOUNT := vSELL;
      ELSE
        vMINAMOUNT := vBUY;
      END IF;
      vCOUNT_C := vCOUNT_C + 1;
      IF ((pROLL_CLT_MIO = 'Y') AND (vCLIENT = 'K')) THEN
        IF (f_ccy_iso(vinstr_B) = 'USD') THEN
          vAMOUNT_TMP_USD := vBUY;
        ELSIF (f_ccy_iso(vinstr_S) = 'USD') THEN
             vAMOUNT_TMP_USD := vSELL;
           ELSE
             CONVERTCCY(vBUY, vinstr_B, f_ccy_instrument('USD'), pTD, vAMOUNT_TMP_USD, vRATE_TEMP);
        END IF;
        IF (vAMOUNT_TMP_USD IS NULL) THEN
          vAMOUNT_TMP_USD := 0;
        END IF;
        IF (vAMOUNT_TMP_USD < 1000000) THEN 
          vBIK := '';
          IF (vRESID = 'R') then
            vGROUPID := -3;
          ELSE
            vGROUPID := -4;
          END IF;
          vTICKET := 0;
          vBOURSE := '';
        END IF;
      ELSIF (vMINAMOUNT < 0.5) THEN
           IF (vCLIENT = 'K') THEN
             vBIK := '';
             IF (vRESID = 'R') THEN
               vGROUPID := -3;
             ELSE
               vGROUPID := -4;
             END IF;
             vTICKET := 0;
             vBOURSE := '';
           ELSE
             IF (vRESID = 'R') THEN
               vGROUPID := -1;
               vBIK := '000000000';
             ELSE
               vGROUPID := -2;
               vBIK := 'XXXXXXXX';
             END IF;
             vTICKET := 0;
             vBOURSE := '';
           END IF;
         ELSE
           vGROUPID := vCOUNT_C;
         END IF;
         IF vGROUPID = -1 THEN
            vCUSTID := 'BANK_RESIDENT';
         ELSIF vGROUPID = - 2 THEN
              vCUSTID := 'BANK_NONRESIDENT';
            ELSIF vGROUPID = -3 THEN
                 vCUSTID := 'CLIENT_RESIDENT';
               ELSIF vGROUPID = -4 THEN
                    vCUSTID := 'CLIENT_NONRESIDENT';
        END IF;
         IF (/*(vBOURSE <> '') OR */(vBOURSE='MMVB') OR (vBOURSE='SMVB')/*(NOT (vBOURSE IS NULL))*/) THEN
           vGROUPID := -10;
         END IF;
         IF (vCBNUM <> vCSNUM) THEN
						 --исключение по филиалам если сделка с филиалом тогда по курсу ЦБ и пересчитываем сумму покупки\продажи относительно валюты
						 IF cur.filial='True' AND (vinstr_B=national_ccy OR vinstr_S=national_ccy) THEN
								vRATE := f_market_rate(pTD,national_bank,f_get_lead_idccy(cur.instr_b, cur.instr_s),national_ccy,'False','CLOSE_PRICE',0)/*/f_get_rate_amount(f_get_lead_idccy(cur.instr_b, cur.instr_s),pTD)*/; -- srb 27.09.2011 f_market_rate быть может делит на кол-во валюты в курсе ?!
								IF cur.instr_b=national_ccy THEN
								   vBUY := vSELL*vRATE;
								ELSE
								   vSELL := vBUY*vRATE;
								END IF;
						 END IF;
						 --end   
						 --свопы
						 IF length(vswap)>1 THEN
						    vswap := 'S';
						 ELSE 
						   	 vswap := '';	
						 END IF;
           tbl.extend;
           tbl(tbl.last) := TP_FORM701_tcb(vTICKET, f_ccy_iso(vinstr_B), f_ccy_iso(vinstr_S), vCBNUM, vCSNUM, vVALUEBUY, vVALUESELL,
                                       vCUSTID, vBOURSE, vBIK, vBUY, vSELL, NULL, vTRADERNAME,
                                       vCLIENT, vRESID, vMINAMOUNT, vGROUPID, vSWAP_ID,vswap, vFILIAL,NULL,NULL);
         END IF;
   END IF;
 END LOOP;

 FOR cur IN(SELECT
								 t.ticket
								,t.valuedate valuebuy -- графе 2
								,t.maturity  valuesell  --графе 3
								,t.tradedate
								,c.id
								,t.instrument_id --графа 4,7
								,decode(t.tran, 'T', t.amount, abs(t.amount) + abs(pkg_deal_dp.func_deal_interest(t.ticket))) buy --графа 5
								,decode(t.tran, 'T', abs(t.amount) +abs(pkg_deal_dp.func_deal_interest(t.ticket)), t.amount) sell --графа 7
							--	,DECODE(F_CUST_INROLE(c.ID, 'RZDT', c.SEC_ROLES), 1, 'True', 'False') AS RESIDENT --графа 8
								,c.custid --графа 9
								,NULL --графа 10
								,ct.code_ --графа 11
								,'DEPO'  --графа 13
								,to_number(round(t.rate,4), '99D9999')  rate  --графа 14
								--,c.filial
								,NVL(ct.country_name, '?') country_name
								,DECODE(F_CUST_INROLE(c.ID, 'BRCH', c.SEC_ROLES), 1, 'True', 'False') AS FILIAL
								,NVL(bicdom, '') bicdom,bicint
								,DECODE(F_CUST_INROLE(c.ID, 'RZDT', c.SEC_ROLES), 1, 'True', 'False') AS RESIDENT
								,DECODE(F_CUST_INROLE(c.ID, 'BANK', c.SEC_ROLES), 1, 'True', 'False') AS BANK
								,NVL(regn, '') regn
								,t.typeinput  
								,NVL((SELECT co.code_value FROM CODES co WHERE co.entity_id=c.id AND co.type_id=455),'RTRS') comm
						FROM dp t, customer c,nostro n_ta
								,cfu p
								,countries ct     
					   --  , sec_tmp_account_loro tmp-- nam 31.09.2009
					 WHERE t.tradedate = ptd
						 AND p.id = n_ta.CFU_id
						 AND (t.amount*f_get_rate(t.instrument_id,t.tradedate).rate>=1000000)   -- srb 28.04.2011 по просьбе Бакумцевой  добавлено "="
						 AND t.sec_tradeaccount_id IN
										 (666, 667, 668, 672, 680, 695, 723, 790, 846, 1709, 3250, 3349, 3352, 3370, 3390, 4314, 4340, 4414, 4415, 4557, 4558)							
               --tmp.account_id --nam 31.09.2009
						 AND (n_ta.filial_id = vfilial_id)
						 AND n_ta.incl_701_form = 'True'
						 AND c.id(+) = t.cid    
						-- AND t.ticket=1777838
						 AND (n_ta.accpointer(+) = t.sec_tradeaccount_id)
						 AND (n_ta.filial_id <> t.cid)
						 AND ct.id(+) = c.country_id
						 AND DECODE(F_CUST_INROLE(c.ID, 'BRCH', c.SEC_ROLES), 1, 'True', 'False')='False'
	 )
 LOOP

   vcid:=Cur.id;
   vTICKET := Cur.ticket;
   vVALUEBUY := Cur.tradedate;
   vVALUESELL := Cur.valuesell;
   vCUSTID := Cur.custid;
   vBUY := Cur.buy;
   vSELL := Cur.sell;
   vRATE := Cur.rate;
   vinstr_B := Cur.Instrument_Id;
   vinstr_S := Cur.Instrument_Id;
   vSWAP_ID := NULL;
   vSWAP    := NULL;
	 vFILIAL  := cur.filial;
	 vCOUNT_C := vCOUNT_C + 1;
	 vGROUPID := vCOUNT_C;
	 vBIK     := cur.bicdom;
	 vRESIDENT:= cur.resident;
	 vBICINT  := cur.bicint;
	 vCOUNTRY_NAME := cur.country_name;
	 vBANK         := cur.bank;
	 vREGN         := cur.regn;

   BEGIN
     SELECT NVL(iso_digv, -1), NVL(nal_type, 'False') INTO vNUM_TMP, vCB_NALTYPE FROM ccy_all WHERE instrument_id=vinstr_B;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       vNUM_TMP := -1;
       vCB_NALTYPE := 'False';
   END;
   vCBNUM := vNUM_TMP;
   BEGIN
     SELECT NVL(iso_digv, -1), NVL(nal_type, 'False') INTO vNUM_TMP, vCS_NALTYPE FROM ccy_all WHERE instrument_id=vinstr_S;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       vNUM_TMP := -1;
       vCS_NALTYPE := 'False';
   END;

	 IF ((vRESIDENT = 'False') AND (vBANK = 'True')) THEN
		vBIK := vBICINT;
		IF ((vBIK IS NULL) OR (vBIK = '')) THEN
			SELECT MAX(english1) INTO vBIK FROM customer WHERE id=vCID;
			IF ((vBIK IS NULL) OR (vBIK = '')) THEN
				vBIK := vCUSTID;
			END IF;
			vBIK := vBIK||', '||vCOUNTRY_NAME;
		END IF;
	 END IF;

   IF (vBANK = 'False') THEN
     vBIK := '';
     vCLIENT := 'K';
   ELSE
     vClient := '';
     IF (NOT (vREGN IS NULL)) THEN
--     IF (vREGN <> '') OR (NOT (vREGN IS NULL)) THEN
       vBIK := vREGN;
     END IF;
   END IF;

   IF (vRESIDENT = 'True') THEN
     vRESID := 'R';
   ELSE
     vRESID := 'N';
   END IF;

	 IF cur.typeinput=1 THEN
		  IF cur.comm<>'PHONE' THEN 
				 vBOURSE := 'RTRS';
			ELSE
				 vBOURSE := 'PHONE'; 
			END IF;
	 ELSIF substr(cur.typeinput,1,1)='3' THEN
	    vBOURSE := 'MMVB';
	 ELSE
	    vBOURSE := 'E';
	 END IF;

	 IF vBIK = '044501002' THEN
	    vBIK := 'CBRF';
   END IF;

   vBUY  := round(vBUY/1000,3);
   vSELL := round(vSELL/1000,3);

   vCSNUM := vNUM_TMP;

           tbl.extend;
           tbl(tbl.last) := TP_FORM701_tcb(vTICKET, f_ccy_iso(vinstr_B), f_ccy_iso(vinstr_S), vCBNUM, vCSNUM, vVALUEBUY, vVALUESELL,
                                       vCUSTID, vBOURSE, vBIK, vBUY, vSELL, vRATE, vTRADERNAME,
                                       vCLIENT, vRESID, vMINAMOUNT, vGROUPID, vSWAP_ID,vswap, vFILIAL,'DEPO',cur.rate);
 END LOOP;

 RETURN tbl;
END;

----------------------------------------------------------------------------------


----------------------------------------------------------------------------------
--18/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- запросы для Катасова по векселям                                                                                                                              ++                                                                                                                                                              
select * from billoper

select (select operdate from doctree where doc = bs.doc) from billsum bs where bill in (select classified from bill where num = '0031013') 
select (select operdate from doctree where doc = bs.doc) from billsum bs where bill in (select classified from bill where num = '0031016') 
select * /*operdate*/ from doctree where classified in (select doc from billsum bs where bill in (select classified from bill where num = '0031013'))
select * /*operdate*/ from doctree where classified in (select doc from billsum bs where bill in (select classified from bill where num = '0023915'))

select * from billsumtype where classified in (1011996477,1011996370,1042775368)

-- даты начисления процентов/дисконтов по собственному векселю
select operdate from doctree where classified in (select doc from billoper bs where bill in (select classified from bill where num = '0031016')) and docstate = 1000000035 and doctype = 1042775240
-- даты начисления процентов/дисконтов по стороннему векселю
select operdate from doctree where classified in (select doc from billoper bs where bill in (select classified from bill where num = '0327367')) and docstate = 1000000035 and doctype = 1042775299






-- даты начисления процентов по собственному векселю
select operdate from doctree where classified in (select doc from billsum bs where bill in (select classified from bill where num = '0031016'/*номер векселя*/) and sumtype in (select classified from billsumtype where consttype = 14)) and docstate = 1000000035
-- даты начисления процентов по стороннему векселю
select operdate from doctree where classified in (select doc from billsum bs where bill in (select classified from bill where num = '0238219'/*номер векселя*/) and sumtype in (select classified from billsumtype where consttype = 29)) and docstate = 1000000035




select * from doctype where classified in (select * from billoper bs where bill is null)
select * from doctree where classified in (select doc from billoper bs where bill is null) and docstate = 1000000035 and doctype = 1042775240
in (select classified from bill where num = '0031013') 
select * from doctype where category = 704 classified = 1042775240
select* from doccategory


select * from billsumtype where classified in (
1011996478,
1042775364,
1042775365,
1011996370
)

select * from bill where classified in (
1206803512,
1206803997,
1186507886
)

select * from bill where num = '0031097'
select * from bill where classified in (
1251701645
)
select * from billsum where bill in (1251701645)

select * from billsum where bill in (
select classified from bill where classified in (
1206803512,
1206803997,
1186507886
)
)

-- дисконт выдачи собственного векселя
select amount from billsum bs where bill in (select classified from bill where num = '0031097'/*номер векселя*/) and sumtype in (select classified from billsumtype where consttype = 11)

-- дисконт при учете стороннего векселя 
select b.billsum - bs.amount from billsum bs, bill b where bs.bill = b.classified and b.num = '004950'/*номер векселя*/ and bs.sumtype in (select classified from billsumtype where consttype = 23)

select * from billsum where  sumtype in (select classified from billsumtype where consttype = 30)
select * from doctree where classified = 206432518
select * from dealdeposit
od.UT_DEALACCRUAL

-- запросы для Катасова по сделкам МБК (сделал новую функцию DealBegProcDate_TCB)                                                                               ++

create or replace function DealBegProcDate_TCB(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления предыдущей даты начисления процентов по депозитной сделке от заданной даты.
-- на основе DealBegProcDate
-- 22/07/2013 Панфилов М.С.
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference,  -- идентификатор сделки
   ddate            date          -- дата
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null then
      --это не депозитная сделка
      return null;
   end if;
   --
   if nIsTransh = 1 then
      -- последняя дата учета процентов по сделке.
      select nvl(max(OperDate),d.valuedate) into dtPercbegdate
        from DealSwapInterestLog ds, deal d
      where ds.Doc = nDoc and d.doc = ds.doc and trunc(ds.operdate) <= ddate group by d.valuedate;
   else
      select DA.Account,DA.rsAccount
        into nAccount,nRSAccount
        from DealAccount DA, DealAccIntention DAI
       where DA.Doc = nDoc
         and DA.AccIntention = DAI.Classified
         and DAI.ConstIntention = decode(nIsReceive, 1, 18, 17);
      --
      if nRSAccount is null then
         select max(BegDate) into dtPercbegdate
           from Balance
          where Account = nAccount
            and EndDate > dtStartdealdate
            and Type = 1
            and EndTurn = 0 and trunc(BegDate) <= ddate
            and trunc(BegDate) < trunc(EndDate);
           -- order by EndDate ASC;
      else
         select max(BegDate) into dtPercbegdate
           from Reestr
          where ReestrInit = nRSAccount
            and EndDate > dtStartdealdate
            and Type = 1 and trunc(BegDate) <= ddate
            and trunc(BegDate) < trunc(EndDate);
      end if;
   end if;
   return trunc(dtPercBegDate);
end DealBegProcDate_TCB;
 
select od.DealBegProcDate_TCB(220533422,td) from dual

select max(startdate) from billstatushistory where bill in (select classified from bill where num = '0031016') and status = 2 -- собственный
select max(startdate) from billstatushistory where bill in (select classified from bill where num = '0327367') and status = 6 -- сторонний

----------------------------------------------------------------------------------
-- поменял типы счетов для Обязательств/Требований по %% в настройках типов сделок "Лимит выдачи на размещение/привлечение" на реестровые                       ++


select * from dealswap

----------------------------------------------------------------------------------
--19/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


 SELECT * -- Label, Description
 FROM Holidayschema
 WHERE Classified = 1199945084
 
 SELECT * -- DayNumber, MonthNumber
 FROM ConstHoliday
 WHERE HolidaySchema = 1199945084
 
  SELECT * from holiday where HolidaySchema = 1199945084 -- EUR
  SELECT * from holiday where HolidaySchema = 1000131227 -- RUS
  SELECT * from holiday where HolidaySchema = 1200760328 -- USA
  SELECT * from holiday where HolidaySchema = 1200760270 -- SWE

-- добавил выходные для календаря USA за 2012 по субботам и воскресеньям                                                                                        ++
insert into holiday value (select 1200760328, holidaydate from holiday where HolidaySchema = 1199945084 and holidaydate < to_date('01.01.2013','dd.mm.yyyy') )

-- добавил ещё выходные для календарей EUR и USA за 2002-2011 по субботам и воскресеньям                                                                                                    ++
insert into holiday value (select 1200760328, holidaydate from holiday where HolidaySchema = 1000131227 and holidaydate < to_date('01.01.2012','dd.mm.yyyy') and ((to_char(holidaydate,'d')=6) or to_char(holidaydate,'d')=7))
insert into holiday value (select 1199945084, holidaydate from holiday where HolidaySchema = 1000131227 and holidaydate < to_date('01.01.2012','dd.mm.yyyy') and ((to_char(holidaydate,'d')=6) or to_char(holidaydate,'d')=7))

-- скопировал выходные для календаря SWE из EUR за за 2002-2012 (29/07/2013) 
insert into holiday value (select 1200760270, holidaydate from holiday where HolidaySchema = 1199945084 and holidaydate < to_date('01.01.2013','dd.mm.yyyy') and ((to_char(holidaydate,'d')=6) or to_char(holidaydate,'d')=7))
insert into holiday value (select 1200760270, holidaydate from holiday where HolidaySchema = 1199945084 and holidaydate < to_date('01.01.2013','dd.mm.yyyy') and holidaydate >= to_date('01.01.2012','dd.mm.yyyy') and ((to_char(holidaydate,'d')=6) or to_char(holidaydate,'d')=7))


SELECT * from holiday where HolidaySchema in (1200760328,1200760270)

select * from constholiday where HolidaySchema = 1200760328

select to_char(td-2,'d') from dual

----------------------------------------------------------------------------------
--22/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_BillInterChange

od.DPC_FillDealDepInterest

-- проблемы с валютными траншами МБК 07/2013
--- процентный график разбивается лишний раз в конце года, несмотря на то, что база от високосности года не зависит 
--- (скорее всего проблема в DealDep_proc.CorrectMainShedule) => написал в НА 22/07/2013 => зарегистрировали замечание 47556 => обещают исправить 26/07/2013 =>
--- прислали deal1178.sql => тесты на боевой                                                                                                                        ++
--- проблема с нумерацией траншей, внутри одной кредитной линии (КЛ = 217645254) => добавить/удалить два фиктивных транша для выправления последовательности =>
--- (вдальнейшем, для полного решения проблемы, возможно стоит заменить в manager в соответствующих вариантах шаблона "последовательность" на "функцию") =>
--- см. 23/10/2013                                                                                                                                                  +-
--- при пересчете процентного графика не учитывается сумма последней амортизации, если дата последней амортизации совпадает с датой уплаты процентов (
--- и события по процентам и амортизации в этой дате уже исполнены) (транш от 10/09/2010 с AKBN) => написал в НА 24/07/2013 => зарегистрировали замечание 47604 => 
--- обещают исправить 26/07/2013 => прислали deal1178.sql =>     тесты на боевой                                                                                    ++
--- проблемы с доп.соглашениями по траншам МБК: => написал в НА 25/07/2013 => зарегистрировали замечание 47624 => обещают исправить 31/07/2013 =>                   
--- 07/08/2013 обещают скоро прислать новый модуль для тестов на сборке 1871 => 08/08/2013 прислали deal1100.sql,deal1101.sql,deal1109.sql,deal1114.sql
--- deal1181.sql + новые модуля => 09/08/2013 тесты на athena3 !!! => накатить на diling !!! => тестит Ледовская => 25/08/2013 накачено на боевую                      ++
---- не скроллирруется "Индекс"                                                                                                                                        ++
---- не подтягиваются в доп.соглашение поля из основной сделки поля: кредитная линия, спрэд, периодичность пересмотра ставки (набор полей), фиксация процентной ставки ++
---- после удаления основной сделки доп.соглашения не удаляются => пока не сделали, написал в на 09/08/2013, зарегистрировали замечание 47844 => 
---- исполнять не хотят, попробовать самому:                                                                                                                           ++
----- сделать связанный объект для "Депозитных сделок" "Все связ. копии сделки и доп.согл. из DocHistory" и навесить его на "Транши" на действия "Удалить" и
----- "Удалить из RN"
select classified, doctype from doctree where classified in
(select doc
 from DocHistory
 where MainDoc = 227432838/*:idObject*/ 
union
select addagreement
 from DocHistory
 where MainDoc = 227432838/*:idObject*/) 
 
 select *
 from DocHistory
 where MainDoc = 227436245
--- после запуска процедуры начисления процентов (или любого другого пересчета процентов) слетает последняя фиксация процентов => написал в НА 29/07/2013 =>
--- зарегистрировали замечание 47663 => обещают исправить 31/07/2013 => прислали deal1180.sql =>     тесты на боевой                                                ++
--- не начислялись проценты по траншам с общими счетами процентов => счета процентов нужно было сделать реестровыми                                                 ++
--- четыре проблемы от Ледовской с ручными амортизациями по траншам с плавающей ставкой (на транше с PNCB от 23/11/2007 на 15000000 USD): => написал в НА 30/07/2013 
--- => зарегистрировали замечание 47670 => 07/08/2013 согласовал исправления => обещают исправить 09/08/2013 => 08/08/2013 прислали deal1183.sql                 
--- => 09/08/2013 тесты на athena3, накатил на diling (стали затираться суммы в графике платежей после ввода доп.соглашения и пересчета процентного графика,
--- а так вроде всё работает, написал в НА, зарегистрировали замечание 47845 => 14/08/2013 прислали кучу скриптов deal1113.sql deal1121.sql deal1130.sql deal1136.sql
--- deal1138.sql deal1140.sql deal1142.sql deal1150.sql + deal1155.sql + deal1156.sql deal1176.sql deal1186.sql => 19/08/2013 накатил на diling 
--- => проверить перекрытые функции !!! => протестить !!!) => тестит Ледовская => 25/08/2013 установил на боевую                                                    ++
---- 1. при вводе ручной амортизации дата фиксации нового процентного периода остается старой, а должна меняться на дату амортизации =>                             ++
---- дата останется старой, но значения индекса затираться не будут; дату и значение индекса можно будет корректировать и затираться при пересчете они на будут => 
---- 2. нет автоматического пересчета процентов в процентном графике, если были какие-нибудь изменения в данном процентном периоде (строка красная) => 
---- будет (следует из п.1)                                                                                                                                         ++
---- 3. суммы по процентным платежам вручную не меняются (проблема не критична, если в НА решат проблему 4)  => не будет
---- 4. если изменить сумму в закладке «ПРОЦЕНТЫ» вручную, то сумма на закладке «Платежи» автоматически пересчитывается некорректно (с обратным знаком) => поправят ++            

--- проблема с некорректной закачкой праздников в Афину через swiftCCH                                                                                              ++
---- поправить LoadBICDir_HF_CCH_TCB и LoadBICDir_HS_CCH_TCB                                                                                                        ++
---- 02/08/2013 зачистить ConstHoliday, Holiday (кроме 2013 года) - по всем календарям кроме RUS                                                                    ++
---- 02/08/2013 накатить субботы и воскресенья в Holiday с RUS до 2013 года и после 2013 года - по EUR, USA, SWE                                                    ++
---- проверить 05/08/2013 после стандартной закачки 03/08/2013                                                                                                      ++
---- поправить LoadBICDir_HF_CCH_TCB и LoadBICDir_HS_CCH_TCB, чтобы insert Holiday делался только по праздникам "H", так как "W" инсерчу вручную                    ++
---- 30/08/2013 и 04/10/2013 зачистить Holiday (кроме 2013 года) - по всем календарям кроме RUS                                                                     ++
---- 30/08/2013 и 04/10/2013 накатить субботы и воскресенья в Holiday с RUS до 2013 года и после 2013 года - по EUR, USA, SWE                                       ++
---- + просила Ледовская сделать выходными 06092010 и 18022008 в USA, и 03102011 в EUR!!! 
----- SELECT * from holiday where HolidaySchema = 1200760328 -- USA
----- insert into Holiday( HolidaySchema, HolidayDate ) values( 1200760328, to_date('06092010','ddmmyyyy'));                                                        ++
----- insert into Holiday( HolidaySchema, HolidayDate ) values( 1200760328, to_date('18022008','ddmmyyyy'));                                                        ++
----- SELECT * from holiday where HolidaySchema = 1199945084 -- EUR
----- insert into Holiday( HolidaySchema, HolidayDate ) values( 1199945084, to_date('03102011','ddmmyyyy'));                                                        ++
---- проверить после стандартной закачки => 05/10/2013 загрузки не было (задачи IPI 159111 159109) => проверить 14/10/2013 закачку                                  ++

od.LoadBICDir_HF_CCH_TCB
od.LoadBICDir_HS_CCH_TCB

delete from Holiday where holidayschema != 1000131227 and (holidaydate < to_date('01.01.2013','dd.mm.yyyy') or holidaydate >= to_date('01.01.2014','dd.mm.yyyy'))

select * from Holiday where holidayschema = 1200760328

insert into holiday value (select 1200760328, holidaydate from holiday where HolidaySchema = 1000131227 and (holidaydate < to_date('01.01.2013','dd.mm.yyyy') or holidaydate >= to_date('01.01.2014','dd.mm.yyyy')) and ((to_char(holidaydate,'d')=6) or to_char(holidaydate,'d')=7));
insert into holiday value (select 1199945084, holidaydate from holiday where HolidaySchema = 1000131227 and (holidaydate < to_date('01.01.2013','dd.mm.yyyy') or holidaydate >= to_date('01.01.2014','dd.mm.yyyy')) and ((to_char(holidaydate,'d')=6) or to_char(holidaydate,'d')=7));
insert into holiday value (select 1200760270, holidaydate from holiday where HolidaySchema = 1000131227 and (holidaydate < to_date('01.01.2013','dd.mm.yyyy') or holidaydate >= to_date('01.01.2014','dd.mm.yyyy')) and ((to_char(holidaydate,'d')=6) or to_char(holidaydate,'d')=7));

create or replace procedure LoadBICDir_HF_CCH_TCB(
   siRowData in out DT.PString,           -- строка с данными 'HF'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника выходных дней
-- Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе LoadBICDir_HF)
-- Автор: Данилов О.В.
-- Версия от 20/06/2007
-- Версия: UAV (25/12/2009)
-- LoadBICDir_HF  - Процедура для закачки справочника выходных дней. Исправлены условия для выхода из обработки,
-- иначе не загружались данные.
-- Версия от 22/12/2012: Исправлено начитывание названия страны для формат с разделителем <Tab>
-- 26/12/2012 Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе LoadBICDir_HF)
-- 30/07/2013 Панфилов М.С. теперь не чистим прошлый месяц, как принято в swift, и не используем ConstHoliday
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HF'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sCountryCode   DT.Label;             -- краткий код ISO государства
   sCountryName1  DT.Description;       -- наименование государства (часть 1)
   sCountryName2  DT.Label;             -- наименование государства (часть 2)
   dtDate         date;                 -- дата праздника
   sHolidayType   DT.Label;             -- тип праздника
   sSpecInfo      DT.Text;              -- дополнительная информаци
   nCountry       DT.Reference;
   nHoliday       DT.Reference;
   nRef           DT.Reference;
   nCount         DT.Quantity;
   sDate          DT.Label;
   nDay           ConstHoliday.DayNumber%TYPE;
   nMonth         ConstHoliday.MonthNumber%TYPE;
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
 -- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sCountryCode := cut_of_string(siRowData,2);
      sCountryName1 := cut_of_string(siRowData,35);
      sCountryName2 := cut_of_string(siRowData,35);
      sCountryName1 := rtrim(rpad(sCountryName1,35)||sCountryName2);
      dtDate := TO_DATE(cut_of_string(siRowData,8),'YYYYMMDD');
      sHolidayType := cut_of_string(siRowData,1);
      sSpecInfo := cut_of_string(siRowData,320);
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryName1 := text_proc.cut_part_of_string(siRowData,null,CHR(9));
--      sCountryName2 := text_proc.cut_part_of_string(siRowData,null,CHR(9));  название только одно
      dtDate := TO_DATE(text_proc.cut_part_of_string(siRowData,null,CHR(9)),'YYYYMMDD');
      sHolidayType := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sSpecInfo := text_proc.cut_part_of_string(siRowData,null,320);
   end if;
   -- Проверяем тип записи
   if sTag != 'HF' or sTag is null or sCountryCode is null
      or dtDate < S.ysdate then
      return;
   end if;
   -- Ищем страну
   if sCountryCode = 'RU' then        -- 26/12/2012 Панфилов М.С. РФ не трогаем!!!
         return;
   end if;
   nCountry := FindObjectByCode(sCountryCode, 17);
   if nCountry is null then
      if sCountryName1 is null then
         return;
      end if;
      -- Ищем тип региона - государство
      begin
         select Classified into nRef from RegionType where Const = 1;
      exception
         when No_Data_Found then
            null;
      end;
      -- Заводим страну
      ClientRegionIns(nCountry, null, substr(sCountryName1, 1, 50), sCountryName1, null, nRef);
      nRef := null;
      BankCode_Edit(nRef, nCountry, sCountryCode, 17);
   end if;
   -- Схема выходных дней у региона
   select HolidaySch into nHoliday from ClientRegionTree where Classified = nCountry;
   if nHoliday is null then
      -- Заводим схему выходных дней
      select Classified.NextVal into nHoliday from Dual;
      insert into HolidaySchema(Classified, Label, Description)
         values(nHoliday, substr('Календарь г-ва '||sCountryName1, 1, 50),'Схема выходных дней государства '||sCountryName1);
      insert into WeekDefinition(ClientRegion, WeekBegining, MonType, TueType, WedType, ThuType, FriType, SatType, SunType)
         values( nHoliday, 1, 0, 0, 0, 0,  0, 1, 1 );
      -- Удаляем выходные дни
      delete from Holiday where HolidaySchema = nHoliday;
      -- Привязываем схему к региону
      update ClientRegionTree set HolidaySch = nHoliday where Classified = nCountry;
   end if;
   select Count(*) into nCount from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
   sDate := to_char(dtDate,'DD/MM/YYYY');
   if sFlag = 'D' then
      if nCount > 0 then
      if to_char(dtDate,'MM/YYYY') != to_char(td,'MM/YYYY') then -- 30/07/2013 Панфилов М.С. не чистим прошлый месяц, как принято в swift
         delete from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
         Eventservice.Putevent(34,'TRANS','В схеме выходных дней для г-ва '||sCountryName1||' удаляется праздник '||sDate,
                                          'Загрузка BIC/BIC+ Directory '||sysdate);
      end if;
      end if;
   elsif nCount = 0 then
      -- Добавляем праздник
      insert into Holiday( HolidaySchema, HolidayDate ) values( nHoliday, dtDate );
      if sHolidayType = 'H' then    -- только праздники, имеющие статус "обычного"
   nDay := TO_NUMBER(SUBSTR(sDate,1,2));
   nMonth := TO_NUMBER(SUBSTR(sDate,4,2));
   /*begin                                                       -- 30/07/2013 Панфилов М.С. ConstHoliday теперь не используем
    insert into ConstHoliday values(nHoliday, nMonth, nDay);
   exception
            when others then null;
   end;*/
  end if;
   end if;
end LoadBICDir_HF_CCH_TCB;
create or replace procedure LoadBICDir_HS_CCH_TCB(
   siRowData in out DT.PString,           -- строка с данными 'HF'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника выходных дней для специфических календарей (пока только EUR)
-- 26/12/2012 Панфилов М.С. для TCB для закачки CCH
-- 30/07/2013 Панфилов М.С. теперь не чистим прошлый месяц, как принято в swift, и не используем ConstHoliday
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HS'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sServiceCode   DT.Label;             -- краткий код календаря
   dtDate         date;                 -- дата праздника
   sHolidayType   DT.Label;             -- тип праздника
   sSpecInfo      DT.Text;              -- дополнительная информаци
   nCountry       DT.Reference;
   nHoliday       DT.Reference;
   nRef           DT.Reference;
   nCount         DT.Quantity;
   sDate          DT.Label;
   nDay           ConstHoliday.DayNumber%TYPE;
   nMonth         ConstHoliday.MonthNumber%TYPE;
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
 -- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sServiceCode := cut_of_string(siRowData,3);
      dtDate := TO_DATE(cut_of_string(siRowData,8),'YYYYMMDD');
      sHolidayType := cut_of_string(siRowData,1);
      sSpecInfo := cut_of_string(siRowData,320);
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sServiceCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      dtDate := TO_DATE(text_proc.cut_part_of_string(siRowData,null,CHR(9)),'YYYYMMDD');
      sHolidayType := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sSpecInfo := text_proc.cut_part_of_string(siRowData,null,320);
   end if;
   -- Проверяем тип записи
   if sTag != 'HS' or sTag is null or sServiceCode is null
      or dtDate < S.ysdate then
      return;
   end if;
   -- пока только EUR
   if sServiceCode != 'EUR' then
     return;
   end if;
   nHoliday := 1199945084;
   select Count(*) into nCount from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
   sDate := to_char(dtDate,'DD/MM/YYYY');
   if sFlag = 'D' then
   if to_char(dtDate,'MM/YYYY') != to_char(td,'MM/YYYY') then -- 30/07/2013 Панфилов М.С. не чистим прошлый месяц, как принято в swift
      if nCount > 0 then
         delete from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
         Eventservice.Putevent(34,'TRANS','В схеме выходных дней '||sServiceCode||' удаляется праздник '||sDate,
                                          'Загрузка BIC/BIC+ Directory CCH '||sysdate);
      end if;
   end if;
   elsif nCount = 0 then
      -- Добавляем праздник
      insert into Holiday( HolidaySchema, HolidayDate ) values( nHoliday, dtDate );
      if sHolidayType = 'H' then    -- только праздники, имеющие статус "обычного"
   nDay := TO_NUMBER(SUBSTR(sDate,1,2));
   nMonth := TO_NUMBER(SUBSTR(sDate,4,2));
   /*begin                                             -- 30/07/2013 Панфилов М.С. ConstHoliday теперь не используем
    insert into ConstHoliday values(nHoliday, nMonth, nDay);
   exception
            when others then null;
   end;*/
  end if;
   end if;

end LoadBICDir_HS_CCH_TCB;



  SELECT d.classified INTO v_label FROM doctree d WHERE d.classified in (select creditline from deal where doc = idDoc);
  exception when others then

    begin
    SELECT d.classified INTO v_label FROM doctree d WHERE d.classified in (select pact from deal where doc = idDoc);
    exception when others then null;
    end;
    tcb_getparlabeldoc

select* from deal where creditline = 217645254
SELECT * FROM doctree d WHERE d.classified in (select doc from deal where creditline = 217645254)


Select to_number(null), 'FIXED' from DUAL 
  Union All 
SELECT CR.Classified, CR.Label FROM  ComputeRate CR
  WHERE CR.IsPrivate = 0
        AND CR.RateType = 1 AND CR.RateCurrency = 1000001185
        AND CR.SubSystem = 1
select * from ComputeRate
select * from currency where  classified = 1000001185
----------------------------------------------------------------------------------
--24/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- select rowid, f.* from fx f where ticket = 2601164 -- НЕоткатывал по просьбе Андриянова

-- КЛ в валюте SEK, а транш в EUR (попробовать на athena3 на транше с COBA от 18/01/2013 - завести новый транш => попросить Ледовскую оттестить проводку по внеб.   +-
update deal set creditline = 224447049 where doc = 224614747 -- цепляем линию
insert into DealAccount value -- цепляем счет лимита
(select doc, 1179849838, 1000001267, 196347348, null, 0, contextvalue, startdate, enddate, null, null, null, null, null from DealAccount where doc = 224614747 and account = 201489370)


update deal set creditline = 224447049 where doc = 225297437
insert into DealAccount value -- цепляем счет лимита
(select doc, 1179849838, 1000001267, 196347348, null, 0, contextvalue, startdate, enddate, null, null, null, null, null from DealAccount where doc = 225297437 and account = 201489370)

select * from deal where creditline is not null -- doc = 224614747
select * from dealaccount where doc = 224614747
select * from dealaccount where doc = 224447049
select * from account where classified = 196347348
select * from currency 
 
od.DPC_DealDepositEvent_Limit
select * from doctree where classified = 225297191
select GetDealLimitDoc(224614747) from dual
select * from Deal where Doc = 225297437
select* from doctype where classified = 1047170421
select min(consttype) from DealType where Classified = 1179849837 --58

select -- sum(Amount) into nSum
     from DealTrAccount
    where Doc = Context.CurrentDoc
      and Account = recAccDeposit.Account

select * from genintention where classified in (1056942143,1000104503)

----------------------------------------------------------------------------------
--26/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

BBR.BBR_TCB_UNIV_RTF

select * from TCB_Univ_Report
BBR.Bbr_Tcb_Bill_Dosr_Act BBR_TCB_BILL_DOSR_ACT
BBR.BBR_TCB_BILL_EARLY_REPAYMENT

----------------------------------------------------------------------------------
--29/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.dpc_partialcommisdischarge

select * from doctree where classified = 225508414

nAccount = 
nPortfolio = 1249724406
nCurrency = 1000001275
nAccountType = 1

select PortfolioAccountNm(1249724406, 1, null, 1000001275) from dual

select * from AccIntention

select * from portfolioaccount where portfolio = 1249724406

select * from portfolioaccount where portfolio = 1033590729

-- проставил валюту RUR к счету "Средства клиентов по брокерским операциям" в привязке к портфелю ц.б. "Портфель Шестаков Сергей Васильевич" и убрал привязку к рынку ++       
update portfolioaccount set currency = 1000001275 where portfolio = 1249724406
update portfolioaccount set currency = null where portfolio = 1249724406 and classified = 1254426517


od.dpc_tcb_desc_for_diling 

\MBC\30

select DealBegProcDate2(224813879) from dual

select  DealBegProcDate(224813879) from dual

select * from deal where doc = 224813879

select * from DealSwapInterestLog where doc = 224813879

od.UT_DealAccrual_EveryDayFT_TCB
select * from DealSwapInterest where doc = 224813879
od.GetDealDepositPercent_sm


od.DPC_CREATEPERCENTACCOUNTDOC

od.UT_DealAccrual
-- нужно поправить UT_DealAccrual_EveryDayFT_TCB, чтобы было больше похоже на UT_DealAccrual                                                                       ++
od.UT_DealAccrual_EveryDayFT_TCB
od.dealdep_proc

procedure CreateDepSheduleOfPayments(
   /******************************************************************************
    Автор:    Шубин Р.
    Описание: Создать график платежей на основе графика процентов.
    Версия:   17.04.2012
              08.06.2012 AGN
              04.12.2012 - учтен расчет подробностей без округления (Зам. № 44099, AGN)
              16.01.2013
              --28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
   *****************************************************************************/
      idDoc    DT.Reference,       -- документ.
      nInit    DT.Status default 1 -- инициализация переменных
   ) as
      idPaymentLine   DT.Reference;                  --
      nAmountPay      DT.Amount;
   begin
      if nvl(nInit, 1) = 1 then
         InitVariables(idDoc);
      end if;
      -- выплаты по процентам:
      -- nSign := i.f(recDealDep.IsReceive = 1, -1, 1);
--28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
for recDSI in
         (
            select sum(P.AMOUNT) Amount, P.PayDate InterestDate, NTLCurrency,
                   P.PaymentLine
              from DealSwapInterest DSI, DealSwapPayPeriod P
             where DSI.Doc = idDoc
               and P.InterestPeriod = DSI.Classified
          group by P.PaymentLine, P.PayDate, NTLCurrency
         )
      loop
         nAmountPay :=  round(recDSI.Amount, nvl(MinorUnit(recDSI.NTLCurrency), 2));
         update DealSwapPayment
            set Amount = nAmountPay,
                Currency = recDSI.NTLCurrency,
                IsNetting = recDeal.IsNetting
          where Doc = idDoc and Classified = recDSI.PaymentLine;
         if sql%notfound then
            insert into DealSwapPayment (Doc, ValueDate, Currency, Amount,
                                          PaymentType, IsNetting, NettAmount)
               values (idDoc, recDSI.InterestDate, recDSI.NTLCurrency, nAmountPay,
                        nPaymentType_Interest, 0, null)
               returning Classified into idPaymentLine;
            update DealSwapPayPeriod
               set PaymentLine = idPaymentLine
             where PayDate = recDSI.InterestDate
               and InterestPeriod in (select Classified from DealSwapInterest
                                       where NTLCurrency = recDSI.NTLCurrency
                                         and Doc = idDoc);
         end if;
      end loop;
      -- основные суммы + амортизация.
      GeneralAmountExchange;
      -- перенумерация платежей.
      ReCalculateSheduleOfPayments(idDoc);
   end CreateDepSheduleOfPayments;
----------------------------------------------------------------------------------
--30/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from bill where num = '0362450'
select * from bill where num = '0362451'
select * from bill where num = '0362462'
select * from bill where riskgroup is not null
-- Калашникова просила проставить категории качества по векселям                                                                                               ++
--update bill set riskgroup = 1000063414 where num = '0362450'
--update bill set riskgroup = 1000063414 where num = '0362451'
--update bill set riskgroup = 1000063414 where num = '0362462'

select * from riskgroup where classified = 1000063414

  SELECT * from holiday where HolidaySchema = 1199945084 -- EUR
  SELECT * from holiday where HolidaySchema = 1000131227 -- RUS
  SELECT * from holiday where HolidaySchema = 1200760328 -- USA
  SELECT * from holiday where HolidaySchema = 1200760270 -- SWE
  
  od.SRP_LoadBicDirectory_CCH_TCB
  od.LoadBICDir_HF_CCH_TCB
  od.LoadBICDir_HS_CCH_TCB

----------------------------------------------------------------------------------
--31/07/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from accountwithreestr where account = 118323264
select * from reestr where accountwithreestr = 1254933531
select * from reestrdoc where accountwithreestr = 1254933531

select * from doctree where classified in (
226062051,
226062143,
224807407)

select case((2>3),true,2,3) from dual

select * from DealSwapPayment where doc = 224506446
select * from DealSwapPayPeriod where interestperiod = 224506446
select * from DealSwapPayPeriod where paymentline = 1252288901
select * from DealSwapInterest where doc = 224506446


select 207685*0.01723*(31/360)  from dual

select 1838.90644931*(29/173) from dual
select 1838.91*(29/173) from dual

1838.90644931 

DealDep_proc.GetIntChargeOnDate
DealSwapPayPeriod



function GetIntChargeOnDate(
   -------------------------------------------------------------------------------------------------
   -- Описание: Выдает величину процентов, которую было бы неплохо учесть на дату.
   -- Параметры:  nDoc    - сделка(транш)
   --             dtDate_ - дата
   -- Автор: А. Галкин
   -- Версия от: 28.06.2012
   --            12.07.2012 - из интервала исклювается первый день, последний день учитывается (AGN)
   --            19.07.2012 - ликвидирован outer join (Зам 41585, AGN)
   --            04.09.2012 - в середине интервала убран лишний день (Зам. № 42310, AGN)
   --            04.12.2012 - сумма формируется из неокругленных подробностей (Зам. № 44099, AGN)
   --            24.12.2012 - сумма состоит из полных перидов платежей и неокругленных сумм неполных периодов (Зам. № 44419, AGN)
   -------------------------------------------------------------------------------------------------
      nDoc       in   DT.Reference,
      dtDate_    in   Date          default nvl((Context.Operdate), s.ysdate)
   )return            DT.Amount
   is
      dtDate          Date := trunc(dtDate_);
      nIntCharge      DealSwapInterest.AccrualAmount%Type := 0; -- формируется из полных периодов платежей
      nPart           DealSwapInterest.AccrualAmount%Type := 0; -- промежуточная сумма из неполных периодов платежей
      nDaysInt        DT.ConstValue;
      nDaysAll        DT.ConstValue;
      nBase           DT.ConstValue;   -- временная база
      nCurr           DT.Reference;
      nRet            DT.Amount;
      a1              DT.Amount;
      r1              DT.Amount;
   begin
      select D.CurrencyB, case DP.InterestBase when 0 then 1 else 0 end -- валюта + меппинг базы к виду DPGeneral
        into nCurr, nBase
        from Deal D, DealDeposit DP
       where D.Doc = DP.Doc
         and D.Doc = nDoc;
      for rec in(select to_date('02.07.2013','dd.mm.yyyy') as BegChargeDate, DSPP.EndChargeDate, abs(DSPP.AccrualAmount) Amount, abs(DSP.Amount) PayAmount,
                        DSPP.PaymentLine,-- текущий платежный период
                        lead(DSPP.PaymentLine) over(order by DSPP.BegChargeDate asc) NextPayment -- следующий платежный период
                   from DealSwapPayPeriod DSPP, DealSwapPayment DSP, Doctree DCT
                  where DSPP.PaymentLine = DSP.Classified
                    and DSP.Doc = nDoc
                    and DSP.Classified = DCT.Operobj
                    and DCT.Parent = DSP.Doc
                    and DCT.Category = 905
                    and DCT.DocState not in(Constants.State_Close, Constants.State_Cancel, Constants.State_RollBack)
               order by DSPP.BegChargeDate asc
                 )
      loop
         if dtDate <= rec.BegChargeDate then   -- пришлось вынести из курсора, чтобы видеть следующий платеж
            exit; -- первый день не учитываем
         end if;
         if dtDate >= rec.EndChargeDate then  -- последний день интервала учитывается.
            -- сумма интервала целиком
            if rec.PaymentLine != rec.NextPayment then
               -- полный платеж
               nIntCharge := nIntCharge + rec.PayAmount;
               -- пред. кусочки сбрасываем
               nPart := 0;
            else
               -- копим частичные суммы платежа из полного интервала подробностей
               nPart := nPart + rec.Amount;
            end if;
         else
            -- попали внутрь интервала подробностей - считаем сумму пропорционально количеству дней с учетом базы
            nDaysInt := DpGeneral.DaysInInterval(rec.BegChargeDate, dtDate, nBase);
            nDaysAll := DpGeneral.DaysInInterval(rec.BegChargeDate, rec.EndChargeDate, nBase);
            nPart := nPart + rec.Amount*(nDaysInt/nDaysAll);
            dbms_output.put_line('EVENTS: nDaysInt='||nDaysInt||' rec.Amount='||rec.Amount||' nDaysAll='||nDaysAll);
         end if;
      end loop;
      dbms_output.put_line('EVENTS: nDaysInt='||nDaysInt||' nIntCharge='||nIntCharge||' nDaysAll='||nDaysAll);
      nIntCharge := nIntCharge + nPart;
      
      select rate+spread, ntlamount into r1, a1 from DealSwapInterest where doc = nDoc and dtDate >= startdate and dtDate <= enddate;
      
      nIntCharge := r1*a1*(31/36000);
      
      nRet := round(nIntCharge, MinorUnit(nCurr));
      return nRet;
   end GetIntChargeOnDate;
   
   
   
   
   
   
   
   
   select DSPP.BegChargeDate, DSPP.EndChargeDate, abs(DSPP.AccrualAmount) Amount, abs(DSP.Amount) PayAmount,
                        DSPP.PaymentLine,-- текущий платежный период
                        lead(DSPP.PaymentLine) over(order by DSPP.BegChargeDate asc) NextPayment -- следующий платежный период
                   from DealSwapPayPeriod DSPP, DealSwapPayment DSP, Doctree DCT
                  where DSPP.PaymentLine = DSP.Classified
                    and DSP.Doc = 224506446
                    and DSP.Classified = DCT.Operobj
                    and DCT.Parent = DSP.Doc
                    and DCT.Category = 905
                    and DCT.DocState not in(Constants.State_Close, Constants.State_Cancel, Constants.State_RollBack)

select 3103.78*(2/178) from dual
select 3103.78*(2/182) from dual

select 332936.04*0.01844*(2/360) from dual

select 30 - LEAST(to_date('29/07/2013','dd/mm/yyyy') - TRUNC(to_date('29/07/2013','dd/mm/yyyy'),'MONTH'),30)+
                  LEAST(to_date('27/01/2014','dd/mm/yyyy') - TRUNC(to_date('27/01/2014','dd/mm/yyyy'),'MONTH'),30) +
                  30*(MONTHS_BETWEEN(LAST_DAY(to_date('27/01/2014','dd/mm/yyyy')),LAST_DAY(to_date('29/07/2013','dd/mm/yyyy')))-1) from dual

select TRUNC(to_date('29/07/2013','dd/mm/yyyy'),'MONTH') from dual

select * from dealdeposit where doc = 2248074l07
select (MONTHS_BETWEEN(LAST_DAY(to_date('27/01/2014','dd/mm/yyyy')),LAST_DAY(to_date('29/07/2013','dd/mm/yyyy')))-1) from dual


-- проблемы с валютными траншами МБК 08/2013
-- нулевые события => это события под КЛ => отписать Ледовской                                                                                                 ++
-- нет счетов контрагенов в событиях по сделкам - в UT_DEALACCRUAL есть DealDep_proc.DealDepEvents, из-за этого счетов в новых событиях нет =>
-- нужно поправить UT_DealAccrual и UT_DealAccrual_EveryDayFT_TCB => тесты на athena3 02/08/2013 => накатить на боевой и отписать Ледовской                    ++
-- проблема с NostroPos => проблема похоже из-за того, что в один день и погашение процентов и амортизация => (IPI 70140) похоже нужно убрать процедуры 
-- DPC_DealNostroPos_Event_RB, DPC_DealNostroPos_Event, DPC_DealNostroRecalc, DPC_DealNP_DocTypeEvent с событий по депозитам на действии "Редактировать"       ++       
-- почему продолжаются начисления по траншу "1000", если уже была полная амортизация? => проценты начисляются в соответствии с процентным графиком, который
-- сейчас кривой. для корректного оформления досрочного завершения транша нужно: => отписать Ледовской                                                         ++
---- зайти в 27/07/2011
---- полностью удалить исполненные события в 27/07/2011
---- удалить доп. соглашение, так как оно, как я понял, никак на транш не влияет 
---- запустить операцию "Управление - Обработка - Досрочный отзыв депозита"
---- исполнить события в 27/07/2011
---- исполнить транш в 27/07/2011
-- вопрос к НА по алгоритму начисления(учета) процентов по траншам МБК на дату (с базой 360) => написал в НА 01/08/2013 => зарегистрировали вопрос 28281 =>
-- => перевели в вопрос 28342 => исправят вместе с замечанием 47670 => 08/08/2013 прислали deal1183.sql => 09/08/2013 тесты на athena3 => накатить на diling
-- => тестит Ледовская => 22/08/2013 пронал на боевой                                                                                                          ++
-- починить реестры по счетам процентов Валютных траншей МБК (список в письме от Ледовской 06/08/2013) => 08/08/2013 скрипт есть => 
-- 09/08/2013 тесты на athena3, накатил на diling => тестит Ледовская => 22/08/2013 пронал на боевой                                                           ++
-- починить реестры по счетам ОД Валютных траншей МБК                                                                                                          --
----
----------------------------------------------------------------------------------
--01/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- Калашникова просила поправить номера в Учетах, переучетах и Погашениях с начала года                                                                        ++
select rowid, d.* from doctree d where doctype in (1065659573,1065672863) and sysfilial = 4 and /*classified = 226069897 and*/ operdate > to_date('01012013','ddmmyyyy')
select rowid, b.* from billoper b where doc in(
select classified from doctree d where doctype in (1065659573,1065672863) and sysfilial = 4 and /*classified = 226069897 and*/ operdate > to_date('01012013','ddmmyyyy')
)

select rowid, d.* from doctree d where doctype in (1065660049) and sysfilial = 4 and operdate > to_date('01012013','ddmmyyyy')
select rowid, b.* from billoper b where doc in(
select classified from doctree d where doctype in (1065660049) and sysfilial = 4 and operdate > to_date('01012013','ddmmyyyy')
)

select 98000 * 0.01844 * (182/360) from dual

select * from od.nostroposdoc where doc = 226288501
select * from doctree where classified = 226288501
select * from doctype where classified = 1047170421

od.UT_DEALACCRUAL
od.dpc_dealtrans_settransacc

select Constants.GetGenIntention(933) from dual
select Constants.GetGenIntention(932) from dual

select Constants.GetGenIntention(901) from dual
select Constants.GetGenIntention(916) from dual

select * from GenIntention where classified in (1179849844,1179849844) 

select * from docstate

od.DPC_DealNostroRecalc

create or replace procedure UT_DealAccrual(
/*******************************************************************************
 Автор: Логинов Д.
 Описание:  Начисление процентов по депозитным сделкам.
            Начисление ведется для сделок в состояниях, к которым привязан экран DEALACCRUAL.
            Создаваемые внутренние переводы становятся дочерними к сделкам.
 Версия:
   06.07.2001 Расчет процентов ведется на заданную дату, а проводка делается на S.YSDATE.
   02.10.2001 Добавлена проверка на c_access.GetFilial, ограничение по датам из сделки.
   10.10.2001 В последний рабочий день месяца начисления делаются с учетом выходных.
   29.09.2004 Для EDO переделан основной запрос.
   08.02.2006 Поправлено условие отбора сделок, верно учитывается состояние документа.
   13.04.2007 Добавлен учет возможного изменения базовой процентной ставки в течение дня.
   30.05.2008 При сдвиге интервала в последний рабочий день месяца учитывается дата окончания сделки.
   06.06.2008 Не начислять проценты по сделкам, которые открыты в день, когда делается начисление.
   03.09.2008 Начисление по сделкам с датой начала = последнему рабочему дню месяца.
   21.05.2009 В зависимости от ключа начисление может осуществляться ежедневно/ежемесячно.
   05.10.2011 Добавлен запуск процедуры логирования. Добавлена блокировка.(Дор.11198, dvp)
   16.03.2012 Блокировка сделок в зависимости от значения параметра nLockMode (зам.37133, tmy).
   06.06.2011 Для депозитов до востребования вместо MaturityDate используется дата расчета (зам.40924, tmy)
   29.06.2012 (Дор. № 10561, AGN)
   05.09.2012 Исправлено вычисление последнего рабочего дня месяца (зам.42331, tmy)
   04.12.2012 для траншей МБК события пересоздаются с даты начала перерасчета %% (Зам. № 44062, AGN)
   16.01.2013 Убран пересчет платежей после расчета процентов по траншам МБК(пересчет выполняется в самом расчете %)(Зам. № 44628, AGN)
   
   01/08/2013 Панфилов М.С. затирается счет контрагента в событиях сделок траншей МБК поэтому приходится тут его восстанавливать
   
********************************************************************************/
   dtAccrualDate  date,  -- дата расчета
   nLog           DT.Status default 1,   -- вести логирование 0/1 нет/да
   nLockMode      DT.Status default 1    -- блокировать сделки перед обработкой 0/1 нет/да
) is
   dtToDate       date := trunc(dtAccrualDate);
   dtToDateTemp   date;
   nAllSum        DT.Amount;        -- общая сумма %
   nIsReceive     DT.ConstValue;
   nCurrency      DT.Reference;
   nIsLastDay     DT.Status := 0;
   dtMaturityDate date;
   nJ             DT.Quantity := 0;
   sProcLabel     dt.Description := 'UT_DealAccrual';
   sOperation     DT.Label := 'DealInterestRate';
   sDocLabel      dt.Label;
   sTextMess      dt.Description;
   sCrlf          constant DT.Label := CHR(13)||CHR(10);
   nLockStatus    DT.Status := 0;
   naDeal         DT.ClassType;
   naGenInt       DT.ClassType;
   nLockErr       DT.Status := 0;
   nGenInt932     DT.Reference := Constants.GetGenIntention(932);
   nGenInt933     DT.Reference := Constants.GetGenIntention(933);
   outtransacc901    dealtransaction.beneficiaryaccount%type;
   outtransacc916    dealtransaction.beneficiaryaccount%type;
   nGenInt901     DT.Reference := Constants.GetGenIntention(901); -- событие по процентам
   nGenInt916     DT.Reference := Constants.GetGenIntention(916); -- событие по основной сумме
   cursor curDeals is
   select DT.Classified, DT.GenIntention
     from EntityMethod EM, EntityPropValue EPV, EntityState ES, DocTree DT
    where EM.SQLNAME = 'DEALACCRUAL'
      and EPV.PropValue = EM.Classified and EPV.PropType = 1
      and EPV.EntityState = ES.Classified
      and DT.DocType = ES.EntityClass and Dt.EntityState = ES.Classified
      and DT.SysFilial = c_access.GetFilial
      and exists (select null from Deal
                   where Doc = DT.Classified
                     and ValueDate - nIsLastDay < trunc(dtAccrualDate)
                     and (dtAccrualDate <= MaturityDate or MaturityDate is null)
                     and DealDate <= (select s.ysdate from dual))
      and exists (select null from DealAccount DA, DealAccintention DAI
                   where DA.AccIntention = DAI.Classified
                     and DA.Doc = DT.Classified
                     and DAI.ConstIntention in (17, 18));
   --  разблокировка сделок
   procedure LockReleas(
      naDealIn  DT.ClassType  -- массив сделок
   ) is
   begin
      if naDealIn.count > 0 then
         for n in naDealIn.first..naDealIn.last loop
            teller_proc.lock_release(naDealIn(n));
         end loop;
      end if;
   end LockReleas;
begin
   if dtToDate is null then
      tm_proc.RaiseError(42007);
   end if;

   -- Если \Deal\Deposit\NoDailyAccrual = 1, то начисление производится только в последний день месяца.
   if Registry.GetValue('\Deal\Deposit\NoDailyAccrual') = 1 and dtToDate != PreWorkDay(last_day(dtToDate) + 1) then
      tm_proc.RaiseError(42153);
   end if;
   -- откроем LOG
   Dbl_Log('', '', 0, 3, null, sOperation, sProcLabel, nLog);
   -- в последний рабочий день месяца расширяем интервал до конца месяца
   if DPGeneral.GetIntervalValue(dtToDate, last_day(dtToDate) + 1, 2) <= 1 then
      dtToDate := last_day(dtToDate);
      nIsLastDay := 1;
   end if;
   --
   dtToDateTemp := dtToDate;
   if nLockMode = 1 then
      sTextMess :=  'Блокировка сделок. Дата расчета <'|| to_char(dtAccrualDate, 'dd.mm.yyyy hh24:mi:ss')  || ')';
      Dbl_Log(sTextMess, sTextMess, 35, 3, null, sOperation, sProcLabel, nLog);
   end if;
   for recDeals in curDeals loop
      if nLockMode = 1 then
         -- блокируем сделку
         teller_proc.doc_lock(recDeals.Classified, nLockStatus);
      end if;
      if nLockStatus = 0 then
         nJ := nJ + 1;
         naDeal(nJ) := recDeals.Classified;
         naGenInt(nJ) := recDeals.GenIntention;
      else
         nLockErr := 1;
         sTextMess := 'Не удалось заблокировать сделку ' || DocTreeLabel(recDeals.Classified)||'('||recDeals.Classified||')';
         Dbl_Log(sTextMess, sTextMess, 121, 5, recDeals.Classified, sOperation , sProcLabel, nLog);
         exit;
      end if;
   end loop;
   if nLockMode = 1 then
      Dbl_Log('Блокировка сделок.','Блокировка сделок.', 45, 3, null, sOperation, sProcLabel, nLog);
   end if;
   if nLockErr = 1 or (nLockErr = 0 and nJ = 0) then
      if nLockErr = 1 then
      -- Разблокируем сделки
         LockReleas(naDeal);
      elsif nLockErr = 0 and nJ = 0 then
         sTextMess := 'Не найдено ни одной депозитной сделки на дату <' ||dtToDate|| '>';
         Dbl_Log(sTextMess, sTextMess, 121, 3, null, sOperation, sProcLabel, nLog);
      end if;
   else
      -- сделки заблокированы
      sTextMess := '<Дата расчетов>='|| to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
                   '<Интерв расчетов>='|| to_char(dtToDate, 'dd.mm.yyyy') || sCrlf ||
                   '<Сделок>=' ||nJ;
      Dbl_Log(sTextMess, 'Сформирован  набор из ' || nJ || ' депозитных сделок на дату <' ||dtToDate|| '>',
              35, 101, null, '', sProcLabel, nLog);
      for nJ in naDeal.first..naDeal.last loop
         sTextMess := 'Обработка сделки <' ||DocTreeLabel( naDeal(nJ))||'> (' ||  naDeal(nJ) || ')';
         Dbl_Log(sTextMess, sTextMess,  35, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
         select MaturityDate into dtMaturityDate from Deal where Doc = naDeal(nJ);
         dtToDate := least(dtToDateTemp, nvl(dtMaturityDate, dtToDateTemp));
         nAllSum := null;
         if naGenInt(nJ) in (nGenInt932, nGenInt933) then
            outtransacc901 := null;                                                  -- 01/08/2013 Панфилов М.С. затирается счет контрагента в событиях сделок
            outtransacc916 := null;                                                  -- поэтому приходится тут его восстанавливать
            begin                                                                 
            select distinct d.beneficiaryaccount into outtransacc901 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = naDeal(nJ) and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt901;           
            exception when others then null;
            end;
            begin                                                                 
            select distinct d.beneficiaryaccount into outtransacc916 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = naDeal(nJ) and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt916;           
            exception when others then null;
            end;
            -- пересчет графиков и событий по сделке транша МБК
            DealDep_proc.FillDealDepInterest(naDeal(nJ));
            DealDep_proc.DealDepEvents(naDeal(nJ), dtToDate, null, 2);
            if outtransacc901 is not null then
              update dealtransaction set beneficiaryaccount = outtransacc901 where exists (select * from doctree where parent = naDeal(nJ) and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt901);
            end if;
            if outtransacc916 is not null then
              update dealtransaction set beneficiaryaccount = outtransacc916 where exists (select * from doctree where parent = naDeal(nJ) and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt916);
            end if;
         else
            -- Если изменилась базовая процентная ставка необходимо скорректировать сумму в событиях
            SetDealInterestRate(idDoc => naDeal(nJ) ,
                                nLog => nLog );
         end if;
         CreatePercentAccountDoc(nDoc => naDeal(nJ),
                                 dtDate => dtToDate ,
                                 nAllSum => nAllSum,
                                 nIsReceive => nIsReceive,
                                 nCurrency => nCurrency,
                                 dtOperDate_ => S.YSDATE,
                                 nLog => nLog);
         Dbl_Log(sTextMess, sTextMess, 45, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
      end loop;
      if nLockMode = 1 then
         -- Разблокируем сделки
         LockReleas(naDeal);
      end if;
      Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   end if;
   -- закроем LOG
   Dbl_Log('<Дата расчетов>=' || to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
           '<Сделок>=' ||nJ , '', 1, 3, null, sOperation, sProcLabel, nLog);
exception when OTHERS then
   if nLockMode = 1 then
      -- Разблокируем сделки
      LockReleas(naDeal);
   end if;
   Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   Dbl_Log('', '', 1, 3, null, sOperation, sProcLabel, nLog);
   raise;
end UT_DealAccrual;
create or replace procedure UT_DealAccrual_EveryDayFT_TCB(
/*******************************************************************************
 Автор: Панфилов М.С. 21.12.2012 (на основе UT_DealAccrual)
 Описание:  Начисление процентов по траншам МБК НЕ в последний день месяца (четко по графику начисления процентов DealSwapInterest).
            Начисление ведется для траншей МБК, по которым наступила дата выплаты процентов, в состояниях, к которым привязан экран DEALACCRUAL.


 Версия:
   06.07.2001 Расчет процентов ведется на заданную дату, а проводка делается на S.YSDATE.
   02.10.2001 Добавлена проверка на c_access.GetFilial, ограничение по датам из сделки.
   10.10.2001 В последний рабочий день месяца начисления делаются с учетом выходных.
   29.09.2004 Для EDO переделан основной запрос.
   08.02.2006 Поправлено условие отбора сделок, верно учитывается состояние документа.
   13.04.2007 Добавлен учет возможного изменения базовой процентной ставки в течение дня.
   30.05.2008 При сдвиге интервала в последний рабочий день месяца учитывается дата окончания сделки.
   06.06.2008 Не начислять проценты по сделкам, которые открыты в день, когда делается начисление.
   03.09.2008 Начисление по сделкам с датой начала = последнему рабочему дню месяца.
   21.05.2009 В зависимости от ключа начисление может осуществляться ежедневно/ежемесячно.
   05.10.2011 Добавлен запуск процедуры логирования. Добавлена блокировка.(Дор.11198, dvp)
   16.03.2012 Блокировка сделок в зависимости от значения параметра nLockMode (зам.37133, tmy).
   06.06.2011 Для депозитов до востребования вместо MaturityDate используется дата расчета (зам.40924, tmy)
   29.06.2012 (Дор. № 10561, AGN)
   05.09.2012 Исправлено вычисление последнего рабочего дня месяца (зам.42331, tmy)
   04.12.2012 для траншей МБК события пересоздаются с даты начала перерасчета %% (Зам. № 44062, AGN)
   
   01/08/2013 Панфилов М.С. затирается счет контрагента в событиях сделок траншей МБК поэтому приходится тут его восстанавливать
   
********************************************************************************/
   dtAccrualDate  date,  -- дата расчета
   nLog           DT.Status default 1,   -- вести логирование 0/1 нет/да
   nLockMode      DT.Status default 1    -- блокировать сделки перед обработкой 0/1 нет/да
) is
   dtToDate       date := trunc(dtAccrualDate);
   dtToDateTemp   date;
   nAllSum        DT.Amount;        -- общая сумма %
   nIsReceive     DT.ConstValue;
   nCurrency      DT.Reference;
   nIsLastDay     DT.Status := 0;
   dtMaturityDate date;
   nJ             DT.Quantity := 0;
   sProcLabel     dt.Description := 'UT_DealAccrual';
   sOperation     DT.Label := 'DealInterestRate';
   sDocLabel      dt.Label;
   sTextMess      dt.Description;
   sCrlf          constant DT.Label := CHR(13)||CHR(10);
   nLockStatus    DT.Status := 0;
   naDeal         DT.ClassType;
   naGenInt       DT.ClassType;
   nLockErr       DT.Status := 0;
   nGenInt932     DT.Reference := Constants.GetGenIntention(932);
   nGenInt933     DT.Reference := Constants.GetGenIntention(933);
   outtransacc901    dealtransaction.beneficiaryaccount%type;
   outtransacc916    dealtransaction.beneficiaryaccount%type;
   nGenInt901     DT.Reference := Constants.GetGenIntention(901); -- событие по процентам
   nGenInt916     DT.Reference := Constants.GetGenIntention(916); -- событие по основной сумме

   flag           DT.Status := 0; -- в графике начисления процентов по сделке есть дата расчета

   cursor curDeals is
   select DT.Classified, DT.GenIntention
     from EntityMethod EM, EntityPropValue EPV, EntityState ES, DocTree DT
    where EM.SQLNAME = 'DEALACCRUAL'
      and EPV.PropValue = EM.Classified and EPV.PropType = 1
      and EPV.EntityState = ES.Classified
      and DT.DocType = ES.EntityClass and Dt.EntityState = ES.Classified
      and DT.SysFilial = 1
      and exists (select null from Deal d, DealDeposit dd
                   where d.Doc = DT.Classified
                     and d.ValueDate - nIsLastDay < trunc(dtAccrualDate)
                     and (sysdate <= d.MaturityDate or d.MaturityDate is null)
                     and d.DealDate <= (select s.ysdate from dual)
                     and dd.doc = d.doc and dd.istransh = 1)                    -- 21/12/2012 Панфилов М.С. - тут смотрим только транши МБК
      and exists (select null from DealSwapPayment DSP, Doctree DCT             -- 21/12/2012 Панфилов М.С. - тут смотрим только те сделки, у которых есть "созданные" события по процентам на даты <= дата расчета
                   where DSP.Doc = DT.Classified
                     and DSP.Classified = DCT.OperObj
                     and DCT.Parent = DSP.Doc
                     and DSP.VALUEDATE <= trunc(dtAccrualDate)
                     and DSP.Paymenttype = 0
                     and DCT.DocState = Constants.State_Open)
      and exists (select null from DealAccount DA, DealAccintention DAI
                   where DA.AccIntention = DAI.Classified
                     and DA.Doc = DT.Classified
                     and DAI.ConstIntention in (17, 18))
                     ;
   --  разблокировка сделок
   procedure LockReleas(
      naDealIn  DT.ClassType  -- массив сделок
   ) is
   begin
      if naDealIn.count > 0 then
         for n in naDealIn.first..naDealIn.last loop
            teller_proc.lock_release(naDealIn(n));
         end loop;
      end if;
   end LockReleas;
begin
   if dtToDate is null then
      tm_proc.RaiseError(42007);
   end if;

   -- начисление производится только НЕ в последний день месяца.
   /*if Registry.GetValue('\Deal\Deposit\NoDailyAccrual') = 1 and dtToDate != PreWorkDay(last_day(dtToDate) + 1) then
      tm_proc.RaiseError(42153);
   end if;*/
   -- откроем LOG
   Dbl_Log('', '', 0, 3, null, sOperation, sProcLabel, nLog);
   -- в последний рабочий день месяца расширяем интервал до конца месяца
   if DPGeneral.GetIntervalValue(dtToDate, last_day(dtToDate) + 1, 2) <= 1 then
      dtToDate := last_day(dtToDate);
      nIsLastDay := 1;
   end if;
   --
   dtToDateTemp := dtToDate;
   if nLockMode = 1 then
      sTextMess :=  'Блокировка сделок. Дата расчета <'|| to_char(dtAccrualDate, 'dd.mm.yyyy hh24:mi:ss')  || ')';
      Dbl_Log(sTextMess, sTextMess, 35, 3, null, sOperation, sProcLabel, nLog);
   end if;
   for recDeals in curDeals loop
      if nLockMode = 1 then
         -- блокируем сделку
         teller_proc.doc_lock(recDeals.Classified, nLockStatus);
      end if;
      if nLockStatus = 0 then
         nJ := nJ + 1;
         naDeal(nJ) := recDeals.Classified;
         naGenInt(nJ) := recDeals.GenIntention;
      else
         nLockErr := 1;
         sTextMess := 'Не удалось заблокировать сделку ' || DocTreeLabel(recDeals.Classified)||'('||recDeals.Classified||')';
         Dbl_Log(sTextMess, sTextMess, 121, 5, recDeals.Classified, sOperation , sProcLabel, nLog);
         exit;
      end if;
   end loop;
   if nLockMode = 1 then
      Dbl_Log('Блокировка сделок.','Блокировка сделок.', 45, 3, null, sOperation, sProcLabel, nLog);
   end if;
   if nLockErr = 1 or (nLockErr = 0 and nJ = 0) then
      if nLockErr = 1 then
      -- Разблокируем сделки
         LockReleas(naDeal);
      elsif nLockErr = 0 and nJ = 0 then
         sTextMess := 'Не найдено ни одного транша МБК на дату <' ||dtToDate|| '>';
         Dbl_Log(sTextMess, sTextMess, 121, 3, null, sOperation, sProcLabel, nLog);
      end if;
   else
      -- сделки заблокированы
      sTextMess := '<Дата расчетов>='|| to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
                   '<Интерв расчетов>='|| to_char(dtToDate, 'dd.mm.yyyy') || sCrlf ||
                   '<траншей МБК>=' ||nJ;
      Dbl_Log(sTextMess, 'Сформирован  набор из ' || nJ || ' траншей МБК на дату <' ||dtToDate|| '>',
              35, 101, null, '', sProcLabel, nLog);
      for nJ in naDeal.first..naDeal.last loop
         flag := 0;
         sTextMess := 'Обработка транша МБК <' ||DocTreeLabel( naDeal(nJ))||'> (' ||  naDeal(nJ) || ')';
         Dbl_Log(sTextMess, sTextMess,  35, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
         select MaturityDate into dtMaturityDate from Deal where Doc = naDeal(nJ);
         dtToDate := least(dtToDateTemp, nvl(dtMaturityDate, dtToDateTemp));
         nAllSum := null;
         if naGenInt(nJ) in (nGenInt932, nGenInt933) then
            outtransacc901 := null;                                                  -- 01/08/2013 Панфилов М.С. затирается счет контрагента в событиях сделок
            outtransacc916 := null;                                                  -- поэтому приходится тут его восстанавливать
            begin                                                                 
            select distinct d.beneficiaryaccount into outtransacc901 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = naDeal(nJ) and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt901;           
            exception when others then null;
            end;
            begin                                                                 
            select distinct d.beneficiaryaccount into outtransacc916 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = naDeal(nJ) and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt916;           
            exception when others then null;
            end;
            -- пересчет графиков и событий по сделке транша МБК
            DealDep_proc.FillDealDepInterest(naDeal(nJ));
            FillDealDepPaymentForSave(naDeal(nJ));                              -- 29/07/2013 Панфилов М.С. чтобы было как в UT_DealAccrual
            DealDep_proc.DealDepEvents(naDeal(nJ), dtToDate, null, 2);
            if outtransacc901 is not null then
              update dealtransaction set beneficiaryaccount = outtransacc901 where exists (select * from doctree where parent = naDeal(nJ) and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt901);
            end if;
            if outtransacc916 is not null then
              update dealtransaction set beneficiaryaccount = outtransacc916 where exists (select * from doctree where parent = naDeal(nJ) and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt916);
            end if;
         else
            -- Если изменилась базовая процентная ставка необходимо скорректировать сумму в событиях
            SetDealInterestRate(idDoc => naDeal(nJ) ,
                                nLog => nLog );
         end if;

         select count(classified) into flag from DealSwapInterest where doc = naDeal(nJ) and enddate = dtToDate; -- ищем в графике начисления процентов дату расчета

         if dtToDate != PreWorkDay(last_day(dtToDate) + 1) and flag != 0 then -- 21/12/2012 Панфилов М.С. - начисление производится только НЕ в последний день месяца
         CreatePercentAccountDoc(nDoc => naDeal(nJ),                          -- (в последний день месяца для начисления процентов сначала нужно запускать od.UT_DealAccrual)
                                 dtDate => dtToDate ,
                                 nAllSum => nAllSum,
                                 nIsReceive => nIsReceive,
                                 nCurrency => nCurrency,
                                 dtOperDate_ => S.YSDATE,
                                 nLog => nLog);

         end if;
         -- толкаем события траншей МБК с ValueDate <= текущей
         for rec in (select DCT.* from DealSwapPayment DSP, Doctree DCT             -- 21/12/2012 Панфилов М.С. - тут смотрим только "созданные" события по процентам на даты <= дата расчета
                   where DSP.Doc = naDeal(nJ)
                     and DSP.Classified = DCT.OperObj
                     and DCT.Parent = DSP.Doc
                     and DSP.VALUEDATE <= trunc(dtAccrualDate)
                     and DSP.Paymenttype = 0
                     and DCT.DocState = Constants.State_Open)
         loop
           od.docprocessforchild(rec.classified,S.YSDATE,1,Constants.State_Start,false); -- 27/03/2013 Панфилов М.С. - добавлен пятый параметр = false, чтобы можно было обрабатывать чужие события
         end loop;

         Dbl_Log(sTextMess, sTextMess, 45, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
      end loop;
      if nLockMode = 1 then
         -- Разблокируем сделки
         LockReleas(naDeal);
      end if;
      Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   end if;
   -- закроем LOG
   Dbl_Log('<Дата расчетов>=' || to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
           '<траншей МБК>=' ||nJ , '', 1, 3, null, sOperation, sProcLabel, nLog);
exception when OTHERS then
   if nLockMode = 1 then
      -- Разблокируем сделки
      LockReleas(naDeal);
   end if;
   Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   Dbl_Log('', '', 1, 3, null, sOperation, sProcLabel, nLog);
   raise;
end UT_DealAccrual_EveryDayFT_TCB;


----------------------------------------------------------------------------------
--02/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select td + 547 from dual

select distinct d.beneficiaryaccount /*into outtransacc*/ from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = 225332285 and d.beneficiaryaccount is not null and dt.docstate = 1000000034 -- Constants.State_Open;
 

od.SPEC_DealDeposit_AdvRepay

-- правил FUNC_BILL_ACCRUALADD_TCB для Калашниковой (дописал abs) - вылазили ошибки из-за некачественных тестов по задаче 130215                                    ++ 
od.FUNC_BILL_ACCRUALADD_TCB

----------------------------------------------------------------------------------
--05/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select 100000000*0.0675*(4/365) from dual
select * from doctree where classified = 222068316

bbr.BBR_DOC_SWIFT

select * from balance where account = 141314068 -- = 338019,51 (по Ледовской 338019,50)
select * from balance where account = 217464748 -- = 468081,95 (по Ледовской 468912,50)
select * from balance where account = 174250758 -- =  30710,81
select * from balance where account = 54798351  -- =  72834,56
select * from balance where account = 109041489 -- =   1810,66 (по Ледовской 1810,67)
select * from balance where account = 118323264 -- =     39,06
select * from balance where account = 174674393 -- =   2490,48 (по Ледовской 2490,47)
select * from balance where account = 201489512 -- =  10617,64 
select * from balance where account = 214300042 -- = 200750,88 (по Ледовской 200750,87)
 
 
select * from account where code = '31407978900000000092'
select * from od.accountwithreestr where account = 217464583
select * from reestr where accountwithreestr = 1252609069
select * from reestrdoc where accountwithreestr = 1252609069
select * from 31407978900000000092    

select od.reestrrestout((
    select doc from reestrdoc rd where initdoc in
    (
    select 224679515/*nDealID*/ from dual
    ) and doc in (select * from dealaccount where account = (select classified from account where code = '47426978150000100092')))
    , td) from dual
    
    select od.reestrrestout((select rsaccount from dealaccount where doc = 224679515/*nDealID*/ and 
                             account = (select classified from account where code = '31407978900000000092'))
                            , td) from dual
 
select * from dealaccount where doc = 226620099  
select * from doctree where classified in (224822870,224822875)  

select * from doctype where classified = 1000135223
select * from account where classified = 36422712

    select od.reestrrestout((select rsaccount from dealaccount where doc = 226620099/*nDealID*/ and 
                             account = (select classified from account where code = '31304810300000000918'))
                            , td-4) from dual

select od.reestrrestout((select rsaccount
                          from dealaccount
                         where doc = 223712953 /*nDealID*/
                           and account =
                               (select classified
                                  from account
                                 where code = '31307810800000001029')),
                        td-23)
  from dual
  
select * from doctree where classified = 226180360 
select * from doctype where classified = 1000135409

select * from account where code = '31307810800000001029'
select * from od.accountwithreestr where account = 223447907
select * from reestr where accountwithreestr = 1249968958
select * from reestrdoc where accountwithreestr = 1249968958

select * from account where code = '31302810100000002626'
select * from od.accountwithreestr where account = 126861
select * from reestr where accountwithreestr = 1116805212
select * from reestrdoc where accountwithreestr = 1116805212

select * from dealaccount where doc = 223712953 
select * from doctree where classified = 223691571
select * from doctype where classified = 1000161094

select * from DealSwapPayment where doc = 224660711
select * from DealSwapInterest where doc = 226133843
select * from DealSwapPayPeriod where interestperiod = 1256292944

select 70270.5*(142/266) from dual
select 30710.81 - 32757.68 from dual

select 10455.43 - 15857.4*(129/182) from dual
select 397.6 -  183.71 from dual

select DealDep_proc.GetIntChargeOnDate(226133843,td) from dual
select
30 - LEAST(to_date('02042013','ddmmyyyy') - TRUNC(to_date('02042013','ddmmyyyy'),'MONTH'),30)+
                  LEAST(to_date('01102013','ddmmyyyy') - TRUNC(to_date('01102013','ddmmyyyy'),'MONTH'),30) +
                  30*(MONTHS_BETWEEN(LAST_DAY(to_date('01102013','ddmmyyyy')),LAST_DAY(to_date('02042013','ddmmyyyy')))-1) from dual
                  
                  
select
to_date('01102013','ddmmyyyy') - to_date('02042013','ddmmyyyy'), to_date('09082013','ddmmyyyy') - to_date('02042013','ddmmyyyy') from dual

----------------------------------------------------------------------------------
-- чиним реестры по счетам проц. Валютных траншей МБК => 09/08/2013 тесты на athena3, накатил на diling => тестит Ледовская => 22/08/2013 прогнал на боевой         ++
----------------------------------------------------------------------------------
select * from account where code = '47426978150000003461'
select * from od.accountwithreestr where account = 120505648
select * from reestr where accountwithreestr = 1119929282
select * from reestrdoc where accountwithreestr = 1119929282
select * from doctree where classified in (226664223,226664239)
select * from doctree where classified in (226656100,226656096)
select * from doctype where classified in (1047492427,1047624989)

select * from account where code = '31302978400000003461'
select * from od.accountwithreestr where account = 107932427
select * from reestr where accountwithreestr = 1116805780
select * from reestrdoc where accountwithreestr = 1116805780
select * from doctree where classified in (226508600,226664231)
select * from doctree where classified in (226502888,226656099)
select * from doctype where classified in (1000161029,1047624989)

select * from doctree where classified = 115997230
select * from doctype where classified = 1047124628

-- ЕБРР
select * from account where code = '47426840300000100093'
select * from od.accountwithreestr where account = 144976839
select * from reestr where accountwithreestr = 1252214617
select * from reestrdoc where accountwithreestr = 1252214617

select * from account where code = '47426840900001000084'
select * from od.accountwithreestr where account = 75286590
select * from reestr where accountwithreestr = 1268216442
select * from reestrdoc where accountwithreestr = 1268216442

select * from account where code = '47426840700001002143'
select * from od.accountwithreestr where account = 217903119
select * from reestr where accountwithreestr = 1252217790
select * from reestrdoc where accountwithreestr = 1252217790

select * from account where code = '47426978950001001743'
select * from od.accountwithreestr where account = 169603586
select * from reestr where accountwithreestr = 1252213870
select * from reestrdoc where accountwithreestr = 1252213870


select * from account where code = '47426840000000100092'
select * from od.accountwithreestr where account = 141314068
select * from reestr where accountwithreestr = 1252214949
select * from reestrdoc where accountwithreestr = 1252214949

--++++
update reestr set docsum = 338019.51 where reestrinit = 224661326 and docsum != 0 and accountwithreestr = 1252214949;         -- изменяем сумму в занесении на реестр 31/07
delete reestr where reestrinit != 224661326 and accountwithreestr = 1252214949;                                               -- удаляем большое занесение на реестр 
update reestrdoc set docsum = 338019.51 where doc = 226349260 and accountwithreestr = 1252214949;                             -- изменяем сумму в занесении на реестр 31/07
delete reestrdoc where doc = 224493058 and accountwithreestr = 1252214949;                                                    -- удаляем большое занесение на реестр 

update reestrdoc set docsum = -453142.08 where docsum = 453142.08 and accountwithreestr = 1252214949;  

select * from doctree where classified = 232513371
select * from doctree where classified = 232463631
select * from doctree where classified = 230552499
select * from doctype where classified = 1000135307

select * from account where code = '47426978150000100092'
select * from od.accountwithreestr where account = 217464748
select * from reestr where accountwithreestr = 1252211233
select * from reestrdoc where accountwithreestr = 1252211233

--++++
update reestr set docsum = 468081.95 where reestrinit = 224822875 and docsum != 0 and accountwithreestr = 1252211233;         -- изменяем сумму в занесении на реестр 31/07
delete reestr where reestrinit != 224822875 and accountwithreestr = 1252211233;                                               -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 468081.95 where doc = 226349344 and accountwithreestr = 1252211233;                             -- изменяем сумму в занесении на реестр 31/07
delete reestrdoc where doc in (224491069,224680471,225541513) and accountwithreestr = 1252211233;                             -- удаляем лишние занесения на реестр 

select * from account where code = '47426840150000000097'
select * from od.accountwithreestr where account = 174250758
select * from reestr where accountwithreestr = 1252214444
select * from reestrdoc where accountwithreestr = 1252214444

--++++
update reestr set docsum = 30710.81 where reestrinit = 226133871 and docsum != 0 and accountwithreestr = 1252214444;          -- изменяем сумму в занесении на реестр 31/07
delete reestr where reestrinit != 226133871 and accountwithreestr = 1252214444;                                               -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 30710.81 where doc = 226349227 and accountwithreestr = 1252214444;                              -- изменяем сумму в занесении на реестр 31/07
delete reestrdoc where doc in (224492782) and accountwithreestr = 1252214444;                                                 -- удаляем лишние занесения на реестр

select * from account where code = '47426752100001000082'
select * from od.accountwithreestr where account = 54798351
select * from reestr where accountwithreestr = 1255432406
select * from reestrdoc where accountwithreestr = 1255432406

--++++
update reestr set docsum = 13363.00 where reestrinit = 226024748 and docsum != 0 and accountwithreestr = 1255432406;          -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 13363.00 where reestrinit = 226024747 and docsum != 0 and accountwithreestr = 1255432406;          -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 10455.43 where reestrinit = 226024759 and docsum != 0 and accountwithreestr = 1255432406;          -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 35653.13 where reestrinit = 226024760 and docsum != 0 and accountwithreestr = 1255432406;          -- изменяем сумму в занесении на реестр 31/07
delete reestr where reestrinit = 225998604 and accountwithreestr = 1255432406;                                                -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 13363.00 where doc = 226349238 and accountwithreestr = 1255432406;                              -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 13363.00 where doc = 226349248 and accountwithreestr = 1255432406;                              -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 10455.43 where doc = 226349245 and accountwithreestr = 1255432406;                              -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 35653.13 where doc = 226349242 and accountwithreestr = 1255432406;                              -- изменяем сумму в занесении на реестр 31/07
delete reestrdoc where doc in (225998604) and accountwithreestr = 1255432406;                                                 -- удаляем лишние занесения на реестр

select * from account where code = '47426978800001000085'
select * from od.accountwithreestr where account = 109041489
select * from reestr where accountwithreestr = 1252212047
select * from reestrdoc where accountwithreestr = 1252212047

--++++ (по счету 47426978800001000085 остался ещё один транш, который ещё в Афину не завели)
update reestr set docsum = 460.22 where reestrinit = 226024752 and docsum != 0 and accountwithreestr = 1252212047;            -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 165.53 where reestrinit = 225472292 and docsum != 0 and accountwithreestr = 1252212047;            -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 1184.91 where reestrinit = 226180366 and docsum != 0 and accountwithreestr = 1252212047;           -- изменяем сумму в занесении на реестр 31/07
delete reestr where reestrinit in (224491426,225540266,225540068) and accountwithreestr = 1252212047;                         -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 460.22 where doc = 226349251 and accountwithreestr = 1252212047;                                -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 165.53 where doc = 226349267 and accountwithreestr = 1252212047;                                -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 1184.91 where doc = 226180366 and accountwithreestr = 1252212047;                               -- изменяем сумму в занесении на реестр 31/07
delete reestrdoc where doc in (224491426,225540266,225540068,226024751,224880368) and accountwithreestr = 1252212047;         -- удаляем лишние занесения на реестр

--++++ (тут всё итак ОК)
select * from account where code = '47426978150000000901'
select * from od.accountwithreestr where account = 118323264
select * from reestr where accountwithreestr = 1254933531
select * from reestrdoc where accountwithreestr = 1254933531

select * from account where code = '47426978150000000095'
select * from od.accountwithreestr where account = 174674393
select * from reestr where accountwithreestr = 1255933504
select * from reestrdoc where accountwithreestr = 1255933504

select * from doctree where classified = 230455652
select * from doctype where classified = 1047492427

234623825

230552418

--++++
update reestr set docsum = 397.60 where reestrinit = 226287276 and docsum != 0 and accountwithreestr = 1255933504;            -- изменяем сумму в занесении на реестр 31/07
--update reestr set reestrinit = 234623825 where reestrinit = 230552418 and docsum != 0 and accountwithreestr = 1255933504; 

update reestr set docsum = 697.63 where reestrinit = 226290961 and docsum != 0 and accountwithreestr = 1255933504;            -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 1395.25 where reestrinit = 226289468 and docsum != 0 and accountwithreestr = 1255933504;           -- изменяем сумму в занесении на реестр 31/07
delete reestr where reestrinit = 226196333 and accountwithreestr = 1255933504;                                                -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 397.60 where doc = 226349280 and accountwithreestr = 1255933504;                                -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 397.60 where doc = 226349280 and accountwithreestr = 1255933504;
--update reestrdoc set doc = 234623825, classified = 234623825,   where doc = 226349280 and accountwithreestr = 1255933504;

update reestrdoc set docsum = 697.63 where doc = 226349286 and accountwithreestr = 1255933504;                                -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 1395.25 where doc = 226349290 and accountwithreestr = 1255933504;                               -- изменяем сумму в занесении на реестр 31/07
delete reestrdoc where doc in (226196333) and accountwithreestr = 1255933504;                                                 -- удаляем лишние занесения на реестр

--++++ (тут всё итак ОК)
select * from account where code = '47426978750197010097'
select * from od.accountwithreestr where account = 201489512
select * from reestr where accountwithreestr = 1255442440
select * from reestrdoc where accountwithreestr = 1255442440

select * from account where code = '47426840650000100086'
select * from od.accountwithreestr where account = 214300042
select * from reestr where accountwithreestr = 1252215611
select * from reestrdoc where accountwithreestr = 1252215611

--++++
update reestr set docsum = 3165.32 where reestrinit = 225472289 and docsum != 0 and docsum = 3156.32 and accountwithreestr = 1252215611;            -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 4698.52 where reestrinit = 225472289 and docsum != 0 and docsum = 4689.52 and accountwithreestr = 1252215611;   

update reestr set docsum = 23216.55 where reestrinit = 224549256 and docsum != 0 and accountwithreestr = 1252215611;           -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 14649.82 where reestrinit = 225472288 and docsum != 0 and accountwithreestr = 1252215611;           -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 23956.22 where reestrinit = 225472290 and docsum != 0 and accountwithreestr = 1252215611;           -- изменяем сумму в занесении на реестр 31/07
update reestr set docsum = 133440.00 where reestrinit = 225472291 and docsum != 0 and accountwithreestr = 1252215611;          -- изменяем сумму в занесении на реестр 31/07
delete reestr where reestrinit in (224493377,224545608,225540897,225541191,225541144,225540983/*,227987172*/) and accountwithreestr = 1252215611; -- удаляем лишние занесения на реестр 

update reestrdoc set docsum = 3165.32 where doc = 226349301 and accountwithreestr = 1252215611;                                 -- изменяем сумму в занесении на реестр 31/07
 
update reestrdoc set docsum = 23216.55 where doc = 226349314 and accountwithreestr = 1252215611;                                -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 14649.82 where doc = 226349298 and accountwithreestr = 1252215611;                                -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 23956.22 where doc = 226349307 and accountwithreestr = 1252215611;                                -- изменяем сумму в занесении на реестр 31/07
update reestrdoc set docsum = 133440.00 where doc = 226349311 and accountwithreestr = 1252215611;                               -- изменяем сумму в занесении на реестр 31/07
delete reestrdoc where doc in (224493377,224545608,225540897,225541191,225541144,225540983/*,227987172*/) and accountwithreestr = 1252215611; -- удаляем лишние занесения на реестр

select * from doctree where classified in (227691106,224549226)
select * from doctype where classified = 1179850206
224549226
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--06/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from account where code = '47427810450000002546'
select * from od.accountwithreestr where account = 118018912
select * from reestr where accountwithreestr = 1116567498
select * from reestrdoc where accountwithreestr = 1116567498

select DealDep_proc.GetIntChargeOnDate(224660711, td+1) from dual
select DealDep_proc.GetIntChargeOnDate(224679515, td) from dual
select 811293.06*((1+30+31)/(1+90+16)) from dual
select (811293.06*((1+60+6)/(1+90+16))) from dual

select od.reestrrestout(224679515,td) from dual
select od.reestrinfo (parentdoc(224679515),td) from dual
select parentdoc(classified) from doctree where classified = 224822875
select * from doctree where classified = 224679515
select * from doctype where classified = 1179850206
  
select * from doctree where classified = 223712953


od.dpc_dealdeposit_reservoff_tcb
----------------------------------------------------------------------------------
--07/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проблема у Бакумцевой - задвоилось снятие резерва из-за неправильного назначения генерации в "событии по процентам" (Бакумцева призналась, что разделяла 
-- событие на ОД и процентов после того как они сгенерились) => поправить dpc_dealdeposit_reservoff_tcb, чтобы, если событие уже есть, то больше бы не генерились  ++
-- вопрос у Ледовской по счету ODINBANKа 313078108*1029: почему он открылся с таким хвостом? ведь должен быть хвост = рег.номер => ответ:
-- в Афине два ОДИНБАНКА, один с правильным Reuters, другой с правильным рег.номером => должен быть только один.                                                   ++
-- после обновления 18/08/2013
-- возникла проблема с открытием формы счета 313078108*1029 на боевой базе (DPC_READACCOUNT) => написали в НА => прислали Ромику скрипт                            ++
-- проблемы с бланком соглашения по векселям у Филимоновой (соглашение о покупке векселей) и Епановой (протокол досрочного погашения)                              ++
---- для Филимоновой: поправить 4 BBR (BBR_TCB_BILL_BUY_AGR*) и 4 шаблона .rtf в T:\BBRWORD\TMP => тестят                                                          ++
---- для Епановой: поправить 2 BBR (BBR_TCB_BILL_EARLY_REPAYMENT*) и 2 шаблона .rtf в T:\BBRWORD\TMP => тестят                                                     ++
bbr.BBR_TCB_BILL_BUY_AGREEMENTPROC

bbr.BBR_TCB_BILL_SOGL_BUY

bbr.BBR_TCB_BILL_DOSR_ACT 

bbr.BBR_TCB_BILL_EARLY_REPAYMENT
bbr.BBR_TCB_BILL_EARLY_REPAYMENT_D

select * --LineValue 
  --into sCity 
  from QuestValue 
 where LineCode = 1000062190 
   and Client in (1,23644)
   and RowNum <= 1
   
select * from filial
select * from doctree
select * from preference

select c.label, ClientAnyAddress(c.doc,'AddressJur',s.ysdate), od.GetClientCode(c.doc,20), od.GetClientCode(c.doc,25)
into sOrganization, sClientAddress, sClientINN, sClientKPP
from client c, billoper bo
where bo.doc = nDoc and c.doc = bo.client;


begin
 select b.BeneficiaryAccount, od.GetClientCode(b.BeneficiaryBank,7), c.Label, r.Code
 into sAccCli, sBikCli, sBankCli, sKsCli
  from BillOperBenef b, Client c, ClBankRel r where r.Relation = 1000002508 and r.ClBank = b.BeneficiaryBank
   and c.Doc = b.BeneficiaryBank and b.Doc = nDoc;
exception when OTHERS then
 begin
  select a.Code into sAccCli from account a, billoper bo
  where nvl(a.Opened,to_date('01/01/1998','DD/MM/YYYY')) <= nDate
   and nvl(a.Closed,to_date('01/01/4444','DD/MM/YYYY')) > nDate
   and a.Type = 1000002445 and a.Client = bo.client and bo.doc = nDoc and ROWNUM <= 1;
  sKsCli := sBankNostroAcc;
  sBikCli := sBik;
  sBankCli := sBankLabel;
 exception when OTHERS then
  begin
   select c.Code, od.GetClientCode(c.CorrClBank,7), ClientLabel(c.CorrClBank), r.Code
    into sAccCli, sBikCli, sBankCli, sKsCli from ClBankRel c, billoper bo, ClBankRel r
    where r.Relation = 1000002508 and r.ClBank = c.CorrClBank
     and nvl(c.OpenDate,to_date('01/01/1998','DD/MM/YYYY')) <= nDate
     and nvl(c.CloseDate,to_date('01/01/4444','DD/MM/YYYY')) > nDate
 and c.Relation = 1000002445 and c.ClBank = bo.client and bo.doc = nDoc and ROWNUM <= 1;
     exception when OTHERS then
      sAccCli := '';
      sKsCli := '';
      sBikCli := '';
      sBankCli := '';
     end;
    end;
   end;


-- квитовать "переводы из другого банка (руб)" с плановыми (тесты на diling)                                                                                       +--
---- есть проблема с автоматической квитовкой после удаления/восстановления "Перевод из другого банка (руб)"                                                       ???
---- не работает квитовка от "Переводов из другого банка (руб)" (потому что у покрытий бывает не верный SectionFlag, нужна первая A) => можно поправить =>
---- написать update SectionFlag и навесить её первой строкой на действие "Открыть" на "Перевод из другого банка (руб)" с условием "счет кредита из Дилинга"       +--
---- написать условие "счет кредита из Дилинга"                                                                                                                    +--
---- чтобы автоматическая квитовка работала на документах в статусе "Принят" надо привязать к экрану frmQuittPlan состояния "Принят"
---- для "Переводов из другого банка (руб)"                                                                                                                        +--
---- нужно написать dpc_nostro_AutoQuitDocs_tcb и навесить её на операцию "Исполнить" на "Руб. плановые поступления Дилинг"  с параметром nQuitType = 1 и
---- с условием "счет кредита из Дилинга" перед DPC_ChkCoverExists                                                                                                 +--
---- нужно написать dpc_nostro_AutoQuitDocs_tcb и навесить её на операцию "Исполнить" на "Перевод из другого банка (руб)" с параметром nQuitType = 2 и
---- с условием "счет кредита из Дилинга" перед DPC_MO_PaymentOrder                                                                                                +--
---- написать процедуру DPC_CHECK_QUIT_DILING_TCB, которая бы не позволяла исполнять несквитованные документы и навесить её после dpc_nostro_AutoQuitDocs_tcb   
---- на "Перевод из другого банка (руб)" с параметром nQuitType = 2 и с условием "счет кредита из Дилинга",
---- и на "Руб. плановые поступления Дилинг" с параметром nQuitType = 1 и с условием "счет кредита из Дилинга"                                                     +--
---- тесты на athena3, поставить на diling, отписать Ледовской                                                                                                     +++
---- поставить на боевую                                                                                                                                           ---

declare
   accInDeal   number;
begin
   select count(classified) into accInDeal from bankoper where doc = context.CurrentDoc and account in (select account from dealaccount) and 
   account in (select account from dealaccount);
  if accInDeal > 0 then
    :nCondResult := 1;
  else
    :nCondResult := 0;
  end if;
exception when OTHERS then
    :nCondResult := 0;
end;

update CustomerIso set SectionFlag = 'A' || substr(SectionFlag,2,3) where doc = message.idobject /*15/08/2013 Панфилов М.С.*/

CREATE OR REPLACE 
PROCEDURE DPC_CHECK_QUIT_DILING_TCB(
-- проверка сквитованности дилингового документа 
-- 14/08/2013 Панфилов М.С.
nQuitType            dt.Reference          -- тип квитовки
)AS
begin
  if Nostro_Quit.IsQuitDoc(nQuitType,context.CurrentDoc) = 0 then
       raise_application_error(-20000,'Документ не сквитован!!! Исполнять его нельзя!!!');
  end if;
end DPC_CHECK_QUIT_DILING_TCB;

CREATE OR REPLACE 
PROCEDURE dpc_nostro_AutoQuitDocs_tcb(
-- 14/08/2013 Панфилов М.С. Процедура для запуска автоматической квитовки по документу
nQuitType            dt.Reference          -- тип квитовки
)IS
res     DT.StatusType;
currdoc DT.ClassType;
begin
res(0) := 1;
currdoc(0) := Message.idObject;
Nostro_Quit.AutoQuitDocs( nQuitType, currdoc, res, trunc(s.ysdate) - 1, trunc(s.ysdate) + 1 -(1/86400));
exception when others then null;
end dpc_nostro_AutoQuitDocs_tcb;



select * from CustomerIso where doc = 227783635
select FindObjectByCode('040349715',1000004994) from dual
select * from CodeSystem where classified = 1000004994
select BNK_GetPayBank52D(CI.BeneficiaryBankName) from dual


select * from doctree where classified =  227980173
select distinct (select label from dealaccintention where classified = da.accintention) /*distinct acccode(account)*/ from dealaccount da
select * from accountwithreestr
od.accountw
select * from quittype
od.DPC_ChangeDocStateForDocV_tcb
select * from doccategory
            nCat := 15;
            nQuitT := 2; -- предполагаем квитовку 1:N
         else -- recQuitType.ConstType = 2
            nCat := 71;
            nQuitT := 1;
            
            select /*+ Index(DT ix_DocTree_Extrct)*/DT.Classified, DT.DocType, DT.DocState
           from DocTree DT
          where DT.Category = 15
            and DT.Extract = sQuit
            and DT.SysFilial = 1
            and DT.EntityState in (
                  select ESW.EntityState from V_EntityStateWindow ESW
                   where upper(ESW.WindowName) = upper(sQuitLineForm));

select * from doctree where classified in( 228155621, 228136247)

select DT.Classified, DT.DocType, DT.DocState, FindObjectByCode(CI.PayBankCode, CI.PayCodeType) PayBank
           from DocTree DT, BankOper BO, CustomerIso CI
          where trunc(DT.DocValueDate) = trunc(td-1)
            and DT.Classified = BO.Doc
            and DT.Classified = CI.Doc
            and BO.SumConv = 45000000
            and BO.CurrConv = 1000001275
            and DT.SysFilial = 1
            and DT.DocType in (select Classified from DocType where Category = 71)
            and DT.EntityState in (
                  select ESW.EntityState from V_EntityStateWindow ESW
                   where upper(ESW.WindowName) = upper('frmQuittPlan'))

select * from doctree where classified = 228136247
select * from doctype where classified = 1047624710
select * from doctree where classified = 228155332
select * from doctype where classified = 1000161094

select BO.SumConv, BO.CurrConv, Bo.Doc,DT.DocValueDate DocValueDate, CT.Nostro, CI.SectionFlag, upper(substr(CI.SectionFlag,1,1)), BNK_GetPayBank52D(CI.BeneficiaryBankName) as D, FindObjectByCode(CI.PayBankCode, CI.PayCodeType) as A,
                         decode(upper(substr(CI.SectionFlag,1,1)),
                                'A',FindObjectByCode(CI.PayBankCode, CI.PayCodeType),
                                'D', BNK_GetPayBank52D(CI.BeneficiaryBankName),
                                FindObjectByCode(CI.PayBankCode, CI.PayCodeType)) PayBank
                    from DocTree DT, BankOper BO, CustomerTransfer CT, CustomerIso CI
                   where DT.Classified = BO.Doc
                     and DT.Classified = 228155621
                     and CT.Doc = BO.Doc
                     and CI.Doc = BO.Doc
                     
                     select * from client where classified = 24669
                     select * from CustomerIso where doc =  228155621 

126939
select * from od.accountwithreestr where account = 63388240
select * from reestr where accountwithreestr = 1116805201
select * from reestrdoc where accountwithreestr = 1116805201
select * from doctree where classified = 227599184
select * from doctype where classified = 1047168347
select * from doctree where classified in (227599193,188517933)
select * from doctype where classified = 1000135223

126861
select * from od.accountwithreestr where account = 126861
select * from reestr where accountwithreestr = 1116805212
select * from reestrdoc where accountwithreestr = 1116805212
select * from doctree where classified = 227802926
select * from doctype where classified = 1000161094
select * from doctree where classified in (227783440)
select * from doctype where classified = 1047168245

od.dpc_dealdeposit_reservoff_tcb

create or replace procedure dpc_dealdeposit_reservoff_tcb
/******************************************************************************
 Описание: Списание резерва по депозитной сделке (через событие).
 Версия: unknown - первая версия.
         17/10/2007 - Если сделка пролонгирована списывать резерв не нужно.
         18/10/2007 - Остаток проверяется на конец дня.
         17/01/2011 - Панфилов М.С. процедура для "событий"
         07/08/2013 - Панфилов М.С. - теперь проверяем, чтобы под сделкой уже небыло документа списания резерва, иначе не генерим
                                      списание из резерва, чтобы не было задвоений IPI 151741
******************************************************************************/
as
   nIsReceive     DealDeposit.IsReceive%type;
   rAccReserv     DealAcc.tAcc;
   nAmount        DT.Amount;
   sLabel         DocTree.Label%type;
   nDoc           DT.Reference;
   rAccReservRoll DealAcc.tAcc;
   nDocRoll       DT.Reference;
   rdoc           DT.Quantity;
begin
   select IsReceive into nIsReceive from DealDeposit where Doc = Parentdoc(Context.CurrentDoc);
   if nIsReceive = 1 then
      return;
   end if;
   -- Если есть резерв/просрочка тащим счет...
   rAccReserv := DealAcc.GetDealOverResAcc( Parentdoc(Context.CurrentDoc) );
   if rAccReserv.Account is null then
      return;
   end if;
   -- Сумма резерва
   nAmount := DealAcc.AccountRestIn(rAccReserv, trunc(Context.OperDate)+1);
   if nvl(nAmount,0) = 0 then
      return;
   end if;
   -- Пролонгация.
   select min(Doc) into nDocRoll from DealRollOver where Deal = Parentdoc(Context.CurrentDoc);
   if nDocRoll is not null then
      rAccReservRoll := DealAcc.GetDealOverResAcc( nDocRoll );
      if rAccReserv.Account = rAccReservRoll.Account then
         return;
      end if;
   end if;
   select Label into sLabel from DocTree where Classified = Parentdoc(Context.CurrentDoc);
   
   -- 07/08/2013 - Панфилов М.С. - теперь проверяем, чтобы под сделкой уже небыло документа списания резерва, иначе не генерим
   -- списание из резерва, чтобы не было задвоений IPI 151741
   select count(d.classified) into rdoc from doctree d, dealreserv dr where d.parent = dr.deal and dr.reservtype = 2 and
                            d.parent = Parentdoc(Context.CurrentDoc) and category = 914 and docstate != Constants.State_RollBack;
   if rdoc = 0 then
   nDoc := DealReserveCreate(
         null,                -- тип документа
         null,                -- назначение генерации
         Parentdoc(Context.CurrentDoc),  -- родительский документ
         Context.SubSystem,   -- подсистема
         sLabel,              -- Номер документа
         null,                -- Назначение платежа
         Context.OperDate,    -- Дата
         Parentdoc(Context.CurrentDoc),  -- Сделка (депозит/кредит), по которой проводится резервирование
         2,      -- Тип резервирования (при выдаче ссуды, погашении, изменении курса, изменение группы риска, проч.)
         null,                -- Новая группа риска по сделке
        -nAmount);            -- Сумма изменения резерва
   end if;
   DocProcessForChild(nDoc, Context.OperDate, Context.SubSystem, Constants.State_Close, false, false);
end DPC_DealDeposit_ReservOff_tcb;


select d.* from doctree d, dealreserv dr where d.parent = dr.deal and dr.reservtype = 2 and
                            d.parent = Parentdoc(227091116) and d.category = 914 
                            
                            and docstate != Constants.State_RollBack

select * from dealreserv

select * from docstate
1   procedure CheckCondition_1012874873 (ConditionResult out DT.Status) is
2      bIsEventPercent                  BOOLEAN; /* Проценты? */
3      ChildDoc  DT.Reference; /*  Classified созданного документа  */
4   begin
5      bIsEventPercent := DEALISEVENTPERCENT;
6    if bIsEventPercent then
7       ConditionResult:=1;
8     else
9       ConditionResult:=0;
10    end if;
11  end;

select *from DocTree DT, GenIntention GI
                where DT.GenIntention = GI.Classified
                  and GI.ConstIntention = 901
                  and DT.Classified = 226809483

select * from GenIntention GI where   GI.ConstIntention = 4 --901

od.DPC_DepositDeal_Events

select * from dealswappayment where doc = 226802512
(select * from DealRollover where Doc = 227090618)

select * from DealTransaction
                where Doc in (select Classified from DocTree
                               where Parent = 226953182
                                 and DocState not in (Constants.State_Close, Constants.State_Cancel, Constants.State_Rollback)
                                 and GenIntention = 1000000023)
                  --and ValueDate = recDealTr.ValueDate
                  and IsNetting = 0
                  and sign(Amount) = sign(300000000)
                  
                  select * from docstate
                  select * from 
                  
select * from DealTransaction
                where Doc in (select Classified from DocTree
                               where Parent = 226652298
                                 and DocState not in (1000000036, 1000000037)
                                 and GenIntention = 1000000023)
                  --and ValueDate = recDealTr.ValueDate
                  and IsNetting = 0
                  and sign(Amount) = sign(-300000000)

select * from v_BO_CT_ISO

SELECT   DT.Classified, DT.Label, DT.DocType, ' ', ' ', DT.OperDate,
 SUBSTR(AccountCode( DT.CT_Nostro ),1,34),
 SUBSTR(CurrencyISO( DT.BO_CurrConv ),1,3),
 SUBSTR( FmtDocSum( DT.BO_SumConv,DT.BO_CurrConv ),1,30 ),
DT.BO_SumConv ,NULL  ,DT.CT_Nostro, DT.OperCause ,NULL,
DT.CI_PayBankName,
DT.CT_PayAccount,
DT.ValidFromDate,
DT.BO_Account,
SUBSTR( AccountCode(DT.BO_Account ),1,34),
SUBSTR(ClearingHouseLabel(DT.CT_ClearingHouse ),1,30), 
SUBSTR(TransMessageLabel( DT.CT_TransferMessage ),1,30), 
SUBSTR( DT.CI_AgentBankName,1,34) ,
DT.Obj, DT.DocState, DT.DocType, DT.Category,
DT.CT_ConnectedAcc, DT.CT_RsNostro,NULL,
SUBSTR(GetVObjProp(DT.Classified,1000012701),1,1),
DT.DocValueDate,
DT.CI_PayBankCode ,
SUBSTR( GetClientRegLab( GetBank_Code( DT.CI_PayBankCode, DT.CI_PayCodeType)), 1, 30) ,
DT.CT_PayName ,
GetBank_Code( DT.CI_PayBankCode, DT.CI_PayCodeType) ,
DT.BO_CurrConv ,
SUBSTR( GetVDocDescValue( DT.Classified , 1000010861), 1, 254),
SUBSTR( GetVDocDescValue( DT.Classified , 1000039805 ), 1, 254) ,
DT.CT_Nostro,
DT.InitDate ,
DT.Description,DT.Extract  ,
'',
DT.Priority,
'',
Substr(DT.CT_BeneficiaryName,1,30) ,
Substr( FmtDocSum( decode( DT.Category, 4, -DT.BO_SumAccount, DT.BO_SumAccount ) ,DT.BO_CurrAccount ),1,30 ),
decode( DT.Category, 4, - DT.BO_SumAccount, DT.BO_CurrAccount ),
Nostro_Quit.IsQuitDoc( 2, DT.Classified ),
SubStr( FmtDocSum( decode( DT.Category, 4, -Nostro_Quit.UnQuitSum( 2, DT.Classified ), 
                                                                                    Nostro_Quit.UnQuitSum( 2, DT.Classified ) ), DT.BO_CurrConv ),1,30 ),
Nostro_Quit.UnQuitSum( 2, DT.Classified ),
decode( DT.Category, 4, - Nostro_Quit.UnQuitSum( 2, DT.Classified ), Nostro_Quit.UnQuitSum( 2, DT.Classified )),
Substr( AccLabel(DT.CT_Nostro),1,34),
Substr(DT.CT_BeneficiaryAccount,1,34),
Substr( DT.CT_BeneficiaryTaxid,1,20 ) ,
Substr( DT.CI_INFOAGENTBANK,1,254 )  
 FROM v_BO_CT_ISO DT 
  WHERE DT.DocType IN (1000339710,1000161094,1000161029,1000339558,1000339459,1000339360)
    AND DT.OperDate >= TO_DATE( '2013-08-01-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
    AND DT.OperDate <= TO_DATE( '2013-08-07-23.59.00', 'YYYY-MM-DD-HH24.MI.SS' ) AND DT.BO_CurrConv = 1000001275  AND  DT.CT_Nostro=188499930 
AND DT.BO_CurrConv = 1000001275 
   AND ROWNUM <= 100 

----------------------------------------------------------------------------------
--08/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.dpc_createpercentaccountdoc
od.getbillaccount
od.dealdep_proc.CreateDepSheduleOfPayments
od.DEAL_GetPaymentPurpose
od.dpc_deallimit_close
od.ut_dealaccrual
od.DealBegProcDate

   procedure CreateDepSheduleOfPayments(
   /******************************************************************************
    Автор:    Шубин Р.
    Описание: Создать график платежей на основе графика процентов.
    Версия:   17.04.2012
              08.06.2012 AGN
              04.12.2012 - учтен расчет подробностей без округления (Зам. № 44099, AGN)
              16.01.2013
              --28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
   *****************************************************************************/
      idDoc    DT.Reference,       -- документ.
      nInit    DT.Status default 1 -- инициализация переменных
   ) as
      idPaymentLine   DT.Reference;                  
      nAmountPay      DT.Amount;
   begin
      if nvl(nInit, 1) = 1 then
         InitVariables(idDoc);
      end if;
      -- выплаты по процентам:
      -- nSign := i.f(recDealDep.IsReceive = 1, -1, 1);
--28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
for recDSI in
         (
            select sum(P.AMOUNT) Amount, P.PayDate InterestDate, NTLCurrency,
                   P.PaymentLine
              from DealSwapInterest DSI, DealSwapPayPeriod P
             where DSI.Doc = idDoc
               and P.InterestPeriod = DSI.Classified
          group by P.PaymentLine, P.PayDate, NTLCurrency
         )
      loop
         nAmountPay :=  round(recDSI.Amount, nvl(MinorUnit(recDSI.NTLCurrency), 2));
         update DealSwapPayment
            set Amount = nAmountPay,
                Currency = recDSI.NTLCurrency,
                IsNetting = recDeal.IsNetting
          where Doc = idDoc and Classified = recDSI.PaymentLine;
         if sql%notfound then
            insert into DealSwapPayment (Doc, ValueDate, Currency, Amount,
                                          PaymentType, IsNetting, NettAmount)
               values (idDoc, recDSI.InterestDate, recDSI.NTLCurrency, nAmountPay,
                        nPaymentType_Interest, 0, null)
               returning Classified into idPaymentLine;
            update DealSwapPayPeriod
               set PaymentLine = idPaymentLine
             where PayDate = recDSI.InterestDate
               and InterestPeriod in (select Classified from DealSwapInterest
                                       where NTLCurrency = recDSI.NTLCurrency
                                         and Doc = idDoc);
         end if;
      end loop;
      -- основные суммы + амортизация.
      GeneralAmountExchange;
      -- перенумерация платежей.
      ReCalculateSheduleOfPayments(idDoc);
   end CreateDepSheduleOfPayments;

create or replace function DEAL_GetPaymentPurpose
/******************************************************************************
 Автор: Цветков В.
 Описание: Получение шаблона строки назначения платежа из PAYMENTPURPOSE по ключу и раскрытие макросов
 24.06.2010 по заданию 2161-У.
 Версия:
 13.11.2010 Доработка 31804: function DEAL_GetPaymentPurpose -
                Исправлено раскрытие макроса <DocOperDate> и <DealDate>(формат)
 19.04.2011 Новые тэги
 16.05.2011 Тэг <TICKET> (тикет сделки)
 27.05.2011 вместо nDoc должен быть nDeal в вызове BEGPROCDATE и в процедуре
            LoadDealNettingRec.
 12.12.2012 добавлен тэг BEGACCRDATE - дата начала начисления процентов (Зам. № 44161, AGN)
 08.02.2013 добавлена возможность прямой распаковки шаблона строки без использования справочника (Дор. № 12438, AGN)
 13.06.2013 Панфилов М.С. добавлены тэги <CLLabel>, <CLVALUEDATE>, <BEGPROCDATE2>
 ******************************************************************************/
(  sTemplateCode  DT.Text,        -- Код строки-шаблона
   nDeal          DT.Reference,   -- Сделка
   nDoc           DT.Reference,   -- Документ
   sExtraText     DT.Text,         -- Дополнительный текст
   nDirectExpand  DT.Status default 0 -- прямая распаковка шаблонов строки без справочника
)
return DT.Text as
   sPurpose       DT.Text;
   recDeal        Deal%rowtype;
   recDocTree     DocTree%rowtype;
   recDealReserv  DealReserv%rowtype;
   recDealROLL    Deal%rowtype;
   recDealDeposit DealDeposit%rowtype;
   recDealNetting DealNetting%rowtype;
   recDealTrans   DealTransaction%rowtype;
   recDocTreeCL   DocTree%rowtype;
   recDealCL      Deal%rowtype;
   --
   sCurrTag       Dt.Text;
   sDTFMT         constant Dt.Label := 'DD/MM/YYYY';
   sDTFMT1        constant Dt.Label := 'DD.MM.YY';
   dtDateTemp     Date;
   --
   procedure LoadDealRec as
      cursor c is select * from Deal where Doc = nDeal;
   begin
      if recDeal.Doc is null then
         open c;
         fetch c into recDeal;
         close c;
      end if ;
   end LoadDealRec;
   --
   procedure LoadDocRec as
      cursor c is select * from DocTree where Classified = nDoc;
   begin
      if recDoctree.Classified is null then
         open c;
         fetch c into recDocTree;
         close c;
      end if ;
   end LoadDocRec;
   --
   procedure LoadDealReservRec as
      cursor c is select * from DealReserv where Doc = nDoc;
   begin
      if recDealReserv.Doc is null then
         open c;
         fetch c into recDealReserv;
         close c;
      end if ;
   end LoadDealReservRec;
   --
   procedure LoadDealRollRec as
      cursor c is select * from Deal where Doc =
         (select Deal from DealRollover where Doc = nDeal);
   begin
      if recDealRoll.Doc is null then
         open c;
         fetch c into recDealRoll;
         close c;
      end if ;
   end LoadDealRollRec;
   --
   procedure LoadDealDepositRec as
      cursor c is select * from DealDeposit where Doc = nDeal;
   begin
      if recDealDeposit.Doc is null then
         open c;
         fetch c into recDealDeposit;
         close c;
      end if ;
   end LoadDealDepositRec;
   --
   procedure LoadDealNettingRec as
      cursor c is select * from DealNetting where Doc = nDeal;--nDoc;
   begin
      if recDealNetting.Doc is null then
         open c;
         fetch c into recDealNetting;
         close c;
      end if ;
   end LoadDealNettingRec;
   --
   procedure LoadDealTransRec as
      cursor c is select * from DealTransaction where Doc = nDoc;
   begin
      if recDealTrans.Doc is null then
         open c;
         fetch c into recDealTrans;
         close c;
      end if ;
   end LoadDealTransRec;
   --
   procedure LoadDocCLRec as
      cursor c is select * from DocTree where Classified = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDocTreeCL.Classified is null then
         open c;
         fetch c into recDocTreeCL;
         close c;
      end if ;
   end LoadDocCLRec;
   --
   procedure LoadDealCLRec as
      cursor c is select * from Deal where Doc = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDealCL.Doc is null then
         open c;
         fetch c into recDealCL;
         close c;
      end if ;
   end LoadDealCLRec;
   --
begin
      if nDirectExpand = 1 then
      sPurpose := sTemplateCode;
      else
        begin
        select value into sPurpose from dealpaymentpurpose where fullname =  sTemplateCode;
        exception when NO_DATA_FOUND then
        --raise_application_error(-20000, 'Шаблон не найден. Код ' || sTemplateCode) ;
        tm_proc.RaiseError(42212, sTemplateCode);
        end;
      end if;
--   dbms_output.put_line('1 ' || spurpose);

   sCurrTag := '<DealLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('2 ' || spurpose);

   sCurrTag := '<DealDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDeal.DealDate); --to_char(recDeal.DealDate,'DD.MM.YYYY'));
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT));
   end if ;

--   dbms_output.put_line('3 ' || spurpose);

   sCurrTag := '<ExtraText>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag, sExtraText);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocDescription>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Description);
   end if ;

--   dbms_output.put_line('5 ' || spurpose);

   sCurrTag := '<DocOperDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDocTree.OperDate);
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT));
   end if ;

--   dbms_output.put_line('6 ' || spurpose);

   sCurrTag := '<RiskGroup>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        if recDocTree.Category = 914 then
            LoadDealReservRec;
            sPurpose := replace(sPurpose, sCurrTag, PactRiskGrouplabel(NVL(recDealReserv.RiskGroup, recDealReserv.OldRiskGroup)));
        else
            sPurpose := replace(sPurpose, sCurrTag, '');
        end if;
   end if ;

--   dbms_output.put_line('7 ' || spurpose);

   sCurrTag := '<COUNTERPARTY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDeal.CounterParty));
--dbms_output.put_line('8 ' || spurpose);
   end if ;

   sCurrTag := '<TICKETROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, recDealRoll.Ticket);
--dbms_output.put_line('9 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealRoll.CounterParty));
--dbms_output.put_line('10 ' || spurpose);
   end if ;

   sCurrTag := '<ROLLDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealDepositRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealDeposit.RollOverStartDate,sDTFMT));
--dbms_output.put_line('11 ' || spurpose);
   end if ;


   sCurrTag := '<OPERDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT1));
--dbms_output.put_line('12 ' || spurpose);
   end if ;

   sCurrTag := '<EXTRACT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Extract);
--dbms_output.put_line('13 ' || spurpose);
   end if ;

   sCurrTag := '<TRANSACTDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT1));
--dbms_output.put_line('14 ' || spurpose);
   end if ;

   sCurrTag := '<VALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealNetting.ValueDate,sDTFMT1));
--dbms_output.put_line('15 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYNET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealNetting.CounterParty));
--dbms_output.put_line('16 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARYBANK>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.BeneficiaryBank));
--dbms_output.put_line('17 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.Beneficiary));
--dbms_output.put_line('18 ' || spurpose);
   end if ;

   sCurrTag := '<BEGPROCDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate(nDeal),sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;
   -- дата начала начисления %%
   sCurrTag := '<BEGACCRDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      dtDateTemp := trunc(DealBegProcDate(nDeal)); -- дата последнего начисления %%
      if dtDateTemp > recDeal.ValueDate + 1 then
         dtDateTemp := dtDateTemp + 1;
      else
         dtDateTemp := recDeal.ValueDate + 1;
      end if;
      sPurpose := replace(sPurpose, sCurrTag, to_char(dtDateTemp,sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONAMOUNT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        recDealTrans.Amount);
--dbms_output.put_line('20 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealTrans.ValueDate,sDTFMT));
--dbms_output.put_line('21 ' || spurpose);
   end if ;

   sCurrTag := '<DOCTREEDOCVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDocTree.DocValueDate,sDTFMT));
--dbms_output.put_line('22 ' || spurpose);
   end if ;

    --тикет сделки (Deal.TICKET)
   sCurrTag := '<TICKET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, recDeal.Ticket);
   end if ;

   --кредитная линия по траншу (Deal.CREDITLINE.Label)
   sCurrTag := '<CLLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocCLRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTreeCL.Label);
   end if ;

   --дата начала кредитной линии по траншу (Deal.CREDITLINE.VALUEDATE)
   sCurrTag := '<CLVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealClRec;
        sPurpose := replace(sPurpose, sCurrTag, to_char(recDealCL.ValueDate,sDTFMT));
   end if ;

   --дата начала предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE2>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate2(nDeal),sDTFMT));
   end if ;

   return SUBSTR(sPurpose,1,254);

end DEAL_GetPaymentPurpose;


----------------------------------------------------------------------------------
--09/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

deal1183.sql ++
deal1100.sql ++
deal1101.sql ++
deal1109.sql ++
deal1114.sql ++
deal1181.sql ++
+ обработка связанных для автоматического удаления доп.согл и копий сделок под траншами ++

----------------------------------------------------------------------------------
--12/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select ConstValue, Label from ConstantsLabel where table_name='DEALPERIODEVENT'
and column_name='PERIODTYPE' order by 1

select ConstValue, Label from ConstantsLabel where table_name='DEALPERIODEVENT'
and column_name='SHIFTRULE' order by 1

select * from od.dealfuture where doc = 227432970
select * from doctree where classified = 227432970
227 432 838

SELECT c.classified,cn.label naim,c.operdate,c.amount,substr(CurrencyISO(c.Currency),1,50),st.label amounttype,c.percent, substr(nvl(DoctreeLabel(c.cppayreq), '?'),1,50), c.description
     FROM Commisionadd c, commisionnaim cn, commisionsumtype st
     Where c.Doc = 227432838 and c.naim=cn.classified(+) and c.amounttype = st.classified(+) Order By OperDate Asc

select AddAgreement,  ValidToDate, DocTreeLabel( AddAgreement ), DocTreeOperDate( AddAgreement ), DocTreeLabel( AddAgreement ),
	ELHLabel_Doc( AddAgreement ), DocTreeOperDate( AddAgreement ),  Doc, DocTreeLabel( Doc ), decode(ValidToDate, '01/01/4444 12:00:00',null,ValidToDate),
	ELHLabel_Doc( Doc ), DocTreeOperDate( Doc)
 from DocHistory
 where MainDoc = 227432838
    order by 1

select *
 from DocHistory
 where MainDoc = 227432838
    order by 1
    
select * from DocHistory

SELECT *
/*  DT.Classified, DT.Label, DT.DocType, ' ', ' ', DT.OperDate,
 SUBSTR(AccountCode( DT.CT_Nostro ),1,34),
 SUBSTR(CurrencyISO( DT.BO_CurrConv ),1,3),
 SUBSTR( FmtDocSum( DT.BO_SumConv,DT.BO_CurrConv ),1,30 ),
DT.BO_SumConv ,NULL  ,DT.CT_Nostro, DT.OperCause ,NULL,
DT.CI_PayBankName,
DT.CT_PayAccount,
DT.ValidFromDate,
DT.BO_Account,
SUBSTR( AccountCode(DT.BO_Account ),1,34),
SUBSTR(ClearingHouseLabel(DT.CT_ClearingHouse ),1,30), 
SUBSTR(TransMessageLabel( DT.CT_TransferMessage ),1,30), 
SUBSTR( DT.CI_AgentBankName,1,34) ,
DT.Obj, DT.DocState, DT.DocType, DT.Category,
DT.CT_ConnectedAcc, DT.CT_RsNostro,NULL,
SUBSTR(GetVObjProp(DT.Classified,1000012701),1,1),
DT.DocValueDate,
DT.CI_PayBankCode ,
SUBSTR( GetClientRegLab( GetBank_Code( DT.CI_PayBankCode, DT.CI_PayCodeType)), 1, 30) ,
DT.CT_PayName ,
GetBank_Code( DT.CI_PayBankCode, DT.CI_PayCodeType) ,
DT.BO_CurrConv ,
SUBSTR( GetVDocDescValue( DT.Classified , 1000010861), 1, 254),
SUBSTR( GetVDocDescValue( DT.Classified , 1000039805 ), 1, 254) ,
DT.CT_Nostro,
DT.InitDate ,
DT.Description,DT.Extract  ,
'',
DT.Priority,
'',
Substr(DT.CT_BeneficiaryName,1,30) ,
Substr( FmtDocSum( decode( DT.Category, 4, -DT.BO_SumAccount, DT.BO_SumAccount ) ,DT.BO_CurrAccount ),1,30 ),
decode( DT.Category, 4, - DT.BO_SumAccount, DT.BO_CurrAccount ),
Nostro_Quit.IsQuitDoc( 2, DT.Classified ),
SubStr( FmtDocSum( decode( DT.Category, 4, -Nostro_Quit.UnQuitSum( 2, DT.Classified ), 
                                                                                    Nostro_Quit.UnQuitSum( 2, DT.Classified ) ), DT.BO_CurrConv ),1,30 ),
Nostro_Quit.UnQuitSum( 2, DT.Classified ),
decode( DT.Category, 4, - Nostro_Quit.UnQuitSum( 2, DT.Classified ), Nostro_Quit.UnQuitSum( 2, DT.Classified )),
Substr( AccLabel(DT.CT_Nostro),1,34),
Substr(DT.CT_BeneficiaryAccount,1,34),
Substr( DT.CT_BeneficiaryTaxid,1,20 ) ,
Substr( DT.CI_INFOAGENTBANK,1,254 ) */ 
 FROM v_BO_CT_ISO DT 
  WHERE DT.DocType IN (1000339710,1000161094,1000161029,1000339558,1000339459,1000339360)
 --   AND DT.OperDate >= TO_DATE( '2013-08-09-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
 --   AND DT.OperDate <= TO_DATE( '2013-08-12-23.59.00', 'YYYY-MM-DD-HH24.MI.SS' ) AND DT.BO_CurrConv = 1000001275  AND  DT.CT_Nostro=160737904 
AND DT.BO_CurrConv = 1000001275 
   AND ROWNUM <= 100 

select * from doctype where classified in (1000339710,1000161094,1000161029,1000339558,1000339459,1000339360)
select * from account where classified = 160737904 


od.Nostro_Quit.AutoQuitDocs


select StartDate, EndDate, InterestAmount, AccrualAmount
  from DealSwapInterest
 where Doc = 225634707
 order by StartDate asc
 
 select * from DEALDEPOSIT where doc = 225634707
 
 select BegChargeDate, EndChargeDate, PayDate, Amount, AccrualAmount  
 from DealSwapPayPeriod  where InterestPeriod in (select Classified from DealSwapInterest where Doc = 225634707)

od.DealDepositAddAgreementClose

 select ValidFromDate, ValidToDate, PercRate
   from CRateVersion RV, CRateTable RT
  where RV.Rate = 1254466569  -- DEALDEPOSIT.RATEINDEX
    and RT.RateVariant(+) = RV.Classified
    and RV.ValidFromDate <= to_date('23.11.2007','DD.MM.YYYY')
    and RV.ValidToDate > to_date('23.11.2007','DD.MM.YYYY')
  order by ValidFromDate

----------------------------------------------------------------------------------
--14/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from od.dealintratehistory where doc = 182659070
select * from dealdeposit.intrate  where doc = 182586346
select 150000000*(0.1/365) from dual

deal1113.sql ++
deal1121.sql ++
deal1130.sql ++
deal1136.sql ++
deal1138.sql ++
deal1140.sql ++ очень долго отрабатывает (на athena3 - час)
deal1142.sql ++
deal1150.sql ++

deal1155.sql ++

deal1156.sql ++
deal1176.sql ++
deal1186.sql ++

rdea1221.sql ++
----------------------------------------------------------------------------------
--15/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
bbr.BBR_DYNAMICS_BALANCES_KREST
od.SRP_UFEBS_Control_ARMKBR
od.SRP_MAKERMAKETLASTRAYS

----------------------------------------------------------------------------------
--16/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select 228344741
declare
   nPercent  Bill.Percent%type;
begin
   select nvl(Percent,-1) into nPercent
    from Bill where Classified = BC.GetBill;
  if nPercent >= 0 then
    :nCondResult := 1;
  else
    :nCondResult := 0;
  end if;
exception
   When Others then
      :nCondResult := 0;
end;

od.DPC_EditGuidBill

----------------------------------------------------------------------------------
-- правил процедуры od.DPC_BillSumCorrection_TCB и od.DPC_BillSumCorrectionDisc_TCB (убрал проверки из manager и встроил их в процедуры, чтобы можно было в 
-- одно погашение вклшючать и дисконтные и процентные векселя) - это ошибки из-за некачественных тестов по задаче 130215                                        ++
----------------------------------------------------------------------------------
od.DPC_BillSumCorrection_TCB
od.DPC_BillSumCorrectionDisc_TCB
create or replace procedure DPC_BillSumCorrection_TCB
/******************************************************************************
 Изменение суммы %% по векселю (коррекция %% для досрочного выкупа по ставке досрочного погашения)
 Дата: 25/04/2013
 Автор: Панфилов М.С.
  -- 16/08/2013 Панфилов М.С. - встроил проверку, процентный вексель или нет
******************************************************************************/
as
  psum           dt.Amount;
  pallsum        dt.Amount := 0;                -- вся сумма процентов по операции
  allsum         dt.Amount := 0;                -- вся сумма по операции
  sPerc          objdesc.desctext%type;         -- процентная ставка из доп.описания
  nPerc          billrange.percentsum%type;     -- процентная ставка из доп.описания
  nPercent       Bill.Percent%type;
begin
      -- проверяем доп.описание
      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

dbms_output.put_line('DPC_BillSumCorrection_TCB ->');

begin

  -- если доп.описание есть
  if nPerc is not null then
  for rec in (select br.*, b.billsum from BillRange br, bill b where br.Doc=CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      nPercent := 0;
      select nvl(Percent,-1) into nPercent from Bill where Classified = rec.bill;
      if nPercent >= 0 then -- 16/08/2013 Панфилов М.С. - встроил проверку, процентный вексель или нет
      -- вычислим сумму процентов по новой ставке nPerc
      psum := BillDPPercentSum_TCB(rec.bill,Context.OperDate,nPerc);
      update BillRange set percentsum = psum, rowprice = psum + rec.billsum where bill = rec.bill;
      pallsum := pallsum + psum;
      allsum := allsum + psum + rec.billsum;
      dbms_output.put_line('DPC_BillSumCorrection_TCB <- ' || psum);
      end if;
    end loop;

  update billpercent set percentsum = pallsum where doc = Context.CurrentDoc;

  update BillOper set OperSum=allsum, SumFrom=allsum, SumTo=allsum where Doc=CONTEXT.CurrentDoc;

  end if;

exception
  when others then null;
end;

end DPC_BillSumCorrection_TCB;

create or replace procedure DPC_BillSumCorrectionDisc_TCB
/******************************************************************************
 Изменение суммы операции по непроцентному векселю (коррекция цены для досрочного выкупа по ставке досрочного учета векселя)
 для пермских непроцентных векселей, которые выдются по номиналу
 Дата: 16/07/2013
 Автор: Панфилов М.С.
 -- 16/08/2013 Панфилов М.С. - встроил проверку дисконтный вексель или нет
******************************************************************************/
as
  psum           dt.Amount;
  allsum         dt.Amount := 0;                -- вся сумма по операции
  sPerc          objdesc.desctext%type;         -- процентная ставка дисконта из доп.описания
  nPerc          billrange.percentsum%type;     -- процентная ставка дисконта из доп.описания
  dateend        date;                          -- дата погашения векселя
  T              dt.Quantity;                   -- срок, оставшийся до погашения
  nPercent       Bill.Percent%type;
begin
  dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB ->');

  for rec in (select br.*, b.billsum, b.paydatevar, b.date1, b.date2, b.DRAWDATE, b.time from BillRange br, bill b where br.Doc = CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      nPercent := 0;
      select nvl(Percent,-1) into nPercent from Bill where Classified = rec.bill;
      if nPercent < 0 then -- 16/08/2013 Панфилов М.С. - встроил проверку дисконтный вексель или нет
      begin
        psum  := null;
        sPerc := null;
        nPerc := null;
        dateend := null;
        T := null;

      -- проверяем доп.описание
      begin
      select value into sPerc from ENUMTYPEVALUE where classified in (select ENUMTYPEVALUE from OBJENUM where enumtype = (select classified from enumtype where constenum = -5000) and obj = rec.bill);

      nPerc := sPerc;
      dbms_output.put_line('sPerc -> ' || sPerc);
      exception
             when others then null;
      end;

      -- если доп.описание есть
      if nPerc is not null then
      -- вычислим срок, оставшийся до погашения
      begin
                  select CASE
                  WHEN rec.paydatevar = 1 AND rec.date2 IS NOT NULL THEN
                   rec.date1
                  WHEN rec.paydatevar = 1 AND rec.date1 IS NOT NULL THEN
                   rec.date1
                  WHEN rec.paydatevar = 4 THEN
                   rec.date1
                  when rec.paydatevar = 1 and rec.date1 is null and rec.date2 is null then
                   rec.DRAWDATE
                    when rec.paydatevar = 3 then
                   rec.DRAWDATE + rec.time
                  ELSE
                   null
                  END into dateend from dual;
                  dbms_output.put_line('dateend -> ' || to_char(dateend,'dd.mm.yyyy'));
                  T := trunc(dateend) - trunc(CONTEXT.OperDate);
                  dbms_output.put_line('T -> ' || T);
      exception
        when others then null;
      end;
      -- вычислим сумму дисконта по новой ставке nPerc
      psum := round(rec.billsum*(1-T*nPerc/36500),MinorUnit(GetBillCurrency(rec.bill)));
      update BillRange set rowprice = psum where bill = rec.bill;
      allsum := allsum + psum;
      dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB ' || psum);
      end if;
      exception
        when others then null;
      end;
    end if;  
  end loop;
  update BillOper set OperSum=allsum, SumFrom=allsum, SumTo=allsum where Doc=CONTEXT.CurrentDoc;

dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB <- ');
exception
  when others then null;
end DPC_BillSumCorrectionDisc_TCB;



select * from bill where num = '0032100' --1261279161
-- просила поправить Герасимова                                                                                                                                 ++
-- update bill set date1 = to_date('13032014','ddmmyyyy') where classified = 1261279161
select * from DealSwapPayment
od.CopyDealSwapGraphs
----------------------------------------------------------------------------------
--19/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_READACCOUNT
-- форматировал BBR_TCB_BILL_RASP_OPER_POG для Герасимовой                                                                                                      ++

od.tcb_dwh.getsegment

----------------------------------------------------------------------------------
--20/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 228708208 
select * from dealtransaction where doc = 228708024

od.DPC_BillMultiSet

select to_number(PropValue) ChildDocType, SQLCondition, IsRevert from EntityPropValue
                     where EntityClass = idParentDocType and EntityState = idState
                       and Context = nvl(idChildIntention,Constants.Pay_Other)
                       and PropValue in (select Classified from DocType where Category = nCategory)
                       and PropType = 3

select to_number(PropValue) ChildDocType, SQLCondition, IsRevert from EntityPropValue
                     where EntityClass = 1065654255 and EntityState = idState
                       and Context = nvl(idChildIntention,Constants.Pay_Other)
                       and PropValue in (select Classified from DocType where Category = nCategory)
                       and PropType = 3

select * from doctype d where d.category = 720

-- по задаче IPI 153244 - сделал условие "прошла дата переноса "к исполнению" по векселю?" и генерить в зависимости от него (под состоянием "Создан")
-- под Меной "Погашение векселя" или "Досрочный выкуп собственного векселя" + для "Погашения векселя" в обработе связанных объектов на действии "Исполнить"
-- нужно добавить заглушку (очерёдность 51)                                                                                                                  ++
declare
xpaydatevar bill.paydatevar%type;    
xdate1         bill.date1%type;  
xbdrawdate  bill.drawdate%type;  
xbtime         bill.time%type;  
begin
dbms_output.put_line('0');
dbms_output.put_line(BC.GetBill);
  select paydatevar, date1, drawdate, time into xpaydatevar, xdate1, xbdrawdate, xbtime  from bill where classified = BC.GetBill; 
   if (xpaydatevar = 4 AND (context.operdate) >= xdate1) 
   or (xpaydatevar = 1 AND (context.operdate) >= add_months(xdate1, 12))
   or (xpaydatevar = 3 AND (context.operdate) >= xbdrawdate + xbtime)
    then       -- прошла дата переноса "к исполнению" по векселю?
dbms_output.put_line('PayInTerm=true');
     :nCondResult := 1;
   else
dbms_output.put_line('PayInTerm=false');
     :nCondResult := 0;
   end if;
end;


Sum2 = 30000000
recInt.IsDepartment =  
BC.recDoc.nCategory =  720
BC.recBillOper.DEPARTMENT =  1021035144
nCompetitorType = 
nIsResident = 
nDepartment = 
nIntention = 1011996344
nCurrency = 1000001275
Sum3 = 30000000
nDoc = 228888456
Constants.State_Close = 1000000035

select * from docstate 
----------------------------------------------------------------------------------
--21/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проблемы с валютными траншами МБК 08/2013 (2)
-- 1. Если по сделке есть периодическая амортизация в доп. соглашении и ручная амортизация в день доп. соглашения, то возникает ошибка (при пересчете процентного графика 
-- сумма ОД уменьшается на сумму периодической амортизации, которая указана в доп. соглашении и дата старта которой ещё не наступила, а не на сумму ручной амортизации) 
-- - можно побороть не исполняя последние события до ввода доп. соглашения 
-- + 2.После ввода ручной амортизации, разбивающей процентный период на две части, даты платежа у первой и второй частей равны. 
-- => написал в НА 20/08/2013 => 20/08/2013 зарегистрировали замечание 48002 => ответили, что нужно вручную в процентном графике править дату платежа, пересчитывать 
-- графики и исполнять события по процентам                                                                                                                         ++
-- Ледовская хочет, чтобы можно было менять даты в графике платежей на периодических амортизация => 22/08/2013 написал в НА => зарегистрировали замечание 48021 
-- => 05/09/2013 прислали deal1190.sql !!! => тестим на diling -- => 03/10/2013 накатил на боевой                                                                   ++
-- проблемы с двумя ЕБРР на боевой !!! => зарегистрировали в НА 23/08/2013 замечание 48032 => 05/09/2013 прислали deal1190.sql !!! => тестим на diling 
-- => 03/10/2013 накатил на боевой                                                                                                                                  ++
-- проблемы с COMMERZ на боевой !!! (аналогично ЕБРР) => 05/09/2013 прислали deal1190.sql !!! => тестим на diling => 03/10/2013 накатил на боевой                   ++

od.dealdep_proc

procedure CreateDepSheduleOfPayments(
   /******************************************************************************
    Автор:    Шубин Р.
    Описание: Создать график платежей на основе графика процентов.
    Версия:   17.04.2012
              08.06.2012 AGN
              04.12.2012 - учтен расчет подробностей без округления (Зам. № 44099, AGN)
              16.01.2013
              --28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
   *****************************************************************************/
      idDoc    DT.Reference,       -- документ.
      nInit    DT.Status default 1 -- инициализация переменных
   ) as
      idPaymentLine   DT.Reference;                  --
      nAmountPay      DT.Amount;
   begin
      if nvl(nInit, 1) = 1 then
         InitVariables(idDoc);
      end if;
      -- выплаты по процентам:
      -- nSign := i.f(recDealDep.IsReceive = 1, -1, 1);
--28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
for recDSI in
         (
            select sum(P.AMOUNT) Amount, P.PayDate InterestDate, NTLCurrency,
                   P.PaymentLine
              from DealSwapInterest DSI, DealSwapPayPeriod P
             where DSI.Doc = idDoc
               and P.InterestPeriod = DSI.Classified
          group by P.PaymentLine, P.PayDate, NTLCurrency
         )
      loop
         nAmountPay :=  round(recDSI.Amount, nvl(MinorUnit(recDSI.NTLCurrency), 2));
         update DealSwapPayment
            set Amount = nAmountPay,
                Currency = recDSI.NTLCurrency,
                IsNetting = recDeal.IsNetting
          where Doc = idDoc and Classified = recDSI.PaymentLine;
         if sql%notfound then
            insert into DealSwapPayment (Doc, ValueDate, Currency, Amount,
                                          PaymentType, IsNetting, NettAmount)
               values (idDoc, recDSI.InterestDate, recDSI.NTLCurrency, nAmountPay,
                        nPaymentType_Interest, 0, null)
               returning Classified into idPaymentLine;
            update DealSwapPayPeriod
               set PaymentLine = idPaymentLine
             where PayDate = recDSI.InterestDate
               and InterestPeriod in (select Classified from DealSwapInterest
                                       where NTLCurrency = recDSI.NTLCurrency
                                         and Doc = idDoc);
         end if;
      end loop;
      -- основные суммы + амортизация.
      GeneralAmountExchange;
      -- перенумерация платежей.
      ReCalculateSheduleOfPayments(idDoc);
   end CreateDepSheduleOfPayments;

select 13636363.64*0.0350188*(3/360)  from dual
select 13636363.64*0.0350188*(179/360)  from dual
----------------------------------------------------------------------------------
--22/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree d where classified = 228673806
select * from doctree where classified = 228668445
select * from doctype where classified = 1179850206

select * from doctree d where classified = 54142082
od.fxevent_doc


----------------------------------------------------------------------------------
--23/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

create or replace function DEAL_GetPaymentPurpose
/******************************************************************************
 Автор: Цветков В.
 Описание: Получение шаблона строки назначения платежа из PAYMENTPURPOSE по ключу и раскрытие макросов
 24.06.2010 по заданию 2161-У.
 Версия:
 13.11.2010 Доработка 31804: function DEAL_GetPaymentPurpose -
                Исправлено раскрытие макроса <DocOperDate> и <DealDate>(формат)
 19.04.2011 Новые тэги
 16.05.2011 Тэг <TICKET> (тикет сделки)
 27.05.2011 вместо nDoc должен быть nDeal в вызове BEGPROCDATE и в процедуре
            LoadDealNettingRec.
 12.12.2012 добавлен тэг BEGACCRDATE - дата начала начисления процентов (Зам. № 44161, AGN)
 08.02.2013 добавлена возможность прямой распаковки шаблона строки без использования справочника (Дор. № 12438, AGN)
 13.06.2013 Панфилов М.С. добавлены тэги <CLLabel>, <CLVALUEDATE>, <BEGPROCDATE2>
 ******************************************************************************/
(  sTemplateCode  DT.Text,        -- Код строки-шаблона
   nDeal          DT.Reference,   -- Сделка
   nDoc           DT.Reference,   -- Документ
   sExtraText     DT.Text,         -- Дополнительный текст
   nDirectExpand  DT.Status default 0 -- прямая распаковка шаблонов строки без справочника
)
return DT.Text as
   sPurpose       DT.Text;
   recDeal        Deal%rowtype;
   recDocTree     DocTree%rowtype;
   recDealReserv  DealReserv%rowtype;
   recDealROLL    Deal%rowtype;
   recDealDeposit DealDeposit%rowtype;
   recDealNetting DealNetting%rowtype;
   recDealTrans   DealTransaction%rowtype;
   recDocTreeCL   DocTree%rowtype;
   recDealCL      Deal%rowtype;
   --
   sCurrTag       Dt.Text;
   sDTFMT         constant Dt.Label := 'DD/MM/YYYY';
   sDTFMT1        constant Dt.Label := 'DD.MM.YY';
   dtDateTemp     Date;
   --
   procedure LoadDealRec as
      cursor c is select * from Deal where Doc = nDeal;
   begin
      if recDeal.Doc is null then
         open c;
         fetch c into recDeal;
         close c;
      end if ;
   end LoadDealRec;
   --
   procedure LoadDocRec as
      cursor c is select * from DocTree where Classified = nDoc;
   begin
      if recDoctree.Classified is null then
         open c;
         fetch c into recDocTree;
         close c;
      end if ;
   end LoadDocRec;
   --
   procedure LoadDealReservRec as
      cursor c is select * from DealReserv where Doc = nDoc;
   begin
      if recDealReserv.Doc is null then
         open c;
         fetch c into recDealReserv;
         close c;
      end if ;
   end LoadDealReservRec;
   --
   procedure LoadDealRollRec as
      cursor c is select * from Deal where Doc =
         (select Deal from DealRollover where Doc = nDeal);
   begin
      if recDealRoll.Doc is null then
         open c;
         fetch c into recDealRoll;
         close c;
      end if ;
   end LoadDealRollRec;
   --
   procedure LoadDealDepositRec as
      cursor c is select * from DealDeposit where Doc = nDeal;
   begin
      if recDealDeposit.Doc is null then
         open c;
         fetch c into recDealDeposit;
         close c;
      end if ;
   end LoadDealDepositRec;
   --
   procedure LoadDealNettingRec as
      cursor c is select * from DealNetting where Doc = nDeal;--nDoc;
   begin
      if recDealNetting.Doc is null then
         open c;
         fetch c into recDealNetting;
         close c;
      end if ;
   end LoadDealNettingRec;
   --
   procedure LoadDealTransRec as
      cursor c is select * from DealTransaction where Doc = nDoc;
   begin
      if recDealTrans.Doc is null then
         open c;
         fetch c into recDealTrans;
         close c;
      end if ;
   end LoadDealTransRec;
   --
   procedure LoadDocCLRec as
      cursor c is select * from DocTree where Classified = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDocTreeCL.Classified is null then
         open c;
         fetch c into recDocTreeCL;
         close c;
      end if ;
   end LoadDocCLRec;
   --
   procedure LoadDealCLRec as
      cursor c is select * from Deal where Doc = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDealCL.Doc is null then
         open c;
         fetch c into recDealCL;
         close c;
      end if ;
   end LoadDealCLRec;
   --
begin
      if nDirectExpand = 1 then
      sPurpose := sTemplateCode;
      else
        begin
        select value into sPurpose from dealpaymentpurpose where fullname =  sTemplateCode;
        exception when NO_DATA_FOUND then
        --raise_application_error(-20000, 'Шаблон не найден. Код ' || sTemplateCode) ;
        tm_proc.RaiseError(42212, sTemplateCode);
        end;
      end if;
--   dbms_output.put_line('1 ' || spurpose);

   sCurrTag := '<DealLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('2 ' || spurpose);

   sCurrTag := '<DealDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDeal.DealDate); --to_char(recDeal.DealDate,'DD.MM.YYYY'));
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT));
   end if ;

--   dbms_output.put_line('3 ' || spurpose);

   sCurrTag := '<ExtraText>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag, sExtraText);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocDescription>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Description);
   end if ;

--   dbms_output.put_line('5 ' || spurpose);

   sCurrTag := '<DocOperDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDocTree.OperDate);
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT));
   end if ;

--   dbms_output.put_line('6 ' || spurpose);

   sCurrTag := '<RiskGroup>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        if recDocTree.Category = 914 then
            LoadDealReservRec;
            sPurpose := replace(sPurpose, sCurrTag, PactRiskGrouplabel(NVL(recDealReserv.RiskGroup, recDealReserv.OldRiskGroup)));
        else
            sPurpose := replace(sPurpose, sCurrTag, '');
        end if;
   end if ;

--   dbms_output.put_line('7 ' || spurpose);

   sCurrTag := '<COUNTERPARTY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDeal.CounterParty));
--dbms_output.put_line('8 ' || spurpose);
   end if ;

   sCurrTag := '<TICKETROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, recDealRoll.Ticket);
--dbms_output.put_line('9 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealRoll.CounterParty));
--dbms_output.put_line('10 ' || spurpose);
   end if ;

   sCurrTag := '<ROLLDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealDepositRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealDeposit.RollOverStartDate,sDTFMT));
--dbms_output.put_line('11 ' || spurpose);
   end if ;


   sCurrTag := '<OPERDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT1));
--dbms_output.put_line('12 ' || spurpose);
   end if ;

   sCurrTag := '<EXTRACT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Extract);
--dbms_output.put_line('13 ' || spurpose);
   end if ;

   sCurrTag := '<TRANSACTDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT1));
--dbms_output.put_line('14 ' || spurpose);
   end if ;

   sCurrTag := '<VALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealNetting.ValueDate,sDTFMT1));
--dbms_output.put_line('15 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYNET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealNetting.CounterParty));
--dbms_output.put_line('16 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARYBANK>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.BeneficiaryBank));
--dbms_output.put_line('17 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.Beneficiary));
--dbms_output.put_line('18 ' || spurpose);
   end if ;

   sCurrTag := '<BEGPROCDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate(nDeal),sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;
   -- дата начала начисления %%
   sCurrTag := '<BEGACCRDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      dtDateTemp := trunc(DealBegProcDate(nDeal)); -- дата последнего начисления %%
      if dtDateTemp > recDeal.ValueDate + 1 then
         dtDateTemp := dtDateTemp + 1;
      else
         dtDateTemp := recDeal.ValueDate + 1;
      end if;
      sPurpose := replace(sPurpose, sCurrTag, to_char(dtDateTemp,sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONAMOUNT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        recDealTrans.Amount);
--dbms_output.put_line('20 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealTrans.ValueDate,sDTFMT));
--dbms_output.put_line('21 ' || spurpose);
   end if ;

   sCurrTag := '<DOCTREEDOCVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDocTree.DocValueDate,sDTFMT));
--dbms_output.put_line('22 ' || spurpose);
   end if ;

    --тикет сделки (Deal.TICKET)
   sCurrTag := '<TICKET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, recDeal.Ticket);
   end if ;

   --кредитная линия по траншу (Deal.CREDITLINE.Label)
   sCurrTag := '<CLLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocCLRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTreeCL.Label);
   end if ;

   --дата начала кредитной линии по траншу (Deal.CREDITLINE.VALUEDATE)
   sCurrTag := '<CLVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealClRec;
        sPurpose := replace(sPurpose, sCurrTag, to_char(recDealCL.ValueDate,sDTFMT));
   end if ;

   --дата начала предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE2>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate2(nDeal),sDTFMT));
   end if ;

   return SUBSTR(sPurpose,1,254);

end DEAL_GetPaymentPurpose;


select dd.interestrate as "%, Ставка", d.valuedate as "c", d.maturitydate as "по" from dealdeposit dd, deal d where dd.doc = /*nDealID --*/221377912
and d.doc = dd.doc and dd.interestrate is not null
union
select rate, min(startdate), max(enddate) from DealSwapInterest where doc = /*nDealID --*/221377912 group by rate order by 1\

select * from DealSwapInterest

select * from account

select * from DEALSWAPPAYMENT where doc = 229203104
delete from DEALSWAPPAYMENT where doc = 229203104 and classified = 1263061945

select * from od.dealam

select * from dealswappayperiod d where interestperiod  = 1263061909

od.FillDealDepPaymentForSave


-- просила Ледовская сделать выходными!!!!!!!!!!!! => сделал на боевой => не забыть при накате календарей                                                  ++
SELECT * from holiday where HolidaySchema = 1200760328 -- USA
insert into Holiday( HolidaySchema, HolidayDate ) values( 1200760328, to_date('06092010','ddmmyyyy'));

insert into Holiday( HolidaySchema, HolidayDate ) values( 1200760328, to_date('18022008','ddmmyyyy'));

SELECT * from holiday where HolidaySchema = 1199945084 -- EUR
insert into Holiday( HolidaySchema, HolidayDate ) values( 1199945084, to_date('03102011','ddmmyyyy'));

ut_dealaccrual
UT_DealAccrual_EveryDayFT_TCB

DealSwapPaymentRS 


    select od.reestrrestout((select rsaccount from dealaccount where doc = 224679515/*nDealID*/ and 
                             account = (select classified from account where code = '47426978150000100092'))
                            , td) from dual


    select od.reestrrestout((select rsaccount from dealaccount where doc = 224535563/*nDealID*/ and 
                             account = (select classified from account where code = '47426978150000000095'))
                            , td) from dual
                            
select * from od.accountwithreestr where account = 174674393
select * from reestr where accountwithreestr = 1255933504
select * from reestrdoc where accountwithreestr = 1255933504

----------------------------------------------------------------------------------
--25/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- запрос для Миши
    select od.reestrrestout((select rsaccount from dealaccount where doc = 224535563/*nDealID*/ and 
                             account = (select classified from account where code = '47426978150000000095'))
                            , td) from dual
                            
select * from doctree where classified = 224535563
select * from doctype where classified = 1179850206
select * from dealaccount where doc = 224535563
select * from doctree where classified = 226289468
select * from doctype where classified = 1000135223

create or replace function ReestrRestOut
--------------------------------------------------------------------------------
-- Назначение: Остаток по документу на реестре
-- Параметры :
--  idInitDoc - документ занесения на реестр
--  dtDate    - дата
--  nType     - тип остатка
-- Версия от : 20/12/99
-- Автор     : А.Коновалов.
--------------------------------------------------------------------------------
(
  idInitDoc in ReestrDoc.Doc%type,
  dtDate    in date,
  nType     in Reestr.Type%type default 1
)
return dt.Amount
as
   nRest dt.Amount;
begin
   select DocSum into nRest
     from Reestr
    where ReestrInit = idInitDoc
      and Type = nType
      and BegDate <= dtDate
      and EndDate > dtDate;
   return nRest;
exception
   when NO_DATA_FOUND then
      return null;
end ReestrRestOut;


select DocSum into nRest
     from Reestr
    where ReestrInit = idInitDoc
      and Type = nType
      and BegDate <= dtDate
      and EndDate > dtDate;
      
      select * from DealSwapInterest 
      
      select * from od.dealrollover w
      select * from deal where doc in (130467844,130335046)
      select * from od.deal where doc in (201752425,201589080)
      
create or replace procedure UT_DealAccrual(
/*******************************************************************************
 Автор: Логинов Д.
 Описание:  Начисление процентов по депозитным сделкам.
            Начисление ведется для сделок в состояниях, к которым привязан экран DEALACCRUAL.
            Создаваемые внутренние переводы становятся дочерними к сделкам.
 Версия:
   06.07.2001 Расчет процентов ведется на заданную дату, а проводка делается на S.YSDATE.
   02.10.2001 Добавлена проверка на c_access.GetFilial, ограничение по датам из сделки.
   10.10.2001 В последний рабочий день месяца начисления делаются с учетом выходных.
   29.09.2004 Для EDO переделан основной запрос.
   08.02.2006 Поправлено условие отбора сделок, верно учитывается состояние документа.
   13.04.2007 Добавлен учет возможного изменения базовой процентной ставки в течение дня.
   30.05.2008 При сдвиге интервала в последний рабочий день месяца учитывается дата окончания сделки.
   06.06.2008 Не начислять проценты по сделкам, которые открыты в день, когда делается начисление.
   03.09.2008 Начисление по сделкам с датой начала = последнему рабочему дню месяца.
   21.05.2009 В зависимости от ключа начисление может осуществляться ежедневно/ежемесячно.
   05.10.2011 Добавлен запуск процедуры логирования. Добавлена блокировка.(Дор.11198, dvp)
   16.03.2012 Блокировка сделок в зависимости от значения параметра nLockMode (зам.37133, tmy).
   06.06.2011 Для депозитов до востребования вместо MaturityDate используется дата расчета (зам.40924, tmy)
   29.06.2012 (Дор. № 10561, AGN)
   05.09.2012 Исправлено вычисление последнего рабочего дня месяца (зам.42331, tmy)
   04.12.2012 для траншей МБК события пересоздаются с даты начала перерасчета %% (Зам. № 44062, AGN)
   16.01.2013 Убран пересчет платежей после расчета процентов по траншам МБК(пересчет выполняется в самом расчете %)(Зам. № 44628, AGN)

   01/08/2013 Панфилов М.С. затирается счет контрагента в событиях сделок траншей МБК поэтому приходится тут его восстанавливать

********************************************************************************/
   dtAccrualDate  date,  -- дата расчета
   nLog           DT.Status default 1,   -- вести логирование 0/1 нет/да
   nLockMode      DT.Status default 1    -- блокировать сделки перед обработкой 0/1 нет/да
) is
   dtToDate       date := trunc(dtAccrualDate);
   dtToDateTemp   date;
   nAllSum        DT.Amount;        -- общая сумма %
   nIsReceive     DT.ConstValue;
   nCurrency      DT.Reference;
   nIsLastDay     DT.Status := 0;
   dtMaturityDate date;
   nJ             DT.Quantity := 0;
   sProcLabel     dt.Description := 'UT_DealAccrual';
   sOperation     DT.Label := 'DealInterestRate';
   sDocLabel      dt.Label;
   sTextMess      dt.Description;
   sCrlf          constant DT.Label := CHR(13)||CHR(10);
   nLockStatus    DT.Status := 0;
   naDeal         DT.ClassType;
   naGenInt       DT.ClassType;
   nLockErr       DT.Status := 0;
   nGenInt932     DT.Reference := Constants.GetGenIntention(932);
   nGenInt933     DT.Reference := Constants.GetGenIntention(933);
   outtransacc901    dealtransaction.beneficiaryaccount%type;
   outtransacc916    dealtransaction.beneficiaryaccount%type;
   nGenInt901     DT.Reference := Constants.GetGenIntention(901); -- событие по процентам
   nGenInt916     DT.Reference := Constants.GetGenIntention(916); -- событие по основной сумме
   cursor curDeals is
   select DT.Classified, DT.GenIntention
     from EntityMethod EM, EntityPropValue EPV, EntityState ES, DocTree DT
    where EM.SQLNAME = 'DEALACCRUAL'
      and EPV.PropValue = EM.Classified and EPV.PropType = 1
      and EPV.EntityState = ES.Classified
      and DT.DocType = ES.EntityClass and Dt.EntityState = ES.Classified
      and DT.SysFilial = c_access.GetFilial
      and exists (select null from Deal
                   where Doc = DT.Classified
                     and ValueDate - nIsLastDay < trunc(dtAccrualDate)
                     and (dtAccrualDate <= MaturityDate or MaturityDate is null)
                     and DealDate <= (select s.ysdate from dual))
      and exists (select null from DealAccount DA, DealAccintention DAI
                   where DA.AccIntention = DAI.Classified
                     and DA.Doc = DT.Classified
                     and DAI.ConstIntention in (17, 18));
   --  разблокировка сделок
   procedure LockReleas(
      naDealIn  DT.ClassType  -- массив сделок
   ) is
   begin
      if naDealIn.count > 0 then
         for n in naDealIn.first..naDealIn.last loop
            teller_proc.lock_release(naDealIn(n));
         end loop;
      end if;
   end LockReleas;
begin
   if dtToDate is null then
      tm_proc.RaiseError(42007);
   end if;

   -- Если \Deal\Deposit\NoDailyAccrual = 1, то начисление производится только в последний день месяца.
   if Registry.GetValue('\Deal\Deposit\NoDailyAccrual') = 1 and dtToDate != PreWorkDay(last_day(dtToDate) + 1) then
      tm_proc.RaiseError(42153);
   end if;
   -- откроем LOG
   Dbl_Log('', '', 0, 3, null, sOperation, sProcLabel, nLog);
   -- в последний рабочий день месяца расширяем интервал до конца месяца
   if DPGeneral.GetIntervalValue(dtToDate, last_day(dtToDate) + 1, 2) <= 1 then
      dtToDate := last_day(dtToDate);
      nIsLastDay := 1;
   end if;
   --
   dtToDateTemp := dtToDate;
   if nLockMode = 1 then
      sTextMess :=  'Блокировка сделок. Дата расчета <'|| to_char(dtAccrualDate, 'dd.mm.yyyy hh24:mi:ss')  || ')';
      Dbl_Log(sTextMess, sTextMess, 35, 3, null, sOperation, sProcLabel, nLog);
   end if;
   for recDeals in curDeals loop
      if nLockMode = 1 then
         -- блокируем сделку
         teller_proc.doc_lock(recDeals.Classified, nLockStatus);
      end if;
      if nLockStatus = 0 then
         nJ := nJ + 1;
         naDeal(nJ) := recDeals.Classified;
         naGenInt(nJ) := recDeals.GenIntention;
      else
         nLockErr := 1;
         sTextMess := 'Не удалось заблокировать сделку ' || DocTreeLabel(recDeals.Classified)||'('||recDeals.Classified||')';
         Dbl_Log(sTextMess, sTextMess, 121, 5, recDeals.Classified, sOperation , sProcLabel, nLog);
         exit;
      end if;
   end loop;
   if nLockMode = 1 then
      Dbl_Log('Блокировка сделок.','Блокировка сделок.', 45, 3, null, sOperation, sProcLabel, nLog);
   end if;
   if nLockErr = 1 or (nLockErr = 0 and nJ = 0) then
      if nLockErr = 1 then
      -- Разблокируем сделки
         LockReleas(naDeal);
      elsif nLockErr = 0 and nJ = 0 then
         sTextMess := 'Не найдено ни одной депозитной сделки на дату <' ||dtToDate|| '>';
         Dbl_Log(sTextMess, sTextMess, 121, 3, null, sOperation, sProcLabel, nLog);
      end if;
   else
      -- сделки заблокированы
      sTextMess := '<Дата расчетов>='|| to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
                   '<Интерв расчетов>='|| to_char(dtToDate, 'dd.mm.yyyy') || sCrlf ||
                   '<Сделок>=' ||nJ;
      Dbl_Log(sTextMess, 'Сформирован  набор из ' || nJ || ' депозитных сделок на дату <' ||dtToDate|| '>',
              35, 101, null, '', sProcLabel, nLog);
      for nJ in naDeal.first..naDeal.last loop
         sTextMess := 'Обработка сделки <' ||DocTreeLabel( naDeal(nJ))||'> (' ||  naDeal(nJ) || ')';
         Dbl_Log(sTextMess, sTextMess,  35, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
         select MaturityDate into dtMaturityDate from Deal where Doc = naDeal(nJ);
         dtToDate := least(dtToDateTemp, nvl(dtMaturityDate, dtToDateTemp));
         nAllSum := null;
         if naGenInt(nJ) in (nGenInt932, nGenInt933) then
            outtransacc901 := null;                                                  -- 01/08/2013 Панфилов М.С. затирается счет контрагента в событиях сделок
            outtransacc916 := null;                                                  -- поэтому приходится тут его восстанавливать
            begin
            select distinct d.beneficiaryaccount into outtransacc901 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = naDeal(nJ) and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt901;
            exception when others then null;
            end;
            begin
            select distinct d.beneficiaryaccount into outtransacc916 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = naDeal(nJ) and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt916;
            exception when others then null;
            end;
            -- пересчет графиков и событий по сделке транша МБК
            DealDep_proc.FillDealDepInterest(naDeal(nJ));
            DealDep_proc.DealDepEvents(naDeal(nJ), dtToDate, null, 2);
            if outtransacc901 is not null then
              update dealtransaction set beneficiaryaccount = outtransacc901 where exists (select * from doctree where parent = naDeal(nJ) and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt901);
            end if;
            if outtransacc916 is not null then
              update dealtransaction set beneficiaryaccount = outtransacc916 where exists (select * from doctree where parent = naDeal(nJ) and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt916);
            end if;
         else
            -- Если изменилась базовая процентная ставка необходимо скорректировать сумму в событиях
            SetDealInterestRate(idDoc => naDeal(nJ) ,
                                nLog => nLog );
         end if;
         CreatePercentAccountDoc(nDoc => naDeal(nJ),
                                 dtDate => dtToDate ,
                                 nAllSum => nAllSum,
                                 nIsReceive => nIsReceive,
                                 nCurrency => nCurrency,
                                 dtOperDate_ => S.YSDATE,
                                 nLog => nLog);
         Dbl_Log(sTextMess, sTextMess, 45, 5, naDeal(nJ), sOperation, sProcLabel, nLog);
      end loop;
      if nLockMode = 1 then
         -- Разблокируем сделки
         LockReleas(naDeal);
      end if;
      Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   end if;
   -- закроем LOG
   Dbl_Log('<Дата расчетов>=' || to_char(dtAccrualDate, 'dd.mm.yyyy') || sCrlf ||
           '<Сделок>=' ||nJ , '', 1, 3, null, sOperation, sProcLabel, nLog);
exception when OTHERS then
   if nLockMode = 1 then
      -- Разблокируем сделки
      LockReleas(naDeal);
   end if;
   Dbl_Log('', '', 45,  3, null, sOperation, sProcLabel, nLog);
   Dbl_Log('', '', 1, 3, null, sOperation, sProcLabel, nLog);
   raise;
end UT_DealAccrual;


----------------------------------------------------------------------------------
--26/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from od.dealtransaction dt where 
doc in (select classified from doctree where parentdoc(classified) =  228926524 and docstate != 1000000037) and doctype in (1047170421,1047177856)

select * from od.dealtransaction dt where 
doc in (select classified from doctree where parentdoc(classified) =  228926524 and docstate = 1000000034) and doctype in (1047170421,1047177856)

select * from od.dealtransaction dt where 
doc in (select classified from doctree where parentdoc(classified) =  228926524 and docstate = 1000000035) and doctype in (1047170421,1047177856)

select * from doctree where classified in (229039857,229039859)

select * from docstate

229288172

(select DSP.* from DealSwapPayment DSP, Doctree DCT             -- 21/12/2012 Панфилов М.С. - тут смотрим только "созданные" события по процентам на даты <= дата расчета
                   where DSP.Doc = 229288172
                     and DSP.Classified = DCT.OperObj
                     and DCT.Parent = DSP.Doc
                     --and DSP.VALUEDATE <= trunc(td)
                     --and DSP.Paymenttype = 0
                     and DCT.DocState = 1000000034)
                     
----------------------------------------------------------------------------------
-- запрос по отчету по траншам МБК для Ледовской IPI 153922                                                                                                       ++
----------------------------------------------------------------------------------
select distinct classified, label from client where classified in (select d.counterparty from dealdeposit dd, deal d, doctree dt 
where dd.doc = dt.classified and d.doc = dt.classified
and dd.istransh = 1 and dt.category = 908) order by 2

select distinct classified, codeisoalph from currency where classified in (select d.currencyb from dealdeposit dd, deal d, doctree dt 
where dd.doc = dt.classified and d.doc = dt.classified
and dd.istransh = 1 and dt.category = 908) order by 2

-- осталось перенести в reporter
-- Ледовская тестит                                                                                                                                               ++
-- доделывал Ромик
select 
rownum num,
ClientLabel(d.counterparty) cli,
getclientcode(d.counterparty,1000104502) code,  
acccode_tcb(da1.account) acc,
d.dealdate, 
round(d.amountb, nvl(MinorUnit(d.currencyb), 2)) summfirst,
currencyiso(d.currencyb) curr,
d.maturitydate - d.valuedate days,
dsi.ntlamount a,
dsi.ntlamount*rate(d.currencyb,1000001275,1000131199,to_date('31072013','ddmmyyyy')/*:dDate*/) b,
dsi.rate + nvl(dsi.spread,0) rate,
d.valuedate c,
d.maturitydate,
round(dsi.interestamount, nvl(MinorUnit(d.currencyb), 2)) d,
dspp.paydate e,
(select paydate from Dealswappayperiod where interestperiod in (select classified from DealSwapInterest where doc = d.doc and enddate = dsi.startdate)) f,
acccode(da2.account) acc2,
case
 when da2.rsaccount is null then accountbalance(da2.account,to_date('31072013','ddmmyyyy')/*:dDate*/)
 when da2.rsaccount is not null then reestrrestout(da2.rsaccount,to_date('31072013','ddmmyyyy')/*:dDate*/)
 else null
end g,
case
 when da2.rsaccount is null then accountbalance(da2.account,to_date('31072013','ddmmyyyy')/*:dDate*/)*rate(d.currencyb,1000001275,1000131199,to_date('31072013','ddmmyyyy')/*:dDate*/)
 when da2.rsaccount is not null then reestrrestout(da2.rsaccount,to_date('31072013','ddmmyyyy')/*:dDate*/)*rate(d.currencyb,1000001275,1000131199,to_date('31072013','ddmmyyyy')/*:dDate*/)
 else null
end j,
(select min(valuedate) from od.dealswappayment where doc = d.doc and paymenttype in (1,4) and valuedate > to_date('31072013','ddmmyyyy')/*:dDate*/ ) - to_date('31072013','ddmmyyyy')/*:dDate*/ k,
dspp.paydate - to_date('31072013','ddmmyyyy')/*:dDate*/ l,
case 
 when dd.periodtype = 0 then 'ежедневно'
 when dd.periodtype = 1 then dd.periodvalue || ' недель'
 when dd.periodtype = 2 then dd.periodvalue || ' месяцев'
 when dd.periodtype = 3 then dd.periodvalue || ' кварталов'
 when dd.periodtype = 4 then dd.periodvalue || ' лет'
 when dd.periodtype = 5 then 'в конце срока'
 else null
end periodproc,
case 
 when dd.periodtypeamort = 0 and dd.isamortization = 1 then 'ежедневно'
 when dd.periodtypeamort = 1 and dd.isamortization = 1 then dd.periodvalueamort || ' недель'
 when dd.periodtypeamort = 2 and dd.isamortization = 1 then dd.periodvalueamort || ' месяцев'
 when dd.periodtypeamort = 3 and dd.isamortization = 1 then dd.periodvalueamort || ' кварталов'
 when dd.periodtypeamort = 4 and dd.isamortization = 1 then dd.periodvalueamort || ' лет'
 when dd.periodtypeamort = 5 and dd.isamortization = 1 then 'в конце срока'
 else null
end periodosn,
(select sum(interestamount) from DealSwapInterest where doc = dd.doc and to_date('31072013','ddmmyyyy')/*:dDate*/ <= enddate)
-
case
 when da2.rsaccount is null then accountbalance(da2.account,to_date('31072013','ddmmyyyy')/*:dDate*/)
 when da2.rsaccount is not null then reestrrestout(da2.rsaccount,to_date('31072013','ddmmyyyy')/*:dDate*/)
 else null
end m,
(select label from doctree where classified = d.pact) n
from dealdeposit dd, deal d, doctree dt, dealaccount da1, dealaccount da2, DealSwapInterest dsi, Dealswappayperiod dspp 
where dd.doc = dt.classified and d.doc = dt.classified and d.doc = dsi.doc and dsi.classified = dspp.interestperiod 
and da1.doc = d.doc and da2.doc = d.doc
and dd.istransh = 1 and dt.category = 908
and dt.docstate != 1000000037 
and da1.accintention in (1000105424,1000105425)
and da2.accintention in (1000105426,1000105427)
and to_date('31072013','ddmmyyyy')/*:dDate*/ > dsi.startdate and to_date('31072013','ddmmyyyy')/*:dDate*/ <= dsi.enddate


select 
rownum num,
ClientLabel(d.counterparty) cli,
getclientcode(d.counterparty,1000104502) code, 
acccode_tcb(da1.account) acc,
d.dealdate, 
round(d.amountb, nvl(MinorUnit(d.currencyb), 2)) summfirst,
currencyiso(d.currencyb) curr,
d.maturitydate - d.valuedate days,
null a,
null b,
dsi.rate + nvl(dsi.spread,0) rate,
null c,
d.maturitydate,
null d,
null e,
null f,
acccode(da2.account) acc2,
null g,
null j,
null k,
null l,
case 
when dd.periodtype = 0 then 'ежедневно'
when dd.periodtype = 1 then dd.periodvalue || ' недель'
when dd.periodtype = 2 then dd.periodvalue || ' месяцев'
when dd.periodtype = 3 then dd.periodvalue || ' кварталов'
when dd.periodtype = 4 then dd.periodvalue || ' лет'
when dd.periodtype = 5 then 'в конце срока'
else null
end periodproc,
case 
when dd.periodtypeamort = 0 and dd.isamortization = 1 then 'ежедневно'
when dd.periodtypeamort = 1 and dd.isamortization = 1 then dd.periodvalueamort || ' недель'
when dd.periodtypeamort = 2 and dd.isamortization = 1 then dd.periodvalueamort || ' месяцев'
when dd.periodtypeamort = 3 and dd.isamortization = 1 then dd.periodvalueamort || ' кварталов'
when dd.periodtypeamort = 4 and dd.isamortization = 1 then dd.periodvalueamort || ' лет'
when dd.periodtypeamort = 5 and dd.isamortization = 1 then 'в конце срока'
else null
end periodosn,
null m,
null n
from dealdeposit dd, deal d, doctree dt, dealaccount da1, dealaccount da2, DealSwapInterest dsi 
where dd.doc = dt.classified and d.doc = dt.classified and d.doc = dsi.doc 
and da1.doc = d.doc and da2.doc = d.doc
and dd.istransh = 1 and dt.category = 908
and dt.docstate != 1000000037 
and da1.accintention in (1000105424,1000105425)
and da2.accintention in (1000105426,1000105427)
and :DT > dsi.startdate and :DT <= dsi.enddate


select 
rownum num,
ClientLabel(d.counterparty) cli,
getclientcode(d.counterparty,1000104502) code,  
acccode_tcb(da1.account) acc,
d.dealdate, 
round(d.amountb, nvl(MinorUnit(d.currencyb), 2)) summfirst,
currencyiso(d.currencyb) curr,
d.maturitydate - d.valuedate days,
dsi.ntlamount a,
dsi.ntlamount*rate(d.currencyb,1000001275,1000131199,:DT) b,
dsi.rate + nvl(dsi.spread,0) rate,
d.valuedate c,
d.maturitydate,
round(dsi.interestamount, nvl(MinorUnit(d.currencyb), 2)) d,
dspp.paydate e,
(select paydate from Dealswappayperiod where interestperiod in (select classified from DealSwapInterest where doc = d.doc and enddate = dsi.startdate)) f,
acccode(da2.account) acc2,
case
 when da2.rsaccount is null then accountbalance(da2.account,:DT)
 when da2.rsaccount is not null then reestrrestout(da2.rsaccount,:DT)
 else null
end g,
case
 when da2.rsaccount is null then accountbalance(da2.account,:DT)*rate(d.currencyb,1000001275,1000131199,:DT)
 when da2.rsaccount is not null then reestrrestout(da2.rsaccount,:DT)*rate(d.currencyb,1000001275,1000131199,:DT)
 else null
end j,
(select min(valuedate) from od.dealswappayment where doc = d.doc and paymenttype in (1,4) and valuedate > :DT ) - :DT k,
dspp.paydate - :DT l,
case 
 when dd.periodtype = 0 then 'ежедневно'
 when dd.periodtype = 1 then dd.periodvalue || ' недель'
 when dd.periodtype = 2 then dd.periodvalue || ' месяцев'
 when dd.periodtype = 3 then dd.periodvalue || ' кварталов'
 when dd.periodtype = 4 then dd.periodvalue || ' лет'
 when dd.periodtype = 5 then 'в конце срока'
 else null
end periodproc,
case 
 when dd.periodtypeamort = 0 and dd.isamortization = 1 then 'ежедневно'
 when dd.periodtypeamort = 1 and dd.isamortization = 1 then dd.periodvalueamort || ' недель'
 when dd.periodtypeamort = 2 and dd.isamortization = 1 then dd.periodvalueamort || ' месяцев'
 when dd.periodtypeamort = 3 and dd.isamortization = 1 then dd.periodvalueamort || ' кварталов'
 when dd.periodtypeamort = 4 and dd.isamortization = 1 then dd.periodvalueamort || ' лет'
 when dd.periodtypeamort = 5 and dd.isamortization = 1 then 'в конце срока'
 else null
end periodosn,
(select sum(interestamount) from DealSwapInterest where doc = dd.doc and :DT <= enddate)
-
case
 when da2.rsaccount is null then accountbalance(da2.account,:DT)
 when da2.rsaccount is not null then reestrrestout(da2.rsaccount,:DT)
 else null
end m,
(select label from doctree where classified = d.pact) n
from dealdeposit dd, deal d, doctree dt, dealaccount da1, dealaccount da2, DealSwapInterest dsi, Dealswappayperiod dspp 
where dd.doc = dt.classified and d.doc = dt.classified and d.doc = dsi.doc and dsi.classified = dspp.interestperiod 
and da1.doc = d.doc and da2.doc = d.doc
and dd.istransh = 1 and dt.category = 908
and dt.docstate != 1000000037 
and da1.accintention in (1000105424,1000105425)
and da2.accintention in (1000105426,1000105427)
and :DT > dsi.startdate and :DT <= dsi.enddate






select dd.interestrate as "%, Ставка", d.valuedate as "c", d.maturitydate as "по" from dealdeposit dd, deal d where dd.doc = /*nDealID --*/221377912
and d.doc = dd.doc and dd.interestrate is not null
union
select rate, min(startdate), max(enddate) from DealSwapInterest where doc = /*nDealID --*/227691106 group by rate order by 1
select * from DealSwapInterest where doc = /*nDealID --*/224813879 
select * from Dealswappayperiod where interestperiod in (select classified from DealSwapInterest where doc = /*nDealID --*/224880232 )
select * from preference

select * from dealaccount where doc = 217724905
select * from dealaccintention
select * from DealSwapInterest
select * from od.dealswappayment where doc = 224880232
select od.period_to_char_tcb from 
select * from dealdeposit where doc = 217651091
select * from deal where doc = 217651091
select * from doctree where classified = 217642130
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--27/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

   procedure CreateDepSheduleOfPayments(
   /******************************************************************************
    Автор:    Шубин Р.
    Описание: Создать график платежей на основе графика процентов.
    Версия:   17.04.2012
              08.06.2012 AGN
              04.12.2012 - учтен расчет подробностей без округления (Зам. № 44099, AGN)
              16.01.2013
              --28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
   *****************************************************************************/
      idDoc    DT.Reference,       -- документ.
      nInit    DT.Status default 1 -- инициализация переменных
   ) as
      idPaymentLine   DT.Reference;                  --
      nAmountPay      DT.Amount;
   begin
      if nvl(nInit, 1) = 1 then
         InitVariables(idDoc);
      end if;
      -- выплаты по процентам:
      -- nSign := i.f(recDealDep.IsReceive = 1, -1, 1);
--28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
for recDSI in
         (
            select sum(P.AMOUNT) Amount, P.PayDate InterestDate, NTLCurrency,
                   P.PaymentLine
              from DealSwapInterest DSI, DealSwapPayPeriod P
             where DSI.Doc = idDoc
               and P.InterestPeriod = DSI.Classified
          group by P.PaymentLine, P.PayDate, NTLCurrency
         )
      loop
         nAmountPay :=  round(recDSI.Amount, nvl(MinorUnit(recDSI.NTLCurrency), 2));
         update DealSwapPayment
            set Amount = nAmountPay,
                Currency = recDSI.NTLCurrency,
                IsNetting = recDeal.IsNetting
          where Doc = idDoc and Classified = recDSI.PaymentLine;
         if sql%notfound then
            insert into DealSwapPayment (Doc, ValueDate, Currency, Amount,
                                          PaymentType, IsNetting, NettAmount)
               values (idDoc, recDSI.InterestDate, recDSI.NTLCurrency, nAmountPay,
                        nPaymentType_Interest, 0, null)
               returning Classified into idPaymentLine;
            update DealSwapPayPeriod
               set PaymentLine = idPaymentLine
             where PayDate = recDSI.InterestDate
               and InterestPeriod in (select Classified from DealSwapInterest
                                       where NTLCurrency = recDSI.NTLCurrency
                                         and Doc = idDoc);
         end if;
      end loop;
      -- основные суммы + амортизация.
      GeneralAmountExchange;
      -- перенумерация платежей.
      ReCalculateSheduleOfPayments(idDoc);
   end CreateDepSheduleOfPayments;


 select * from ENUMTYPEVALUE where classified in (select ENUMTYPEVALUE from OBJENUM where enumtype = (select classified from enumtype where constenum = -5000))
 select * from ObjProp
 select * from OBJENUM 
 select * from proplist
od.DPC_FillDealDepInterest

select 500000*0.1725*(10/365) from dual
select 500000*0.1725*(30/365) from dual

select * from doctree where classified in (225780956,225780957)
select * from docstate
select * from entitystate where entityclass = 1047170421
update doctree set docstate = 1000000039, entitystate = 1047409254, parent = null where classified in (225780956,225780957)
update doctree set docstate = 1000000035, entitystate = 1047170430, parent = 225776003 where classified in (225780956,225780957)

select od.GetIntervalDate(to_date('28/01/2013','dd/mm/yyyyy'), 6, 0, 27) from dual
select od.DPGeneral.FirstFixedDay(to_date('26/01/2013','dd/mm/yyyy'), 6, 1, null, 27) from dual
----------------------------------------------------------------------------------
--28/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
-- прогнать на боевой (deal1158.sql deal1178.sql deal1180.sql - это не надо) deal1183.sql (не забыть вернуть od.dealdep_proc.CreateDepSheduleOfPayments)     ++
-- поправить временно od.dealdep_proc.CalculateAmortSchedule !!-2!! на боевой (пересчитать %% графики на COMMERZ и 2 ЕБРР) => 28/08/2013 написал в НА в рамках
-- замечания 48032 => ждем официального исправления => 05/09/2013 прислали deal1190.sql !!! => тестим на diling => 03/10/2013 накатил на боевой              ++
----------------------------------------------------------------------------------
--30/08/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified in (230164011,230168357)

select * from doctype where classified in( 1047625339,1000161094)
select * from doctree where classified = 230163787
select * from doctree where classified = 223720478

----------------------------------------------------------------------------------
--16/09/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


select * from DealSwapInterest where doc = 224807407
-- закрываем транш с COBA на 1000 => осталось только исполнить Ледовской                                                                                 ++
select * from DealSwapInterestLog where doc = 224807407 and paydoc = 230442095
delete from DealSwapInterestLog where doc = 224807407 and paydoc = 230442095
-- +1 день в назначениях платежа по начислению % по траншам МБК                                                                                          ++
---- накатить на боевой                                                                                                                                  ++ 
create or replace function DealBegProcDate(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления предыдущей даты начисления процентов по депозитной сделке.
-- Автор: Цветков В.
-- Версия: 14.04.2011
--         10.06.2013 адаптирована для сделок траншей МБК (Зам. № 46876)
--         03/07/2013 Панфилов М.С. - теперь учтен вариант, когда начислений процентов ещё не было.
--         17/09/2013 Панфилов М.С. - для траншей МБК, когда начисления процентов уже были, + 1 день.
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference  -- идентификатор сделки
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null then
      --это не депозитная сделка
      return null;
   end if;
   --
   if nIsTransh = 1 then
      -- последняя дата учета процентов по сделке.
      select nvl(max(ds.OperDate)+1,d.valuedate) into dtPercbegdate
        from DealSwapInterestLog ds, deal d
      where d.Doc = nDoc and d.doc = ds.doc(+) group by d.valuedate;
   else
      select DA.Account,DA.rsAccount
        into nAccount,nRSAccount
        from DealAccount DA, DealAccIntention DAI
       where DA.Doc = nDoc
         and DA.AccIntention = DAI.Classified
         and DAI.ConstIntention = decode(nIsReceive, 1, 18, 17);
      --
      if nRSAccount is null then
         select max(BegDate) into dtPercbegdate
           from Balance
          where Account = nAccount
            and EndDate > dtStartdealdate
            and Type = 1
            and EndTurn = 0
            and trunc(BegDate) < trunc(EndDate);
           -- order by EndDate ASC;
      else
         select max(BegDate) into dtPercbegdate
           from Reestr
          where ReestrInit = nRSAccount
            and EndDate > dtStartdealdate
            and Type = 1
            and trunc(BegDate) < trunc(EndDate);
      end if;
   end if;
   return dtPercBegDate;
end DealBegProcDate;

-- выровнять реестры по ЕБРР и АКА                                                                                                                       ++
---- накатить на боевой                                                                                                                                  ++   
-- ЕБРР      
select * from account where code = '47426840300000100093'
select * from od.accountwithreestr where account = 144976839
select * from reestr where accountwithreestr = 1252214617
select * from reestrdoc where accountwithreestr = 1252214617
--++++
delete reestr where reestrinit not in (229203162,229205122) and accountwithreestr = 1252214617;                                                                          -- удаляем лишние занесения на реестр 
delete reestrdoc where ((reestrinit not in (229203162,229205122) or reestrinit is null) and classified not in (229203162,229205122)) and accountwithreestr = 1252214617; -- удаляем лишние занесения на реестр

select * from account where code = '47426840900001000084'
select * from od.accountwithreestr where account = 75286590
select * from reestr where accountwithreestr = 1268216442
select * from reestrdoc where accountwithreestr = 1268216442
--++++
delete reestr where docsum <> 0 and accountwithreestr = 1268216442;                                                             -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 0 where doc = 231384819 and accountwithreestr = 1268216442;                                       -- изменяем сумму в занесении
update reestrdoc set docsum = 0, initdoc = 229288172 where doc = 231384777 and accountwithreestr = 1268216442;                  -- изменяем сумму в занесении
delete reestrdoc where doc not in (231384819,231384777) and accountwithreestr = 1268216442;                                     -- удаляем лишние занесения на реестр
update dealaccount set rsaccount = 231384819 where doc = 229293858 and account = 75286590; 
update dealaccount set rsaccount = 231384777 where doc = 229288172 and account = 75286590; 
select * from dealaccount where doc in (229293858,229288172)

select * from account where code = '47426840700001002143'
select * from od.accountwithreestr where account = 217903119
select * from reestr where accountwithreestr = 1252217790
select * from reestrdoc where accountwithreestr = 1252217790

------------------------------------------------------------------ реестры для срочных сделок
select * from account where code like '93307752%00056'
select * from od.accountwithreestr where account = 100488548
select * from reestr where accountwithreestr = 1280015560
select * from reestrdoc where accountwithreestr = 1280015560

select * from account where code like '96307840300000000056'
select * from od.accountwithreestr where account = 36478133
select * from reestr where accountwithreestr = 1099979796
select * from reestrdoc where accountwithreestr = 1099979796

update reestrdoc set initdoc = 236004916 where accountwithreestr = 1280015560
update reestr set begdate = td-4 where accountwithreestr = 1280015560

select rowid, d.* from doctree d where classified = 236440235
select * from doctree where classified = 236083668
select * from doctype where classified = 1000135223
-----------------------------------------------------------------






--++++
update reestr set docsum = 36303.84 where reestrinit = 230117985 and docsum != 0 and accountwithreestr = 1252217790; -- изменяем сумму в занесении на реестр 31/08
delete reestr where reestrinit in (224494446,226178995) and accountwithreestr = 1252217790;                          -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 36303.84 where doc = 230552481 and accountwithreestr = 1252217790;                     -- изменяем сумму в занесении на реестр 31/08
delete reestrdoc where doc in (224494446,226178995) and accountwithreestr = 1252217790;                              -- удаляем лишние занесения на реестр

select * from account where code = '47426978950001001743'
select * from od.accountwithreestr where account = 169603586
select * from reestr where accountwithreestr = 1252213870
select * from reestrdoc where accountwithreestr = 1252213870
--++
delete reestr where reestrinit not in (230116012) and accountwithreestr = 1252213870;                          -- удаляем лишние занесения на реестр 
delete reestrdoc where doc not in (230116012,230552488) and accountwithreestr = 1252213870;                    -- удаляем лишние занесения на реестр

-- АКА
select * from account where code = '47426978700001000062'
select * from od.accountwithreestr where account = 56677199
select * from reestr where accountwithreestr = 1264927242
select * from reestrdoc where accountwithreestr = 1264927242
--++++
update reestr set docsum = 1080.14+4181.19 where reestrinit = 229993647 and docsum != 0 and accountwithreestr = 1264927242; -- изменяем сумму в занесении на реестр 31/08
update reestr set docsum = 1986.16+7688.36 where reestrinit = 229990588 and docsum != 0 and accountwithreestr = 1264927242; -- изменяем сумму в занесении на реестр 31/08
delete reestr where reestrinit in (230081472,230081792) and accountwithreestr = 1264927242;                                 -- удаляем лишние занесения на реестр 
update reestrdoc set docsum = 1080.14+4181.19 where doc = 230552425 and accountwithreestr = 1264927242;                     -- изменяем сумму в занесении на реестр 31/08
update reestrdoc set docsum = 1986.16+7688.36 where doc = 230552443 and accountwithreestr = 1264927242;                     -- изменяем сумму в занесении на реестр 31/08
delete reestrdoc where doc in (230081472,230081792) and accountwithreestr = 1264927242;                                     -- удаляем лишние занесения на реестр


select * from doctree where classified in (228783142, 230442095)

od.DealDepPaymentRS
od.dealdep_proc
----------------------------------------------------------------------------------
--17/09/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- убрать из bbr.BBR_TCB_BILL_BUY_AGR (bbr.BBR_TCB_BILL_BUY_AGREEMENT,BBR_TCB_BILL_BUY_AGREEMENTDISC,BBR_TCB_BILL_BUY_AGREEMENTPROC,BBR_TCB_BILL_BUY_AGREEMENTVAL)
-- счета 525* (просила Герасимова)                                                                                                                                  ++
         AND od.acccode_tcb(ba.account) not like '525%' /* 17/09/2013 Панфилов М.С. */

----------------------------------------------------------------------------------
--19/09/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проблема с od.DPC_BillSumCorrectionDisc_TCB и DPC_BillSumCorrection_TCB  у Епановой (в выдачи записывались суммы из досрочных погашений)                         ++
---- поправить od.DPC_BillSumCorrectionDisc_TCB и DPC_BillSumCorrection_TCB                                                                                         ++
---- проапдейтить update BillRange set rowprice = psum where bill = rec.bill по всем досрочным погашениям с 25/07/2013                                              ++
od.DPC_BillSumCorrectionDisc_TCB
od.DPC_BillSumCorrection_TCB
select * from filial
-- (1) ГО
update BillRange set rowprice = 10000000, percentsum = null where bill = 1258041085 and doc = 226972296

select * from BillRange where doc = 226972296
-- (2) Пермь
update BillRange set rowprice = 1288000 where bill = 1251296630 and doc = 224042384
update BillRange set rowprice = 2546141 where bill = 1237820956 and doc = 218197029
update BillRange set rowprice = 6230985 where bill = 1249256326 and doc = 223113461
update BillRange set rowprice = 200000 where bill = 1251296892 and doc = 224042384
update BillRange set rowprice = 1047655.18 where bill = 1249254825 and doc = 223113461
update BillRange set rowprice = 1100178.90 where bill = 1251301428 and doc = 224044633
update BillRange set rowprice = 500000 where bill = 1252957136 and doc = 224833550
update BillRange set rowprice = 500000 where numfrom = '0030163' and doc = 224833550
update BillRange set rowprice = 300000 where bill = 1249256213 and doc = 223113461
update BillRange set rowprice = 217289.36 where bill = 1256894724 and doc = 226530987
update BillRange set rowprice = 320781.09 where bill = 1256894772 and doc = 226530987
update BillRange set rowprice = 200000 where bill = 1247575120 and doc = 222358956
update BillRange set rowprice = 2000000 where bill = 1257496460 and doc = 226709667
update BillRange set rowprice = 1000000 where bill = 1252957082 and doc = 224833550
update BillRange set rowprice = 3000000 where numfrom = '0030172' and doc = 225889111
update BillRange set rowprice = 6230985 where bill = 1256894488 and doc = 226708805
update BillRange set rowprice = 1000000 where numfrom = '0030295' and doc = 226709667
update BillRange set rowprice = 973000 where bill = 1249265844 and doc = 223122134
update BillRange set rowprice = 158000 where bill = 1258277121 and doc = 227095284
update BillRange set rowprice = 1250000 where bill = 1258276826 and doc = 227095284
update BillRange set rowprice = 400000 where bill = 1258277018 and doc = 227095284
update BillRange set rowprice = 173686.01 where bill = 1258745089 and doc = 227318078
update BillRange set rowprice = 72904 where bill = 1258744834 and doc = 227318078
update BillRange set rowprice = 600000 where bill = 1258744707 and doc = 227318078
update BillRange set rowprice = 462977.37 where bill = 1256894753 and doc = 226530987
update BillRange set rowprice = 1000000 where numfrom = '0030178' and doc = 225889111
update BillRange set rowprice = 1000000 where bill = 1258744571 and doc = 227318078
update BillRange set rowprice = 319294.1 where bill = 1242384415 and doc = 220140826
update BillRange set rowprice = 700000 where bill = 1260044536 and doc = 227893333
update BillRange set rowprice = 120000 where bill = 1260045338 and doc = 227893333
update BillRange set rowprice = 222076 where bill = 1258745006 and doc = 227318078
update BillRange set rowprice = 5000000 where numfrom = '0030182' and doc = 225889111
update BillRange set rowprice = 510000 where bill = 1260044901 and doc = 227893333
update BillRange set rowprice = 337000 where bill = 1251296779 and doc = 224042384
update BillRange set rowprice = 1350000 where bill = 1260044069 and doc = 227893333
update BillRange set rowprice = 300000 where numfrom = '0030165' and doc = 224833550
update BillRange set rowprice = 800000 where bill = 1260044449 and doc = 227893333
update BillRange set rowprice = 2000000 where numfrom = '0030319' and doc = 227893333
update BillRange set rowprice = 3000000 where bill = 1257496433 and doc = 226709667
update BillRange set rowprice = 809981 where bill = 1261745477 and doc = 228609639
update BillRange set rowprice = 609591 where bill = 1261746677 and doc = 228609639
update BillRange set rowprice = 400000 where bill = 1247575512 and doc = 222358956
update BillRange set rowprice = 95000 where bill = 1247575542 and doc = 222358956
update BillRange set rowprice = 1340762.44 where bill = 1261747651 and doc = 228609639
update BillRange set rowprice = 500000 where numfrom = '0030330' and doc = 227893333
update BillRange set rowprice = 6200000 where bill = 1261574826 and doc = 228523252
update BillRange set rowprice = 1300000 where bill = 1261574899 and doc = 228523252
update BillRange set rowprice = 410434.15 where bill = 1261747136 and doc = 228609639
update BillRange set rowprice = 10000000 where numfrom = '0030180' and doc = 225889111
update BillRange set rowprice = 500000 where numfrom = '0030234' and doc = 225937662
update BillRange set rowprice = 340000 where bill = 1261576279 and doc = 228523252
update BillRange set rowprice = 450000 where bill = 1261576173 and doc = 228523252
update BillRange set rowprice = 500000 where numfrom = '0030254' and doc = 225937662
update BillRange set rowprice = 500000 where numfrom = '0030264' and doc = 225937662
update BillRange set rowprice = 500000 where numfrom = '0030244' and doc = 225937662
update BillRange set rowprice = 500000 where numfrom = '0030274' and doc = 225937662
update BillRange set rowprice = 142405.84 where bill = 1263134426 and doc = 229240600
update BillRange set rowprice = 115512.79 where bill = 1263128449 and doc = 229240600
update BillRange set rowprice = 100000 where bill = 1253227715 and doc = 224961516
update BillRange set rowprice = 900000 where bill = 1247575488 and doc = 222358956
update BillRange set rowprice = 700000 where bill = 1263621739 and doc = 229399220
update BillRange set rowprice = 500000 where bill = 1261575961 and doc = 228523252
update BillRange set rowprice = 100000 where numfrom = '0030358' and doc = 228523252
update BillRange set rowprice = 100000 where numfrom = '0030348' and doc = 228523252
update BillRange set rowprice = 1500000 where bill = 1251301199 and doc = 224044633
update BillRange set rowprice = 500000 where bill = 1258276977 and doc = 227095284
update BillRange set rowprice = 4351370.33 where bill = 1261131271 and doc = 228348304
update BillRange set rowprice = 632412.74 where bill = 1258744204 and doc = 227318078
update BillRange set rowprice = 1267108.78 where bill = 1261748043 and doc = 228609639
update BillRange set rowprice = 500000 where numfrom = '0030413' and doc = 229100031
update BillRange set rowprice = 500000 where numfrom = '0030403' and doc = 229100031
update BillRange set rowprice = 500000 where numfrom = '0030383' and doc = 229100031
update BillRange set rowprice = 500000 where numfrom = '0030393' and doc = 229100031
update BillRange set rowprice = 500000 where numfrom = '0030443' and doc = 229100031
update BillRange set rowprice = 1200000 where bill = 1257496489 and doc = 226709667
update BillRange set rowprice = 1200000 where bill = 1263621639 and doc = 229399220
update BillRange set rowprice = 2000000 where bill = 1265226872 and doc = 230136430
update BillRange set rowprice = 300000 where bill = 1265226885 and doc = 230136430
update BillRange set rowprice = 360000 where bill = 1258277046 and doc = 227095284
update BillRange set rowprice = 1000000 where bill = 1263678654 and doc = 229432483
update BillRange set rowprice = 1000000 where numfrom = '0030496' and doc = 229432483
update BillRange set rowprice = 1000000 where numfrom = '0030486' and doc = 229432483
update BillRange set rowprice = 2000000 where numfrom = '0030483' and doc = 229432483
update BillRange set rowprice = 143500 where bill = 1253227392 and doc = 224961516
update BillRange set rowprice = 6230985 where bill = 1266375468 and doc = 230483519
update BillRange set rowprice = 1130000 where bill = 1267885473 and doc = 231219642
update BillRange set rowprice = 4000000 where bill = 1267885407 and doc = 231219642
update BillRange set rowprice = 300000 where bill = 1263133307 and doc = 229240600
update BillRange set rowprice = 1000000 where bill = 1260044140 and doc = 227893333
update BillRange set rowprice = 1702791.16 where bill = 1266374389 and doc = 230483519
update BillRange set rowprice = 150000 where bill = 1263621962 and doc = 229399220
update BillRange set rowprice = 1400000 where bill = 1268745169 and doc = 231621953
update BillRange set rowprice = 71000 where bill = 1268745548 and doc = 231621953
update BillRange set rowprice = 100000 where numfrom = '0030137' and doc = 224042384
update BillRange set rowprice = 169000 where bill = 1268745494 and doc = 231621953
update BillRange set rowprice = 700000 where bill = 1268745306 and doc = 231621953
update BillRange set rowprice = 770000 where bill = 1268745222 and doc = 231621953
update BillRange set rowprice = 2000000 where bill = 1268744909 and doc = 231621953
update BillRange set rowprice = 1000000 where bill = 1268745023 and doc = 231621953
update BillRange set rowprice = 211000 where bill = 1268745043 and doc = 231621953
update BillRange set rowprice = 1329340 where bill = 1239717783 and doc = 218939039
update BillRange set rowprice = 120000 where bill = 1258277171 and doc = 227095284
update BillRange set rowprice = 700000 where bill = 1270832499 and doc = 232592089
update BillRange set rowprice = 215961.33 where bill = 1270835218 and doc = 232592999
update BillRange set rowprice = 100000 where bill = 1270832696 and doc = 232592089
update BillRange set rowprice = 1300000 where bill = 1270832389 and doc = 232592089
update BillRange set rowprice = 69000 where bill = 1270834825 and doc = 232592999
select * from BillRange where doc = 224833550
select * from BillRange where doc = 225889111
select * from BillRange where doc = 226709667
select * from BillRange where doc = 227893333
select * from BillRange where doc = 225937662
select * from BillRange where doc = 228523252
select * from BillRange where doc = 229100031
select * from BillRange where doc = 229432483
select * from BillRange where doc = 224042384
-- (4) Питер
select * from bill where num = '0023836' 
update BillRange set rowprice = 6000000, percentsum = null where bill = 1255439344 and doc = 226006042
update BillRange set rowprice = 150000 where numfrom = '0023827' and doc = 222857462
update BillRange set rowprice = 350000 where numfrom = '0023829' and doc = 222857462
update BillRange set rowprice = 400000 where numfrom = '0023830' and doc = 222857462
update BillRange set rowprice = 450000 where numfrom = '0023832' and doc = 222857462
update BillRange set rowprice = 550000 where numfrom = '0023834' and doc = 222857462
update BillRange set rowprice = 20000000, percentsum = null where numfrom = '0023847' and doc = 225814083
update BillRange set rowprice = 500000, percentsum = null where bill = 1251565820 and doc = 224178096

select * from BillRange where doc = 222857462
select * from BillRange where doc = 225814083
select * from BillRange where doc = 226006042
select * from BillRange where doc = 224178096
--
select * from BillRange where doc = 226912314
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--20/09/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from BillRange where doc = 233274627
select * from billsum where bill = 1236227343

od.FUNC_BILL_ACCRUALADD_TCB

select trim(OD.desctext)
              from objdesc OD, desclist DL
              where OD.doc = 233274627
              and OD.description = DL.classified
              and DL.constdesc = -1370

select 2955000*0.025*(20/365), 2955000*0.025*((30-5+31+31+20)/365), 2955000*0.035*(20/365), 2955000*0.035*((30-5+31+31+20)/365), 2955000*0.04*(20/365), 2955000*0.04*((30-5+31+31+20)/365) from dual
select 34326.57 - 21454.10 from dual

-- снова проблемы с IPI 130215                                                                                                                          ++
-- поправил одну проводку по досрочному погашению процентных векселей по новой ставке досрочного погашения (если начисленные %% >= ранее начисленных, 
-- то теперь используем тоже сумму FUNC_Bill_AccrualAdd_TCB)                                                                                            ++  
-- по письму Калашниковой от 05/08/2013 поправил одну проводку по досрочному погашению процентных векселей по новой ставке досрочного погашения (если 
-- начисленные %% < ранее начисленных, то теперь возврат идет на счет расходов                                                                          ++
-- остался только вопрос с процентными векселями, выданными в прошлых годах. по таким векселям проценты должны возвращаться на счет доходов 
-- + еще Филимонова просила настроить доначисление процентов по новой ставке всегда, а затем уже возврщать на расходы/доходы (письмо от 20/09/2013) =>     
-- => отписала в задачу 130215 =>                                                                                                                         +++
---- сделать новый тип суммы FUNC_Bill_AccrualAdd_TM_TCB (ТКБ: Сумма доначисления %% за текущий месяц по векселю (доср.пог)))                             +++
---- добавить проводку на сумму FUNC_Bill_AccrualAdd_TM_TCB (Доначисление %% за текущий месяц по ставке досрочного учета Кр-т 52501 Д-т 70606810…21804…)  +++
---- написать BillDPPercentSum_TCB2                                                                                                                       +++
---- сделать два новых типа суммы FUNC_Bill_AccrualReturn_TL_TCB, FUNC_Bill_AccrualReturn_TY_TCB                                                          +++
---- настроить две проводки                                                                                                                               +++
FUNC_BILL_NEWPERCENT
od.FUNC_BILL_ACCRUALADD
od.FUNC_Bill_AccrualAdd_TCB

create or replace function FUNC_Bill_AccrualAdd_TM_TCB
/******************************************************************************
 Описание: Функция возвращает сумму процентов для доначисления по векселю ЗА ТЕКУЩИЙ МЕСЯЦ (с проверкой ставки досрочного погашения при досрочном выкупе):
           >0 - надо доначислить проценты
 Автор: Панфилов М.С.
 Версия от: 23/09/2013
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
******************************************************************************/
return DT.Amount as
   nResSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания
   
   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;
   
-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
-- dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;   

begin

   dtAccrDate := nvl(dtAccrDate, trunc(s.ysdate));

      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then
  
select PayDateVar, BillSum, BillCurrency,
          decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2
     into nPayDateVar, nBillSum, nBillCurr,
          dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2
     from Bill
    where Classified = bc.getbill;

  nResSum := GetAmountPercent(trunc(dtAccrDate,'MM') - 1,dtAccrDate,nPerc);
else
  nResSum := GetBillAccrualSum(bc.getbill,Context.OperDate);
end if;
dbms_output.put_line('nResSum = ' || nResSum || ' nResSum = ' || nResSum);
   -- запишем константную сумму (14) для вытаскивания в отчетах
      insert into BillSum(Bill, SumType, Doc, Amount)
         values(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nResSum);

   return nResSum;
   
end FUNC_Bill_AccrualAdd_TM_TCB;

od.FUNC_BILL_ACCRUALADD_TCB


create or replace function BillDPPercentSum_TCB2(
/******************************************************************************
 Сумма процентов по векселю на заданную дату по указанной ставке, с доп. параметром
 Дата: 25/04/2013
 Автор: Панфилов М.С.
******************************************************************************/
   nBill       DT.Reference,            -- вексель
   dtPayDate   date,                    -- дата платежа
   DPPerc      Bill.Percent%type,       --  процентная ставка по векселю
   flag        DT.status default 0      --  0 - с даты выдачи векселя, 1 - с начала текущего года
) return DT.Relation as

   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;

-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
 --dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;

begin
   dt_PayDate := trunc(dtPayDate);
   select PayDateVar, BillSum, BillCurrency,
          DPPerc, decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2, DPPerc
     into nPayDateVar, nBillSum, nBillCurr,
          nPercent, dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2, nSecondRate
     from Bill
    where Classified = nBill;

   --  для векселей "по предъявлению", у которых с даты составления или даты "не ранее" прошло более года
   if nPayDateVar = 1 and months_between(dtPercentTo, nvl(dtDate1, dtDrawDate)) >= 12 then
      dtPercentTo := add_months(nvl(dtDate1, dtDrawDate), 12);
   end if;

   if nPayDateVar != 1 and nPayDateVar != 2 then
      -- у векселей не по предъявлению % не бывает
      return null;
   elsif dtPercentTo <= dtPercentFrom then
      return 0;
   end if;
   if dtPercentFrom is null then
      return 0;
   end if;

   dtFirstRateTo := dtPercentTo;
   -- если есть вторая ставка
   if nvl(nSecondRate, 0) > 0 then
      if dtDate2 is not null and dt_PayDate > trunc(dtDate2) then
         dtFirstRateTo := dtDate2;
      end if;
      if dtDate2 is null and dtDate1 is not null and dt_PayDate > trunc(dtDate1) then
         dtFirstRateTo := dtDate1;
      end if;
   end if;
   -- Расчет суммы по первой ставке
   if flag = 0 then
   nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
   else
     if dtPercentFrom < trunc(dtPercentFrom,'YYYY') then
       nPercentSum := GetAmountPercent(trunc(dtPercentFrom,'YYYY'), dtFirstRateTo, nPercent);
     else 
       nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
     end if;
   end if;
   -- Расчет суммы по второй ставке
   if nvl(nSecondRate, 0) > 0 and dtFirstRateTo < dt_PayDate then
--      DateAddTime(dtPercentFrom, dtFirstRateTo, 1, 1);
      dtPercentFrom := dtFirstRateTo;
      if flag = 0 then
      nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
      else
        if dtPercentFrom < trunc(dtPercentFrom,'YYYY') then
          nPercentSum := nPercentSum + GetAmountPercent(trunc(dtPercentFrom,'YYYY'), dt_PayDate, nSecondRate);
        else 
          nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
        end if;
      end if;
   end if;

   return nPercentSum;
end BillDPPercentSum_TCB2;


create or replace function FUNC_Bill_AccrualReturn_TY_TCB
/******************************************************************************
 Описание: Функция возвращает сумму излишненачисленных процентов ЗА ТЕКУЩИЙ ГОД (с проверкой ставки досрочного погашения при досрочном выкупе):
 Автор: Панфилов М.С.
 Версия от: 24/09/2013
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
******************************************************************************/
return DT.Amount as
   nSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   nPercSum      dt.Amount;                          -- начисленные проценты
   nPrePercSum dt.Amount;                          -- ранее начисленные проценты
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания
   bClassified     dt.Reference;
begin

   dtAccrDate := nvl(dtAccrDate, Context.OperDate);
   
   select sum(bs.Amount) into nPrePercSum from BillSum bs, doctree dt
   where dt.classified = bs.doc and dt.operdate > trunc(Context.OperDate,'YYYY') and bs.Bill = bc.getbill and bs.SumType = nvl( bill_p.SumTypeClassified(14),0);

      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then
  nPercSum := BillDPPercentSum_TCB2(bc.getbill,Context.OperDate,nPerc,1);
  dbms_output.put_line('nPercSum = ' || nPercSum || ' nPrePercSum = ' || nPrePercSum);
   nSum := nPercSum - nPrePercSum;
else
  nSum := 0;
end if;
   -- запишем константную сумму (14) для вытаскивания в отчетах
   dbms_output.put_line('BC.GetBill = ' || BC.GetBill || ' bill_p.SumTypeClassified(14) = ' || bill_p.SumTypeClassified(14) || ' BC.GetDoc = ' || BC.GetDoc || ' nSum = ' || nSum);
      insert into BillSum(Bill, SumType, Doc, Amount)
         values(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nSum);

   return abs(nSum);
end FUNC_Bill_AccrualReturn_TY_TCB;



create or replace function FUNC_Bill_AccrualReturn_TL_TCB
/******************************************************************************
 Описание: Функция возвращает сумму излишненачисленных процентов ЗА ПРОШЛЫЕ ГОДА (с проверкой ставки досрочного погашения при досрочном выкупе):
 Автор: Панфилов М.С.
 Версия от: 24/09/2013
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
******************************************************************************/
return DT.Amount as
   nSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   nPercSum      dt.Amount;                          -- начисленные проценты
   nPrePercSum dt.Amount;                          -- ранее начисленные проценты
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания
   bClassified     dt.Reference;
begin

   dtAccrDate := nvl(dtAccrDate, Context.OperDate);

   select sum(bs.Amount) into nPrePercSum from BillSum bs, doctree dt
   where dt.classified = bs.doc and dt.operdate < trunc(Context.OperDate,'YYYY') and bs.Bill = bc.getbill and bs.SumType = nvl( bill_p.SumTypeClassified(14),0);


      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then
  nPercSum := BillDPPercentSum_TCB(bc.getbill,trunc(Context.OperDate,'YYYY'),nPerc);
  dbms_output.put_line('nPercSum = ' || nPercSum || ' nPrePercSum = ' || nPrePercSum);
   nSum := nPercSum - nPrePercSum;
else
  nSum := 0;
end if;

   -- запишем константную сумму (14) для вытаскивания в отчетах
   insert into BillSum(Bill, SumType, Doc, Amount)
         values(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nSum);
   
   return abs(nSum);
end FUNC_Bill_AccrualReturn_TL_TCB;




select * from billsum
select * from doctree operdate
select trunc(sysdate-25,'MM') from dual
select trunc(sysdate,'YYYY') from dual
select sum(amount) from billsum where bill = 1168560686 -- 14590,57
select * from billsum where bill = 1168560686 -- 14590,57
select * from 
FUNC_BILL_NEWPERCENT_DELTA

(select * from dealaccintention where constintention in (15,16,17,18))

----------------------------------------------------------------------------------
--25/09/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------





select * from billoper where doc = 232236391

-- update billoper set client = 127879653 where doc = 232236391                       -- по задаче IPI 157922                                                     ++

----------------------------------------------------------------------------------
--26/09/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- исправить номера векселей и названия счетов по векселям 0030601..0030631 для Перми (просила Епанова)                                                           ++
select * from bill where num like '00326__' and sysfilial = 2
update bill set num = '0032601' where num = '0030601' and sysfilial = 2;
update bill set num = '0032602' where num = '0030602' and sysfilial = 2;
update bill set num = '0032603' where num = '0030603' and sysfilial = 2;
update bill set num = '0032604' where num = '0030604' and sysfilial = 2;
update bill set num = '0032605' where num = '0030605' and sysfilial = 2;
update bill set num = '0032606' where num = '0030606' and sysfilial = 2;
update bill set num = '0032607' where num = '0030607' and sysfilial = 2;
update bill set num = '0032608' where num = '0030608' and sysfilial = 2;
update bill set num = '0032609' where num = '0030609' and sysfilial = 2;

update bill set num = '0032611' where num = '0030611' and sysfilial = 2;
update bill set num = '0032612' where num = '0030612' and sysfilial = 2;
update bill set num = '0032613' where num = '0030613' and sysfilial = 2;
update bill set num = '0032614' where num = '0030614' and sysfilial = 2;
update bill set num = '0032615' where num = '0030615' and sysfilial = 2;
update bill set num = '0032616' where num = '0030616' and sysfilial = 2;
update bill set num = '0032617' where num = '0030617' and sysfilial = 2;
update bill set num = '0032618' where num = '0030618' and sysfilial = 2;
update bill set num = '0032619' where num = '0030619' and sysfilial = 2;

update bill set num = '0032601' where num = '0030621' and sysfilial = 2;
update bill set num = '0032602' where num = '0030622' and sysfilial = 2;
update bill set num = '0032603' where num = '0030623' and sysfilial = 2;
update bill set num = '0032604' where num = '0030624' and sysfilial = 2;
update bill set num = '0032605' where num = '0030625' and sysfilial = 2;
update bill set num = '0032606' where num = '0030626' and sysfilial = 2;
update bill set num = '0032607' where num = '0030627' and sysfilial = 2;
update bill set num = '0032608' where num = '0030628' and sysfilial = 2;
update bill set num = '0032609' where num = '0030629' and sysfilial = 2;

update bill set num = '0032610' where num = '0030610' and sysfilial = 2;
update bill set num = '0032620' where num = '0030620' and sysfilial = 2;

update bill set num = '0032621' where num = '0032601' and sysfilial = 2 and classified = 1273254836;
update bill set num = '0032622' where num = '0032602' and sysfilial = 2 and classified = 1273254839;
update bill set num = '0032623' where num = '0032603' and sysfilial = 2 and classified = 1273254842;
update bill set num = '0032624' where num = '0032604' and sysfilial = 2 and classified = 1273254845;
update bill set num = '0032625' where num = '0032605' and sysfilial = 2 and classified = 1273254848;
update bill set num = '0032626' where num = '0032606' and sysfilial = 2 and classified = 1273254851;
update bill set num = '0032627' where num = '0032607' and sysfilial = 2 and classified = 1273254854;
update bill set num = '0032628' where num = '0032608' and sysfilial = 2 and classified = 1273254857;
update bill set num = '0032629' where num = '0032609' and sysfilial = 2 and classified = 1273254860;

update bill set num = '0032630' where num = '0030630' and sysfilial = 2;
update bill set num = '0032631' where num = '0030631' and sysfilial = 2;

select * from BillRange where doc = 233745491
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745491 and bill = 1273254746;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745491 and bill = 1273254749;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745491 and bill = 1273254752;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745491 and bill = 1273254755;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745491 and bill = 1273254758;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745491 and bill = 1273254761;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745491 and bill = 1273254764;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745491 and bill = 1273254767;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745491 and bill = 1273254770;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745491 and bill = 1273254773;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745491 and numfrom = '0030606';
update BillRange set numfrom = '0032611', numto = '0032620' where doc = 233745491 and numfrom = '0030611';
update BillRange set numfrom = '0032621', numto = '0032630' where doc = 233745491 and numfrom = '0030621';
update BillRange set numfrom = '0032631', numto = '0032631' where doc = 233745491 and numfrom = '0030631';

select * from BillRange where doc = 233745486
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745486 and bill = 1273254746;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745486 and bill = 1273254749;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745486 and bill = 1273254752;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745486 and bill = 1273254755;
update BillRange set numfrom = '0030596', numto = '0030600' where doc = 233745486 and bill = 1273254758;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745486 and bill = 1273254761;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745486 and bill = 1273254764;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745486 and bill = 1273254767;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745486 and bill = 1273254770;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745486 and bill = 1273254773;
update BillRange set numfrom = '0032601', numto = '0032605' where doc = 233745486 and numfrom = '0030606';
update BillRange set numfrom = '0032611', numto = '0032620' where doc = 233745486 and numfrom = '0030611';
update BillRange set numfrom = '0032621', numto = '0032630' where doc = 233745486 and numfrom = '0030621';
update BillRange set numfrom = '0032631', numto = '0032631' where doc = 233745486 and numfrom = '0030631';

select * from syscertificate where series in (select classified from syssecurityseries where security = 1066859597)
select * from syssecurityseries where security = 1066859597

update syscertificate set num = '0032601' where num = '0030601' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032602' where num = '0030602' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032603' where num = '0030603' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032604' where num = '0030604' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032605' where num = '0030605' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032606' where num = '0030606' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032607' where num = '0030607' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032608' where num = '0030608' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032609' where num = '0030609' and series in (select classified from syssecurityseries where security = 1066859597);

update syscertificate set num = '0032611' where num = '0030611' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032612' where num = '0030612' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032613' where num = '0030613' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032614' where num = '0030614' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032615' where num = '0030615' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032616' where num = '0030616' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032617' where num = '0030617' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032618' where num = '0030618' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032619' where num = '0030619' and series in (select classified from syssecurityseries where security = 1066859597);

update syscertificate set num = '0032621' where num = '0030621' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032622' where num = '0030622' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032623' where num = '0030623' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032624' where num = '0030624' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032625' where num = '0030625' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032626' where num = '0030626' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032627' where num = '0030627' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032628' where num = '0030628' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032629' where num = '0030629' and series in (select classified from syssecurityseries where security = 1066859597);

update syscertificate set num = '0032630' where num = '0030630' and series in (select classified from syssecurityseries where security = 1066859597);
update syscertificate set num = '0032631' where num = '0030631' and series in (select classified from syssecurityseries where security = 1066859597);


select * from account where label like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №00306__' and label not like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №0030600'
update account set label = replace(label,'306','326') where label like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №00306__' and label not like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №0030600'
select * from doctree where label like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №00326__' and label not like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №0030600'
update doctree set label = replace(label,'306','326') where label like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №00306__' and label not like 'ЗАО ТД "ГАЛИОН" вексель "ТКБ" (ЗАО) №0030600'

select * from bill where label like '<без серии> - 00306__' and label not like '<без серии> - 0030600' and sysfilial = 2
update bill set label = replace(label,'306','326') where label like '<без серии> - 00306__' and label not like '<без серии> - 0030600' and sysfilial = 2

select * from doctree where parent = 233745486 and doctype = 1065523598 and description like 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 00306__'
 and description not like 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 0030600'
 
update doctree set description = replace(label,'306','326')
 where parent = 233745486 and doctype = 1065523598 and description like 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 00306__'
 and description not like 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 0030600'

select rowid, dt.* from doctree dt where parent = 233745486 and doctype = 1065523598 and description = 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 00326'

update doctree set description = 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 00326' where parent = 233745486 and doctype = 1065523598 and description = 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 00306'

select rowid, dt.* from doctree dt where parent = 233745486 and doctype = 1065523598 and description = 'Новация векселя "ТКБ" (ЗАО) № 0030595 в вексель "ТКБ" (ЗАО) № 00326'

select rowid, dt.* from doctree dt where parent = 233745486 and doctype = 1065523598

select dtp.rowid, dtp.description, dt.* from doctree dt, doctree dtp where dtp.classified in (select classified from doctree dt where parent = 233745486 and doctype = 1065523598) 
and dtp.classified = dt.parent

select dt.rowid, dtp.description, dt.* from doctree dt, doctree dtp where dtp.classified in (select classified from doctree dt where parent = 233745486 and doctype = 1065523598) 
and dtp.classified = dt.parent

----------------------------------------------------------------------------------
--30/09/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--01/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from dealtransaction where doc = 124651633

-- от Артемова Олега
SELECT D.DOC, 
       D.ACCOUNT, 
       d.rsaccount,
       A.CODE, 
       A.LABEL,
       dt.label,
       od.reestrrestout(D.RSACCOUNT, '30.09.2013'),
       OD.ACCOUNTBALANCE(D.ACCOUNT, '30.09.2013')
FROM DEALACCOUNT D
INNER JOIN ACCOUNT A ON A.CLASSIFIED = D.ACCOUNT
INNER JOIN doctree dt ON dt.CLASSIFIED = D.doc
WHERE D.ACCINTENTION in (select classified from od.dealaccintention where constintention in (15,16,17,18)) 
AND (d.doc in (181847334,224452776,224506446,224533878,224535563,229472529)) and dt.category = 908
ORDER BY D.DOC, d.account


SELECT D.DOC, 
       D.ACCOUNT, 
       d.rsaccount,
       A.CODE, 
       A.LABEL,
       dt.label,
       od.reestrrestout(D.RSACCOUNT, '30.08.2013'),
       OD.ACCOUNTBALANCE(D.ACCOUNT, '30.08.2013')
FROM DEALACCOUNT D
INNER JOIN ACCOUNT A ON A.CLASSIFIED = D.ACCOUNT
INNER JOIN doctree dt ON dt.CLASSIFIED = D.doc
WHERE D.ACCINTENTION in (select classified from od.dealaccintention where constintention in (15,16,17,18)) 
AND /*(d.doc in (181847334,224452776,224506446,224533878,224535563,229472529))*/ d.account = 118316409 and dt.category = 908
ORDER BY D.DOC, d.account


select * from dealaccount where account = 118316409

select * from doccategory
select * from doctree where classified = 222130785

select * from doctree where classified = 224452776

od.SPEC_DealDepFixRate

select * from docstate
select * from doctree where classified = 229472556

od.UT_DealAccrual_EveryDayFT_TCB
od.UT_DEALACCRUAL


select * from account where code = '47426840650000100086'
select * from od.accountwithreestr where account = 214300042
select * from reestr where accountwithreestr = 1252215611
select * from reestrdoc where accountwithreestr = 1252215611


47426840000000100092
225472289

-- проблемы с валютными траншами МБК 10/2013:
-- сделал счет 31409978400000000095 реестровым                                                                                                          ++
-- выровнять реестры по счетам:                                                                                                                         ++
---- 47426840000002000006 ЕБРР (Сумма должна быть 906,39 долларов США (это без суммы наращенных за сентябрь, т.к. процедуру еще не запускали))          ++
---- CH 47426978150000000095                                                                                                                            ++
---- IFC 47426840000000100092 - тут итак всё нормально было                                                                                             ++  
-- снова неверное назначение платежа у Бакумцевой                                                                                                       ++
-- нет автоматического расчета процентов в процентном графике, после ручной коррекции => 04/10/2013 на писал в НА, зарегистрировали замечание 48764 =>
-- прислали алгоритм действий как обойти эту проблему, попробовал - работает => тестит Ледовская                                                        ++

-- ЕБРР      
select * from account where code = '47426840000002000006'
select * from od.accountwithreestr where account = 28735876
select * from reestr where accountwithreestr = 1252218026
select * from reestrdoc where accountwithreestr = 1252218026
--++++
delete reestr where reestrinit != 234406332 and accountwithreestr = 1252218026;                                                -- удаляем лишние занесения на реестр 
update reestr set docsum = 2265.97+815.75+90.64 where docsum = 2265.97 and accountwithreestr = 1252218026;                     -- изменяем сумму в занесении
update reestrdoc set docsum = 2265.97+815.75+90.64 where docsum = 2265.97 and accountwithreestr = 1252218026;                  -- изменяем сумму в занесении
delete reestrdoc where ((reestrinit not in (234406332) or reestrinit is null) and classified not in (234406332)) and accountwithreestr = 1252218026;   -- удаляем лишние занесения на реестр                                  -- удаляем лишние занесения на реестр

-- CH     
select * from account where code = '47426978150000000095'
select * from od.accountwithreestr where account = 174674393
select * from reestr where accountwithreestr = 1255933504
select * from reestrdoc where accountwithreestr = 1255933504
--++++
delete reestr where reestrinit = 230552418 and accountwithreestr = 1255933504;                                                   -- удаляем лишние занесения на реестр 
delete reestrdoc where initdoc = 230455652 and accountwithreestr = 1255933504;                                                   -- удаляем лишние занесения на реестр 

---- IFC 
select * from account where code = '47426840000000100092'
select * from od.accountwithreestr where account = 141314068
select * from reestr where accountwithreestr = 1252214949
select * from reestrdoc where accountwithreestr = 1252214949

create or replace function DealBegProcDate2(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления даты начала предыдущего периода начисления процентов по траншу.
-- Автор: Панфилов М.С. (на основе DealBegProcDate)
-- Версия: 14.04.2011
--         10.06.2013 адаптирована для сделок траншей МБК (Зам. № 46876)
--         13.06.2013 Панфилов М.С.
--         03/07/2013 Панфилов М.С. - теперь учтен вариант, когда уже была только одна дата учета процентов.
--         04/10/2013 Панфилов М.С. - +1 день по просьбе Бакумцевой (письмо от 01/10/2013).
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference  -- идентификатор сделки
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
     dbms_output.put_line(' ppp0 dtPercBegDate  ='||dtPercBegDate);
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null or nIsTransh = 0 then
      --это не депозитная сделка
      return null;
   end if;
   if nIsTransh = 1 then
      dtPercbegdate := dtStartdealdate; -- 29/07/2013 Панфилов М.С. - если c DealSwapInterestLog всё плохо, то чтобы не вылетало
      -- дата начала предыдущего периода начисления процентов по траншу
      begin
      select bd+1 into dtPercbegdate from -- 04/10/2013 Панфилов М.С. - +1 день
          (SELECT trunc(bd) as bd,
                  row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
              FROM (select DISTINCT trunc(OperDate) as bd, doc from DealSwapInterestLog
                    union
                    select trunc(d.valuedate), d.doc from deal d
                   ) b
             WHERE doc = nDoc) x where x.rang = 2;
      exception when others then null;
      end;
   end if;
        dbms_output.put_line(' ppp1 dtPercBegDate  ='||dtPercBegDate);
   return dtPercBegDate;
end DealBegProcDate2;

-- 234623825
select * from doctree where classified in(
230455652,
229472529,
224535563,
224533878,
224506446
)

select * from dealaccount where rsaccount = 1252218026
----------------------------------------------------------------------------------
--03/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------


select dd.interestrate as "%, Ставка", d.valuedate as "c", d.maturitydate as "по" from dealdeposit dd, deal d where dd.doc = /*nDealID --*/221377912
and d.doc = dd.doc and dd.interestrate is not null
union
select rate+spread, min(startdate), max(enddate) from DealSwapInterest where doc = /*nDealID --*/221377912 group by rate+spread order by 1

select * from DealSwapInterest where doc = /*nDealID --*/224628550

select nvl(rate,0)+spread, min(startdate), max(enddate) from DealSwapInterest ds where doc = /*nDealID --*/224628550 group by nvl(rate,0)+spread  order by 1
od.DealDep_proc

BEGPROCDATE2
select * from DEALPAYMENTPURPOSE where value like '%BEGPROCDATE2%'

create or replace procedure LoadBICDir_HF_CCH_TCB(
   siRowData in out DT.PString,           -- строка с данными 'HF'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника выходных дней
-- Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе LoadBICDir_HF)
-- Автор: Данилов О.В.
-- Версия от 20/06/2007
-- Версия: UAV (25/12/2009)
-- LoadBICDir_HF  - Процедура для закачки справочника выходных дней. Исправлены условия для выхода из обработки,
-- иначе не загружались данные.
-- Версия от 22/12/2012: Исправлено начитывание названия страны для формат с разделителем <Tab>
-- 26/12/2012 Панфилов М.С. адаптирвана для TCB для закачки CCH (на основе LoadBICDir_HF)
-- 30/07/2013 Панфилов М.С. теперь не чистим прошлый месяц, как принято в swift, и не используем ConstHoliday
-- 04/05/2013 Панфилов М.С. теперь insert Holiday делается только по праздникам "H", так как "W" инсерчу вручную
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HF'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sCountryCode   DT.Label;             -- краткий код ISO государства
   sCountryName1  DT.Description;       -- наименование государства (часть 1)
   sCountryName2  DT.Label;             -- наименование государства (часть 2)
   dtDate         date;                 -- дата праздника
   sHolidayType   DT.Label;             -- тип праздника
   sSpecInfo      DT.Text;              -- дополнительная информаци
   nCountry       DT.Reference;
   nHoliday       DT.Reference;
   nRef           DT.Reference;
   nCount         DT.Quantity;
   sDate          DT.Label;
   nDay           ConstHoliday.DayNumber%TYPE;
   nMonth         ConstHoliday.MonthNumber%TYPE;
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
 -- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sCountryCode := cut_of_string(siRowData,2);
      sCountryName1 := cut_of_string(siRowData,35);
      sCountryName2 := cut_of_string(siRowData,35);
      sCountryName1 := rtrim(rpad(sCountryName1,35)||sCountryName2);
      dtDate := TO_DATE(cut_of_string(siRowData,8),'YYYYMMDD');
      sHolidayType := cut_of_string(siRowData,1);
      sSpecInfo := cut_of_string(siRowData,320);
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sCountryName1 := text_proc.cut_part_of_string(siRowData,null,CHR(9));
--      sCountryName2 := text_proc.cut_part_of_string(siRowData,null,CHR(9));  название только одно
      dtDate := TO_DATE(text_proc.cut_part_of_string(siRowData,null,CHR(9)),'YYYYMMDD');
      sHolidayType := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sSpecInfo := text_proc.cut_part_of_string(siRowData,null,320);
   end if;
   -- Проверяем тип записи
   if sTag != 'HF' or sTag is null or sCountryCode is null
      or dtDate < S.ysdate then
      return;
   end if;
   -- Ищем страну
   if sCountryCode = 'RU' then        -- 26/12/2012 Панфилов М.С. РФ не трогаем!!!
         return;
   end if;
   nCountry := FindObjectByCode(sCountryCode, 17);
   if nCountry is null then
      if sCountryName1 is null then
         return;
      end if;
      -- Ищем тип региона - государство
      begin
         select Classified into nRef from RegionType where Const = 1;
      exception
         when No_Data_Found then
            null;
      end;
      -- Заводим страну
      ClientRegionIns(nCountry, null, substr(sCountryName1, 1, 50), sCountryName1, null, nRef);
      nRef := null;
      BankCode_Edit(nRef, nCountry, sCountryCode, 17);
   end if;
   -- Схема выходных дней у региона
   select HolidaySch into nHoliday from ClientRegionTree where Classified = nCountry;
   if nHoliday is null then
      -- Заводим схему выходных дней
      select Classified.NextVal into nHoliday from Dual;
      insert into HolidaySchema(Classified, Label, Description)
         values(nHoliday, substr('Календарь г-ва '||sCountryName1, 1, 50),'Схема выходных дней государства '||sCountryName1);
      insert into WeekDefinition(ClientRegion, WeekBegining, MonType, TueType, WedType, ThuType, FriType, SatType, SunType)
         values( nHoliday, 1, 0, 0, 0, 0,  0, 1, 1 );
      -- Удаляем выходные дни
      delete from Holiday where HolidaySchema = nHoliday;
      -- Привязываем схему к региону
      update ClientRegionTree set HolidaySch = nHoliday where Classified = nCountry;
   end if;
   select Count(*) into nCount from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
   sDate := to_char(dtDate,'DD/MM/YYYY');
   if sFlag = 'D' then
      if nCount > 0 then
      if to_char(dtDate,'MM/YYYY') != to_char(td,'MM/YYYY') then -- 30/07/2013 Панфилов М.С. не чистим прошлый месяц, как принято в swift
         delete from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
         Eventservice.Putevent(34,'TRANS','В схеме выходных дней для г-ва '||sCountryName1||' удаляется праздник '||sDate,
                                          'Загрузка BIC/BIC+ Directory '||sysdate);
      end if;
      end if;
   elsif nCount = 0 then
      -- Добавляем праздник
   if sHolidayType = 'H' then    -- только праздники, имеющие статус "обычного"
      insert into Holiday( HolidaySchema, HolidayDate ) values( nHoliday, dtDate );
   nDay := TO_NUMBER(SUBSTR(sDate,1,2));
   nMonth := TO_NUMBER(SUBSTR(sDate,4,2));
   /*begin                                                       -- 30/07/2013 Панфилов М.С. ConstHoliday теперь не используем
    insert into ConstHoliday values(nHoliday, nMonth, nDay);
   exception
            when others then null;
   end;*/
  end if;
   end if;
end LoadBICDir_HF_CCH_TCB;

create or replace procedure LoadBICDir_HS_CCH_TCB(
   siRowData in out DT.PString,           -- строка с данными 'HF'
   niFixLen  in DT.Status                 -- 0 - формат с разделителем <Tab>, 1 - формат с фикс. длиной
)
-----------------------------------------------------------------------------------------------
-- Описание: Процедура для закачки справочника выходных дней для специфических календарей (пока только EUR)
-- 26/12/2012 Панфилов М.С. для TCB для закачки CCH
-- 30/07/2013 Панфилов М.С. теперь не чистим прошлый месяц, как принято в swift, и не используем ConstHoliday
-- 04/05/2013 Панфилов М.С. теперь insert Holiday делается только по праздникам "H", так как "W" инсерчу вручную
-----------------------------------------------------------------------------------------------
as
   sTag           DT.Label;             -- признак типа записи, должен быть 'HS'
   sFlag          BIC_Dir_temp.Flag%Type;          -- флаг
   sServiceCode   DT.Label;             -- краткий код календаря
   dtDate         date;                 -- дата праздника
   sHolidayType   DT.Label;             -- тип праздника
   sSpecInfo      DT.Text;              -- дополнительная информаци
   nCountry       DT.Reference;
   nHoliday       DT.Reference;
   nRef           DT.Reference;
   nCount         DT.Quantity;
   sDate          DT.Label;
   nDay           ConstHoliday.DayNumber%TYPE;
   nMonth         ConstHoliday.MonthNumber%TYPE;
--
   function cut_of_string(
   -- Возвращает подстроку заданной длины. Из первого параметра удаляютс
   -- возвращаемая подстрока
      sio_str    in out dt.pstring,   -- исходная строка
      niLen      in dt.Counter        -- длина получаемой строки
   ) return dt.pstring  is
      s_result dt.text := rtrim(substr(sio_str, 1, niLen));
   begin
      sio_str := substr(sio_str, niLen+1);
      return s_result;
   end cut_of_string;
begin
 -- Разберем данные
   if niFixLen = 1 then          -- фикс. длина
      sTag := cut_of_string(siRowData,2);
      sFlag := cut_of_string(siRowData,1);
      sServiceCode := cut_of_string(siRowData,3);
      dtDate := TO_DATE(cut_of_string(siRowData,8),'YYYYMMDD');
      sHolidayType := cut_of_string(siRowData,1);
      sSpecInfo := cut_of_string(siRowData,320);
   else
      sTag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sFlag := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sServiceCode := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      dtDate := TO_DATE(text_proc.cut_part_of_string(siRowData,null,CHR(9)),'YYYYMMDD');
      sHolidayType := text_proc.cut_part_of_string(siRowData,null,CHR(9));
      sSpecInfo := text_proc.cut_part_of_string(siRowData,null,320);
   end if;
   -- Проверяем тип записи
   if sTag != 'HS' or sTag is null or sServiceCode is null
      or dtDate < S.ysdate then
      return;
   end if;
   -- пока только EUR
   if sServiceCode != 'EUR' then
     return;
   end if;
   nHoliday := 1199945084;
   select Count(*) into nCount from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
   sDate := to_char(dtDate,'DD/MM/YYYY');
   if sFlag = 'D' then
   if to_char(dtDate,'MM/YYYY') != to_char(td,'MM/YYYY') then -- 30/07/2013 Панфилов М.С. не чистим прошлый месяц, как принято в swift
      if nCount > 0 then
         delete from Holiday where HolidaySchema = nHoliday and HolidayDate = dtDate;
         Eventservice.Putevent(34,'TRANS','В схеме выходных дней '||sServiceCode||' удаляется праздник '||sDate,
                                          'Загрузка BIC/BIC+ Directory CCH '||sysdate);
      end if;
   end if;
   elsif nCount = 0 then
      -- Добавляем праздник
   if sHolidayType = 'H' then    -- только праздники, имеющие статус "обычного"
      insert into Holiday( HolidaySchema, HolidayDate ) values( nHoliday, dtDate );
   nDay := TO_NUMBER(SUBSTR(sDate,1,2));
   nMonth := TO_NUMBER(SUBSTR(sDate,4,2));
   /*begin                                             -- 30/07/2013 Панфилов М.С. ConstHoliday теперь не используем
    insert into ConstHoliday values(nHoliday, nMonth, nDay);
   exception
            when others then null;
   end;*/
  end if;
   end if;

end LoadBICDir_HS_CCH_TCB;

----------------------------------------------------------------------------------
--07/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select 12272727.28*0.0367338*((31+31+30-20+21+30+31+28)/360) from dual
od.SRP_LOADBICDIRECTORY_CCH_TCB
od.SRP_LOADBICDIRECTORY_CCH_TCB
od.SRP_LOADBICDIRECTORY

select * from BIC_Dir_Load where rowdata not like 'BI%' like '%MORABANC	ESCALDES-ENGORDANY	ESCALDES%'
not like 'BI%'  'HF%'
select * from BIC_Dir_Load where rowdata like '%CVOCRU3S%'
SRP_LoadBicDirectory_CCH_TCB


-- правил BBR_TCB_BILL_OPER_MSK для Филимоновой ('+1 день' и '<=' для %2012 и discount2012)                                                                ++

----------------------------------------------------------------------------------
--08/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 211456811
select * from billoper where doc = 211456811
update billoper set client = 27372 where doc = 211456811   -- просила Герасимова по IPI 159399                                                             ++
select * from bill where num = '0030807'   

update bill set payee = 27372 where num = '0030807'        -- просила Герасимова по IPI 159399                                                             ++

----------------------------------------------------------------------------------
--09/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.getclientreg_tcb
getclientreg_tcb

od.dealtransaction

----------------------------------------------------------------------------------
--10/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

SELECT DT.CL_Classified, DT.CL_Label, DT.Classified, DT.CL_Description, CT.Label, DT.DocType, null, null, NULL, NULL, NULL, NULL, NULL, NULL
 FROM ClientType CT, V_Doctree_Client DT 
  WHERE DT.DocState = 1000000039
    AND DT.DocType IN (1000133055,1000133080,1014337927,1000360963,1012801392,1026103529,1026333463,1000360918,1000361048,1000361005,1000000441)
    AND CT.Classified = DT.Type 
    AND UPPER( DT.CL_Label ) LIKE '%МОСКВА%СИТИ%' ESCAPE '\'  /*AND
    1 = ( SELECT Count(*) FROM V_ObjProp
        WHERE V_ObjProp.Obj = DT.CL_Classified
            AND ( ( V_ObjProp.Prop = 1000002563 AND
      V_ObjProp.Status = 1 AND S.YSDATE BETWEEN V_ObjProp.ValidFromDate AND V_ObjProp.ValidToDate ) ) ) */
      

SELECT DT.CL_Classified, DT.CL_Label, DT.Classified, DT.CL_Description, CT.Label, DT.DocType, null, null, NULL, NULL, NULL, NULL, NULL, NULL
 FROM ClientType CT, V_Doctree_Client DT 
  WHERE EXISTS (SELECT * FROM V_EntityStateWindow WHERE EntityState = DT.EntityState
        AND WindowName IN ('frmClient') )
    AND DT.DocType = 1000000441
    AND CT.Classified = DT.Type 
    AND UPPER( DT.CL_Label ) LIKE '%МОСКВА%СИТИ%' ESCAPE '\' 
    
select * from dealtransaction where doc in (select classified from doctree where parent = 217656385)   
select * from od.dealtransaction where doc = 234620348
select * from doctree where classified = 234620348

select * from od.dealswapinterest where doc = 226148025
select * from DealSwapInterestLog where doc = 217656385
select * from doctree where classified = 234620474
select * from doctype where classified = 1047492427
select * from od.dealswappayperiod where interestperiod in (select classified from DealSwapInterest where doc = 226148025)
select * from od.dealswappayperiod where interestperiod = 1256305043
select * from od.dealswappayment where doc = 217656385

select * from doctree where classified = 230452608
select * from doctree where classified = 1275682960

-- проблема по процентно-дисконтному векселю в Питере                                                                                                             ++
---- не отрабатывает автомат по начислению процентов => из-за того, что на векселе не была указана дата "начислять с" => сделал update                            ++
---- нет процентных сумм в BillSum => сделал начисление в 30/09/2013, проводки удалил                                                                             ++



-- сделать процедуру для сдвига даты платежа по списку траншей МБК (нужно Ледовской для отчетности)                                                               ++
--- настройки на базе diling:                                                                                                                                     ++
---- основная операция "Групповой пересчет графика платежей и событий"                                                                                            ++
---- написать процедуру SPEC_movepaydate_tcb и привязать её в manager "Изменить дату платежа в процентном графике"                                                ++
---- тесты на базе diling                                                                                                                                         ++
--- перенести на боевую                                                                                                                                           ++
--- отписать Ледовской, чтобы протестила на athena3                                                                                                               ++
--- поставить на athena3 модуля из патча 1890                                                                                                                     ++
--- заменить в manager DPC_DealDep_Events на DPC_DealDep_Events_TCB                                                                                               ++
--- убрать в manager dpc_dealtrans_settransacc                                                                                                                    ++
--- перенести на боевую донастройки                                                                                                                               ++
--- поставить на боевую модуля из патча 1890 IPI 162394                                                                                                           ++

od.DPC_DealDep_Events
od.SPEC_setvaluedate_tcb
select * from doccategory

od.DealDepInterestRS

CREATE OR REPLACE PROCEDURE SPEC_movepaydate_tcb
/**********************************************************************************
Описание: процедура изменяет дату платежа в процентном графике
Автор: Панфилов М.С.
Дата: 11/10/2013
Параметры: OldDate старая дата; NewDate новая дата
**********************************************************************************/
( nDoc        dt.Reference,
  OldDate     date,
  NewDate     date
 )
as
   nDocCat   dt.ConstValue;
begin

if NewDate is not null then
  select d.category into nDocCat from doctree d where classified = nDoc;
  if nDocCat = 908 then -- депозитные сделки
     UPDATE dealswapinterest set interestdate = NewDate where doc = nDoc and interestdate = OldDate; --!!! возможно нужно ещё апдейтить и od.dealswappayperiod !!!
     UPDATE dealswappayperiod set paydate = NewDate where interestperiod in (select classified from DealSwapInterest where doc = nDoc) and paydate = OldDate; 
  end if;
end if;

end SPEC_movepaydate_tcb;

create or replace procedure DPC_DealDep_Events_TCB(
-------------------------------------------------------------------------------
-- Описание: Порождение/корректировка событий сделки МБК по графику платежей (на основе DPC_DealDep_Events с восстановлением счета контрагента в событиях сделок).
-- Параметры: nMode - режим перерасчета событий
--             0 - перерасчет соыбытий с операционной даты;
--             1 - перерасчет всех неисполненных событий;
--             2 - перерасчет событий, начиная с даты последнего исполненного события (синхронно с перерасчетом %%).
-- Версия: 09.06.2012
--         12.12.2012 добавлен параметр режима перерасчета событий(Зам. № 43890, AGN)
--         29/10/2013 Панфилов М.С. затирается счет контрагента в событиях сделок
-------------------------------------------------------------------------------
   nMode   in DT.Status default 2 -- режим перерасчета событий (2 - пересоздать все неисполненные события согласно графику)
)
as
   outtransacc901    dealtransaction.beneficiaryaccount%type;
   outtransacc916    dealtransaction.beneficiaryaccount%type;
   nGenInt901        DT.Reference := Constants.GetGenIntention(901); -- событие по процентам
   nGenInt916        DT.Reference := Constants.GetGenIntention(916); -- событие по основной сумме
begin

   outtransacc901 := null;                                                  -- 29/10/2013 Панфилов М.С. затирается счет контрагента в событиях сделок
   outtransacc916 := null;                                                  -- поэтому приходится тут его восстанавливать
   begin
   select distinct d.beneficiaryaccount into outtransacc901 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = Message.idObject and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt901;
   exception when others then null;
   end;
   begin
   select distinct d.beneficiaryaccount into outtransacc916 from dealtransaction d, doctree dt where dt.classified = d.doc and dt.parent = Message.idObject and d.beneficiaryaccount is not null and dt.docstate = Constants.State_Open and dt.GenIntention = nGenInt916;
   exception when others then null;
   end;  
   DealDep_proc.DealDepEvents(Message.idObject, Message.dtDate, null, nvl(nMode, 2));
   if outtransacc901 is not null then
      update dealtransaction set beneficiaryaccount = outtransacc901 where exists (select * from doctree where parent = Message.idObject and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt901);
   end if;
   if outtransacc916 is not null then
      update dealtransaction set beneficiaryaccount = outtransacc916 where exists (select * from doctree where parent = Message.idObject and classified = doc and docstate = Constants.State_Open and GenIntention = nGenInt916);
   end if;
   
end DPC_DealDep_Events_TCB;


select * from bill where num = '0001067'
select * from billsum where bill = 1270696986
update bill set percentdate = to_date('16092013','ddmmyyyy') where num = '0001067'

select * from billsumtype where classified in (1011996478,1042775365)
select * from doctree where classified = 234321168
select * from doctype where classified = 1042775299

od.FUNC_BILL_PERCACCR

od.FUNC_BILL_PERCUNDEF
  
----------------------------------------------------------------------------------
--14/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select rowid, f.* from fx f where tradedate = td-2
select * from tcb_crc32 where classified in (236327957,236326334,236328668)

-- опять не качаются конверсии из Афины в RN у Андриянова => конверсии качались, просто у них была неверная дата регистрации (initdate в Афине)              ++
-- делал update вручную по 11 конверсиям                                                                                                                     ++
SELECT PARENT
                      FROM department
                     WHERE classified in
                              (SELECT dp
                                 FROM dpaccount
                                WHERE ACCOUNT IN (SELECT ACCOUNT
                                                    FROM bankoper
                                                   WHERE doc = 219906301))
select * from department where classified = 1058336142   
select * from doctree where classified = 236328668  
select * from doctype where classified = 1000136692 

SELECT PARENT
                      FROM department
                     WHERE classified in
                              (SELECT *
                                 FROM dpaccount
                                WHERE ACCOUNT IN (SELECT ACCOUNT
                                                    FROM bankoper
                                                   WHERE doc = 236328668))                                             
                                                   

select * from department where classified = 1014342418

select * from tcb_crc32 where dtsend > td -1

select rowid, f.* from fx f where /*ticket = 2674811 and*/ tradedate > td-2 and valuebuy = to_date('12102013','ddmmyyyy')

-- поставили с Калашниковой вексель 0001067 на хранение без проводок                                                                                              ++

select * from doctree where classified = 236527364

select* from doctype where classified = 1000160977

od.paym

----------------------------------------------------------------------------------
--15/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- проблема у Филимоновой с отчетом по 125 форме bbr.BBR_TCB_BILLOWN_DATE_REP с уже погашенными вкселями после отчетной даты => пришлось поправить
-- TCB_BILLCATSUM_NEW и написать billdayrepay_tcb                                                                                                                 ++
----------------------------------------------------------------------------------

bbr.BBR_TCB_BILLOWN_DATE_REP
od.tcb_billcatsum_new
select * from bill where num = '0023763'
select * from filial
select billdayrepay(1193195348,to_date('30092013','ddmmyyyy')) from dual

      select
      b.num, b.billsum --sum(b.billsum) --into ret1
      from
            bill b,billstatushistory bsh,billrange br,doctree dt
      where
            (( (od.billdayrepay(b.classified,to_date('30092013','ddmmyyyy'))>=0)
             and (od.billdayrepay(b.classified,to_date('30092013','ddmmyyyy'))<=1) )
             or od.billdayrepay(b.classified,to_date('30092013','ddmmyyyy')) is null)
             and   bsh.STATUS in(2,34,38,14) --in (6,8)
             and  bsh.startdate<=to_date('30092013','ddmmyyyy')
             and  bsh.enddate>to_date('30092013','ddmmyyyy')
             and not exists (select *
                             from billstatushistory t
                             where t.bill=bsh.bill
                             and bsh.startdate<t.startdate 
                             and t.startdate<= to_date('30092013','ddmmyyyy') )
             and  bsh.bill=b.classified
             and br.bill=bsh.bill
             and b.billcurrency=1000001275
             and dt.classified=br.doc
             and (b.date1 is null or b.date1<=to_date('30092013','ddmmyyyy')+1)
             and bsh.doc=dt.classified
             and dt.docstate = 1000000035
            -- and (dt.doctype=1065524926 or dt.doctype is null)
             and b.percent is not null  /*and b.sysfilial = 1*/ and b.maker = 1
             and tcb_getbillbalacc(to_date('30092013','ddmmyyyy'),b.classified) != '52406'

create or replace function billdayrepay_tcb
/*---------------------------------
Фуцнкция возвращает количество дней от указанной даты до погашения.
15/10/2013 Панфилов М.С. - функция создана на основе billdayrepay, только на b.repaydate внимания не обращаем.  
-----------------------------------------*/
(
       nBill   in bill.classified%type
       ,pDate  in date
 )

 return  number
 as
 ddif  number;
 begin
           select
                    case
                        --when b.repaydate is not null         then     b.repaydate-pDate
                        when b.paydatevar =3                 then     b.time-(pDate-b.drawdate)
                        when b.paydatevar =4                 then     b.date1- pDate
                        else        null
                     end


                   into ddif

           from
                    bill b
           where
                    b.classified=nBill;
           return ddif;

 end billdayrepay_tcb;
 
CREATE OR REPLACE FUNCTION TCB_BILLCATSUM_NEW
/*---------------------------------

15/10/2013 Панфилов М.С. - заменил billdayrepay на billdayrepay_tcb  
-----------------------------------------*/
       (pdate in date --начало периода
       ,time1 in number   --продолжительность периода
       ,cur1 in number    --валюта векселя
       ,btype in number   --1000001275:процентные,2:дисконтные
       ,ctype in number)  --1:номиналы,2:дисконты, 3:цены продаж
return number
as
ret1 number;

begin
 if ctype=1 then
    if btype=1000001275 then
      select
      sum(b.billsum) into ret1
      from
            bill b
            ,billstatushistory bsh
            ,billrange br
            ,doctree dt
      where
            (( (od.billdayrepay_tcb(b.classified,pdate)>=0)
             and (od.billdayrepay_tcb(b.classified,pdate)<=time1) )
             or od.billdayrepay_tcb(b.classified,pdate) is null)
             and   bsh.STATUS in(2,34,38,14) --in (6,8)
             and  bsh.startdate<=pdate
             and  bsh.enddate>pdate
             and not exists (select *
                             from billstatushistory t
                             where t.bill=bsh.bill
                             and bsh.startdate<t.startdate 
                             and t.startdate<= pdate )
             and  bsh.bill=b.classified
             and br.bill=bsh.bill
             and b.billcurrency=cur1
             and dt.classified=br.doc
             and (b.date1 is null or b.date1<=pdate+time1)
             and bsh.doc=dt.classified
             and dt.docstate = 1000000035
            -- and (dt.doctype=1065524926 or dt.doctype is null)
             and b.percent is not null  /*and b.sysfilial = 1*/ and b.maker = pref.ourbank
             and tcb_getbillbalacc(pdate,b.classified) != '52406'
             /*and b.classified not in (1091120673,
1091120675,
1091120677,
1091120679,
1091120681, 1066859389)*/;
    else
      select
            sum(b.billsum) into ret1
      from
            bill b
            ,billstatushistory bsh
          --  ,client c
            ,billrange br
           -- ,billoper bo
            ,doctree dt
      where
            (( (od.billdayrepay_tcb(b.classified,pdate)>=0)
             and (od.billdayrepay_tcb(b.classified,pdate)<=time1) )
             or od.billdayrepay_tcb(b.classified,pdate) is null)
             and   bsh.STATUS in(2,34,38,14) --in (6,8)
             and  bsh.startdate<=pdate
             and  bsh.enddate>pdate
             and not exists (select *
                             from billstatushistory t
                             where t.bill=bsh.bill
                             and bsh.startdate<t.startdate 
                             and t.startdate<= pdate )
             and  bsh.bill=b.classified
         --    and b.maker=c.classified
             and br.bill=bsh.bill
             and b.billcurrency=cur1
             and dt.classified=br.doc
          --   and bo.doc=dt.classified
             and (b.date1 is null or b.date1<=pdate+time1)
            -- and b.sysfilial=1
             --  and dty.classified=dt.doctype
             and bsh.doc=dt.classified
             and dt.docstate = 1000000035
           --  and (dt.doctype=1065524926 or dt.doctype is null)
             and b.percent is null      /*and b.sysfilial = 1*/ and b.maker = pref.ourbank  
             and tcb_getbillbalacc(pdate,b.classified) != '52406'
             /*and b.classified not in (1091120673,
1091120675,
1091120677,
1091120679,
1091120681, 1066859389)*/;
    end if ;
    return(nvl(ret1,0));
end if;
if ctype=2 then
      if btype=1000001275 then
          select
                sum(/*nvl(bill_p.DiscSum(b.classified,pdate),0)*/+nvl(bill_p.PercentSum(b.classified,pdate),0)) into ret1
          from
                bill b
                ,billstatushistory bsh
              --  ,client c
                ,billrange br
          --      ,billoper bo
                ,doctree dt
              --  ,billsum bs
          where

            (( (od.billdayrepay_tcb(b.classified,pdate)>=0)
             and (od.billdayrepay_tcb(b.classified,pdate)<=time1) )
             or od.billdayrepay_tcb(b.classified,pdate) is null)
             and   bsh.STATUS in(2,34,38,14) --in (6,8)
             and  bsh.startdate<=pdate
             and  bsh.enddate>pdate
             and not exists (select *
                             from billstatushistory t
                             where t.bill=bsh.bill
                             and bsh.startdate<t.startdate 
                             and t.startdate<= pdate )
             and  bsh.bill=b.classified
         --    and b.maker=c.classified
             and br.bill=bsh.bill
             and b.billcurrency=cur1
             and dt.classified=br.doc
         --    and bo.doc=dt.classified
             and (b.date1 is null or b.date1<=pdate+time1)
            -- and b.sysfilial=1
             --  and dty.classified=dt.doctype
             and bsh.doc=dt.classified
             and dt.docstate = 1000000035
            -- and (dt.doctype=1065524926 or dt.doctype is null)
             and b.percent is not null  /*and b.sysfilial = 1*/ and b.maker = pref.ourbank 
             and tcb_getbillbalacc(pdate,b.classified) != '52406'
             /*and b.classified not in (1091120673,
1091120675,
1091120677,
1091120679,
1091120681, 1066859389)*/;

       else
              select
               sum(nvl(bill_p.DiscSum(b.classified,pdate),0)/*+nvl(bill_p.PercentSum(b.classified,pdate),0)*/) into ret1
          from
                bill b
                ,billstatushistory bsh
              --  ,client c
                ,billrange br
           --     ,billoper bo
                ,doctree dt
               -- ,billsum bs
          where
                 (( (od.billdayrepay_tcb(b.classified,pdate)>=0)
             and (od.billdayrepay_tcb(b.classified,pdate)<=time1) )
             or od.billdayrepay_tcb(b.classified,pdate) is null)
             and   bsh.STATUS in(2,34,38,14) --in (6,8)
             and  bsh.startdate<=pdate
             and  bsh.enddate>pdate
             and not exists (select *
                             from billstatushistory t
                             where t.bill=bsh.bill
                             and bsh.startdate<t.startdate 
                             and t.startdate<= pdate )
             and  bsh.bill=b.classified
         --    and b.maker=c.classified
             and br.bill=bsh.bill
             and b.billcurrency=cur1
             and dt.classified=br.doc
         --    and bo.doc=dt.classified
             and (b.date1 is null or b.date1<=pdate+time1)
            -- and b.sysfilial=1
             --  and dty.classified=dt.doctype
             and bsh.doc=dt.classified
             and dt.docstate = 1000000035
            -- and (dt.doctype=1065524926 or dt.doctype is null)
             and b.percent is null  /*and b.sysfilial = 1*/ and b.maker = pref.ourbank 
             and tcb_getbillbalacc(pdate,b.classified) != '52406'
             /*and b.classified not in (1091120673,
1091120675,
1091120677,
1091120679,
1091120681, 1066859389)*/;

        end if ;
      return(nvl(ret1,0));
end if;
if ctype=3 then
         select
            sum(br.rowprice) into ret1
      from
            bill b
            ,billstatushistory bsh
          --  ,client c
            ,billrange br
          --  ,billoper bo
            ,doctree dt
      where
                 (( (od.billdayrepay_tcb(b.classified,pdate)>=0)
             and (od.billdayrepay_tcb(b.classified,pdate)<=time1) )
             or od.billdayrepay_tcb(b.classified,pdate) is null)
             and   bsh.STATUS in(2,34,38,14) --in (6,8)
             and  bsh.startdate<=pdate
             and  bsh.enddate>pdate
             and not exists (select *
                             from billstatushistory t
                             where t.bill=bsh.bill
                             and bsh.startdate<t.startdate 
                             and t.startdate<= pdate )
             and  bsh.bill=b.classified
         --    and b.maker=c.classified
             and br.bill=bsh.bill
             and b.billcurrency=cur1
             and dt.classified=br.doc
         --    and bo.doc=dt.classified
             and (b.date1 is null or b.date1<=pdate+time1)
            -- and b.sysfilial=1
             --  and dty.classified=dt.doctype
             --and bsh.doc=dt.classified
             and dt.docstate = 1000000035
             and (dt.doctype=1065524926 or dt.doctype is null)
             and b.percent is null  /*and b.sysfilial = 1*/ and b.maker = pref.ourbank 
             and tcb_getbillbalacc(pdate,b.classified) != '52406'
             /*and b.classified not in (1091120673,
1091120675,
1091120677,
1091120679,
1091120681, 1066859389,
1115679146)*/;



    return(nvl(ret1,0));
 end if;
 end tcb_billcatsum_new;
 
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

-- Калашникова снова накосичила (сделала группу выпусков ц.б.) => делал update                                                                                    ++
update deposecurity set isgroup = 0 where isgroup = 1

bbr.BBR_TCB_BILL_OPER_MSK
----------------------------------------------------------------------------------
--16/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил отчет bbr.BBR_TCB_BILL_OPER_MSK по задаче IPI 160348 от Герасимовой                                                                                     ++
--- 1. поправил bbr.BBR_TCB_BILL_OPER_MSK (добавил столбец 46 "симв. расх.")                                                                                      ++
--- 2. поправил bbr.BBR_TCB_BILL_OPER_MSK (теперь в столбце 44 "Начисленные проценты за период" возможен "-")  => жду ответа от Герасимовой                       ++
--- 3. навесил в manager для "Досрочного выкупа собственного векселя" на операцию "Оформить" DPC_BillSumCorrection_TCB и DPC_BillSumCorrectionDisc_TCB с условием
--- "Родитель мена" => протестить на athena3, может и не нужно!!! => жду ответа от Герасимовой => делал insertы ниже                                              ++


insert into od.billsum values(1212399267, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399270, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399273, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399276, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399279, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399282, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399285, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399288, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399291, 1042775368, 224808500, 93329.76, null);
insert into od.billsum values(1212399294, 1042775368, 224808500, 93329.76, null);

insert into od.billsum values(1212400503, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400508, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400513, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400518, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400523, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400528, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400533, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400540, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400551, 1042775368, 224808500, 46664.89, null);
insert into od.billsum values(1212400556, 1042775368, 224808500, 46664.89, null);

od.DPC_BillSumCorrection_TCB
od.DPC_BillSumCorrectionDisc_TCB

select * from MemoOrder where doc = 232568296
select * from account where classified = 229190435
select * from doctree where classified = 229190435
select* from balance where account = 229190435



select * from bill where num like '003064%'
select * from billsum where bill = 1212399267
select sum(amount) from billsum where bill = 1212399267 and sumtype = 1042775368
select * from billsumtype where classified = 1042775368
select * from doctree where classified = 221963780
select * from doctype where classified = 1042775240



od.DPC_MO_CheckAccount
select * from bill where num = '0019826'
select * from billsum where bill = 1136487358

select * from bill where num = '0031002'
select * from billsum where bill = 1238893592

select * from bill where num = '0032089'
select * from billsum where bill = 1258041085

select * from bill where num = '0031000'
select * from billsum where bill = 1236227343
select * from doctree where classified = 233274627
select * from doctype where classified = 1065658588

select * from client where classified = 236440086

select * from doctype where classified in (1065672640,1065658588,1155771305,1065659573)
if    ndoctype = 1065672640 then sdtype := 'П';
elsif ndoctype = 1065658588 then sdtype := 'Д';
elsif ndoctype = 1155771305 then sdtype := 'СпД';
elsif ndoctype = 1065659573 then sdtype := 'Пр';
end if;

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- по задаче IPI 152734 от Герасимовой => задачу отменили (в Афине закрытие счетов при обнулении остатка нереально реализовать)    
----------------------------------------------------------------------------------
bbr.BBR_TCB_BILL_RASP_CLOSE_ACC

select ba.account, acccode(ba.account), acclabel(ba.account), ba.bill from billaccount ba where 
      ba.bill in  
      (select bill from billoper where doc in (select classified from doctree where 
      (category = 703 or doctype = 1155771305) and operdate >= to_date(' || to_char(dtDate,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'') and operdate <= to_date(' || to_char(dtDate2+1,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'') and sysfilial = c_access.getfilial and docstate = 1000000035)
      and exists (select * from doctree where classified = ba.account and docstate = 1000000039)
      and (acccode(ba.account) like ''523%'' or acccode(ba.account) like ''52501%'' or acccode(ba.account) like ''52503%'' or acccode(ba.account) like ''52406%'')
      UNION
      select bill from billrange where doc in (select classified from doctree where 
      (category = 703 or doctype = 1155771305) and operdate >= to_date(' || to_char(dtDate,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'') and operdate <= to_date(' || to_char(dtDate2+1,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'')  and sysfilial = c_access.getfilial and docstate = 1000000035))
      and ba.accintention in (1011996343,1011996468,1011996336,1011996470) 
      and exists (select * from doctree where classified = ba.account and docstate = 1000000039)
      and (acccode(ba.account) like ''523%'' or acccode(ba.account) like ''52501%'' or acccode(ba.account) like ''52503%'' or acccode(ba.account) like ''52406%'')
      UNION
      -- залоги и хранения
      select ba.account, acccode(ba.account), acclabel(ba.account), ba.bill from billaccount ba where 
       ba.pact in
      (
      select doc from billstatushistory where bill in 
      (
      select bill from billoper where doc in (
      select dt.classified from doctree dt where 
      dt.doctype in (1110316673,1113093181/*новые залоги и хранения*/) and dt.operdate >= to_date(' || to_char(dtDate,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'') and dt.operdate <= to_date(' || to_char(dtDate2+1,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'') and dt.sysfilial = c_access.getfilial and dt.docstate = 1000000035)
      union
      select bill from billrange where doc in (
      select dt.classified from doctree dt where 
      dt.doctype in (1110316673,1113093181/*новые залоги и хранения*/) and dt.operdate >= to_date(' || to_char(dtDate,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'') and dt.operdate <= to_date(' || to_char(dtDate2+1,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'') and dt.sysfilial = c_access.getfilial and dt.docstate = 1000000035)
      ) and status in (34,38) 
          and enddate <= to_date(' || to_char(dtDate2+1,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'')
          and enddate >= to_date(' || to_char(dtDate,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'')
      )
      and exists (select * from doctree where classified = ba.account and docstate = 1000000039)
      and (acccode(ba.account) like ''91202%''  or acccode(ba.account) like ''90803%'' /*новые счета по залогам и хранениям*/)
      and od.accountBalance(ba.account,to_date(' || to_char(dtDate2+1,'''dd.mm.yyyy''') || ' , ''dd.mm.yyyy'')) = 0
      order by 4

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
--18/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- письмо от Молодовой                                                                                                                                         ++
select * from deal where infoadvise is not null and dealdate = td
select * from deal where doc = 237136709
select * from dealtransaction where doc in (109727983,75592561)
od.dpc_info72deal
od.CreateDealConfirm;
od.FXDeal_TimedBeg

----------------------------------------------------------------------------------
--21/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_DEALDEPOSITAMEND_CANCEL

select 5000*0.0875*((31-21-1)/365) from dual
select 150000*0.0875*((31-16-1)/365) from dual

od.DPC_RB_REESTRINIT

select * from doctree where classified = 224880368

select * from docstate

----------------------------------------------------------------------------------
--22/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- удалил транш МБК с АКА
update doctree set parent = null where classified = 224880368
update doctree set parent = null where classified = 226024751

select * from doctree where classified = 224880368
select* from doctype where classified = 1000135223
select * from doctree where classified = 224880232
select* from doctype where classified = 1179850206
select * from docstate
od.DPC_RB_REESTRINIT 

-- 3 проблемы по траншам МБК                                                                                                                                      
---- некорректное начисление %% по траншам с ОПЕРУ => проблема из-за того, что начисление было позже уплаты => отписал в задачу                                   ++
select * from account where code = '47426810050010010000'
select * from od.accountwithreestr where account = 226017125
select * from reestr where accountwithreestr = 1255463845
select * from reestrdoc where accountwithreestr = 1255463845

select * from account where code = '47426810150010020000'
select * from od.accountwithreestr where account = 226016997
select * from reestr where accountwithreestr = 1255462851
select * from reestrdoc where accountwithreestr = 1255462851

select * from doctree where classified = 237355371
select * from doctree where classified = 237352583
select * from doctree where classified = 237351519
select * from doctype where classified = 1000135307
select * from doctype where classified = 1000160977
select* from DealTrAccount where account = 226017125

select * from DealSwapPayPeriod where paymentline in (select classified from DealSwapPayment where doc = 226012817)
select * from DealSwapPayment where doc = 226012817
delete from DealSwapInterestLog where doc = 226012817 and paydoc in (select classified from doctree where docstate = 1000000037)
select * from DealSwapInterestLog where doc = 226012817 and paydoc in (select classified from doctree where docstate = 1000000037)
select paydoc, (select description from doctree where classified = ds.paydoc) from DealSwapInterestLog ds where doc = 226012817 and paydoc in (select classified from doctree where docstate = 1000000037)

select * from doctree where classified = 237501167

select * from doctree where classified = 237481764
select * from doctype where classified = 1047170421
select * from od.constants
select * from docstate

(select DSPP.BegChargeDate, DSPP.EndChargeDate, abs(DSPP.AccrualAmount) Amount, abs(DSP.Amount) PayAmount,
                        DSPP.PaymentLine,-- текущий платежный период
                        lead(DSPP.PaymentLine) over(order by DSPP.BegChargeDate asc) NextPayment, DCT.classified, DCT.DocState 
                   from DealSwapPayPeriod DSPP, DealSwapPayment DSP, Doctree DCT
                  where DSPP.PaymentLine = DSP.Classified
                    and DSP.Doc = 226015768
                    and DSP.Classified = DCT.Operobj
                    and DCT.Parent = DSP.Doc
                    and DCT.Category = 905
                   --and DCT.DocState not in(Constants.State_Close, Constants.State_Cancel, Constants.State_RollBack
                   )
               order by DSPP.BegChargeDate asc
               
Select Type, TypeLabel, OperDate, abs(Amount), PayDoc, PayDocLabel, DocStateLabel
 From v_DealSwapIntLog
 Where PayPer = 1262126520
   Order by OperDate, Classified Asc

select * from doctree where classified = 237481764
select * from doctype where classified = 1047170421

---- IFC 
select * from account where code = '47426840000000100092'
select * from od.accountwithreestr where account = 141314068
select * from reestr where accountwithreestr = 1252214949
select * from reestrdoc where accountwithreestr = 1252214949

select * from dealaccount where rsaccount = 224661326


od.dpc_dealtrans_settransacc



---- выровнять реестры по трем сделкам (PNC,KFW,AKA)       06/11/2013                                                                                             ++

select * from account where code = '47426840600001000054'
select * from od.accountwithreestr where account = 35176392
select * from reestr where accountwithreestr = 1252217373
select * from reestrdoc where accountwithreestr = 1252217373
---- PNC ++
update reestr set docsum = 63336.61 where docsum = 12045.61 and accountwithreestr = 1252217373
delete reestr where reestrinit not in (237251194) and accountwithreestr = 1252217373
update reestrdoc set docsum = 63336.61 where reestrinit = 237251194 and accountwithreestr = 1252217373
delete reestrdoc where classified not in (237251194,239230277) and accountwithreestr = 1252217373

select * from account where code = '47426840300002000049'
select * from od.accountwithreestr where account = 29445503
select * from reestr where accountwithreestr = 1252217212
select * from reestrdoc where accountwithreestr = 1252217212
---- KFW ++
update reestr set docsum = 42021.83 where docsum = 10421.42 and accountwithreestr = 1252217212
delete reestr where reestrinit not in (237390665) and accountwithreestr = 1252217212
update reestrdoc set docsum = 42021.83 where reestrinit = 237390665 and accountwithreestr = 1252217212
delete reestrdoc where classified not in (239230182,237390665) and accountwithreestr = 1252217212

select * from account where code = '47426978800001000085'
select * from od.accountwithreestr where account = 109041489
select * from reestr where accountwithreestr = 1252212047
select * from reestrdoc where accountwithreestr = 1252212047
---- AKA ++
update reestr set docsum = 2742.24 where docsum = 524.75 and accountwithreestr = 1252212047
delete reestr where reestrinit not in (225472292,226024752,239097955) and accountwithreestr = 1252212047
update reestrdoc set docsum = 2742.24 where reestrinit = 239097955 and accountwithreestr = 1252212047

237480630
239097955

select * from doctree where classified = 237480630
select * from doctype where classified = 1179850206

-- написать инструкцию по кредитным линиям МБК (v.3) с доп.соглашениями                                                                                          ++
-- 05/11/2013 выложить в задачу, на портал (IPI 163195)                                                                                                          ++        
-- закрыть задачу IPI 56516                                                                                                                                      ++

----------------------------------------------------------------------------------
--23/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_DealDepAddAgreementClose
od.DPC_ChangeDealDeposit

select 48700*(0.0165+0.0034)*((6+31+31+28+31+30+22)/360) from dual
od.getdealrate_tcb

-- пропадают периодические амортизации из графика платежей после ввода доп. соглашения, которое не меняет параметры периодической амортизации (проблема с AKA от 30/12/2010)
-- (пересчеты графиков не помогают) (помогает только поменять дату окончания периодической амортизации на что-нибудь аналогичное) => написал в НА 23/10/2013 =>   
-- 23/10/2013 зарегистрировали замечание 49151 => 25/10/2013 прислали скрипт deal1199.sql => 28/10/2013 накатил на боевую !!!                                     ++


-- два отчета для Ледовской в RN ("Отчет_финдеп (привлечение)" и "Отчет_финдеп (размещение)") по задаче IPI 161493                                                ++
--- "Отчет_финдеп (привлечение)":                                                                                                                                 ++
---- есть старые неисполненные сделки МБК (4 штуки)
---- из-за отсутствия квитовки рублевых переводов из др. банка с плановыми проглючивают остатки на дату отчета
--- "Отчет_финдеп (размещение)"                                                                                                                                   ++
--- 01/11/2013 дорабатывал отчеты по задаче IPI 161493 => 05/11/2013 отписал в задачу, тестят                                                                     ++
--- 24/01/2014 дорабатывал отчеты по задаче IPI 161493                                                                                                            ++

select * from deal where portfolio is not null
select * from dealportfolio

select * from dealaccintention where classified in (1000105424,1000105425,1000105426,1000105427)
and da1.accintention in (1000105424,1000105425)
and da2.accintention in (1000105426,1000105427)
select * from dealaccount
select * from dealaccount where doc = 217727080
select acccode(classified) from account where classified = 191722180
select  clientregion(clientregion) from client
select * from clientregiontree where classified = 1000132730

(select (select label from clientregiontree where classified = clientregion) from client where classified = 90417)
(select (select label from clientregiontree where lev = 0 connect by prior parent = classified start with classified = clientregion) from client where classified = 16822)
select label from clientregiontree where lev = 0 connect by prior parent = classified start with classified = clientregion
select * from dealdeposit where doc = 217727080
select sum(abs(amount)) from dealswappayment where doc = 217727080 and amount < 0 and paymenttype in (1,4) and valuedate >= td and valuedate < td+30 

select * from balance where account = (select classified from account where code = '31303810300000000964')
select * from balance where account = (select classified from account where code = '31303810000000001810')

od.reestrrestout
select label from clientregiontree connect by prior classified = parent start with classified = 1000043360
select * from clientregiontree

select * from account where code = '31303810300000000964'
select * from od.accountwithreestr where account = 196688193
select * from reestr where accountwithreestr = 1197161957
select * from reestrdoc where accountwithreestr = 1197161957
select * from dealaccount where doc = 234191453

select * from account where code = '31303810000000001810'
select * from od.accountwithreestr where account = 183081179
select * from reestr where accountwithreestr = 1181361979
select * from reestrdoc where accountwithreestr = 1181361979
select * from dealaccount where doc = 234200809



----------------------------------------------------------------------------------
--25/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил реквизиты в ужеисполненных событиях по просьбе Хейзе
select rowid, d.* from dealtransaction d where doc = 238012515;
update dealtransaction set beneficiarybankcode = '044585684' where doc = 238012515;
update dealtransaction set account57A = '30101810100000000684' where doc = 238012515;
update dealtransaction set beneficiarybankname = 'BIC: 044585684 INN: 5011002908 K/S:30101810100000000684' where doc = 238012515;
 
select rowid, d.* from dealtransaction d where doc = 238012518;
update dealtransaction set beneficiarybankcode = '044585684' where doc = 238012518;
update dealtransaction set account57A = '30101810100000000684' where doc = 238012518;
update dealtransaction set beneficiarybankname = 'BIC: 044585684 INN: 5011002908 K/S:30101810100000000684' where doc = 238012518;
 238012518


od.dealdep_proc

-- добавил в отчет BBR_TCB_BILLOWN_DATE_REP ЕВРО по просьбе Филимоновой                                                                                           ++
select* from currency

----------------------------------------------------------------------------------
--28/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 238293022
select * from doctree where classified = 238293011
select * from doctype where classified = 1033696172

od.dealdep_proc
procedure CreateDepSheduleOfPayments(
   /******************************************************************************
    Автор:    Шубин Р.
    Описание: Создать график платежей на основе графика процентов.
    Версия:   17.04.2012
              08.06.2012 AGN
              04.12.2012 - учтен расчет подробностей без округления (Зам. № 44099, AGN)
              16.01.2013
              --28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
   *****************************************************************************/
      idDoc    DT.Reference,       -- документ.
      nInit    DT.Status default 1 -- инициализация переменных
   ) as
      idPaymentLine   DT.Reference;                  --
      nAmountPay      DT.Amount;
   begin
      if nvl(nInit, 1) = 1 then
         InitVariables(idDoc);
      end if;
      -- выплаты по процентам:
      -- nSign := i.f(recDealDep.IsReceive = 1, -1, 1);
--28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
for recDSI in
         (
            select sum(P.AMOUNT) Amount, P.PayDate InterestDate, NTLCurrency,
                   P.PaymentLine
              from DealSwapInterest DSI, DealSwapPayPeriod P
             where DSI.Doc = idDoc
               and P.InterestPeriod = DSI.Classified
          group by P.PaymentLine, P.PayDate, NTLCurrency
         )
      loop
         nAmountPay :=  round(recDSI.Amount, nvl(MinorUnit(recDSI.NTLCurrency), 2));
         update DealSwapPayment
            set Amount = nAmountPay,
                Currency = recDSI.NTLCurrency,
                IsNetting = recDeal.IsNetting
          where Doc = idDoc and Classified = recDSI.PaymentLine;
         if sql%notfound then
            insert into DealSwapPayment (Doc, ValueDate, Currency, Amount,
                                          PaymentType, IsNetting, NettAmount)
               values (idDoc, recDSI.InterestDate, recDSI.NTLCurrency, nAmountPay,
                        nPaymentType_Interest, 0, null)
               returning Classified into idPaymentLine;
            update DealSwapPayPeriod
               set PaymentLine = idPaymentLine
             where PayDate = recDSI.InterestDate
               and InterestPeriod in (select Classified from DealSwapInterest
                                       where NTLCurrency = recDSI.NTLCurrency
                                         and Doc = idDoc);
         end if;
      end loop;
      -- основные суммы + амортизация.
      GeneralAmountExchange;
      -- перенумерация платежей.
      ReCalculateSheduleOfPayments(idDoc);
   end CreateDepSheduleOfPayments;
   
   
   
od.AVR_TMP_TCB   


select
  cv.VALIDFROMDATE
 ,cv.VALIDTODATE
 ,cd.AMOUNTFROM
 ,cd.AMOUNTTO
 ,ct.AMOUNTFROM
 ,ct.AMOUNTTO AMOUNTTO_2
 ,ct.percrate
 ,ct.ratevariant
from od.CRateVersion cv, od.CRateDependence cd, od.CRateTable ct where cv.rate =  1263746632 and cd.rateversion = cv.classified
  and ct.ratevariant = cd.classified

----------------------------------------------------------------------------------
--29/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.bbook

select * from bbook where parent in (
select dt.parent from reestrdoc rd, doctree dt where dt.classified = rd.doc and rd.doc in
(
select doc from reestrdoc where reestrinit in
(
select doc from reestrdoc rd where initdoc in
(
select /*nDealID --*/209250460 from dual
--union
--select deal from dealrollover connect by prior deal = doc start with doc = /*nDealID --*/209250460
) and doc in (select rsaccount from dealaccount where doc = rd.initdoc and rsaccount is not null and accintention in (select classified from dealaccintention where constintention in (15,16,17,18)))
) --and docsum > 0
) 
--and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and doctype = 1047177856)
--and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and description like 'Пролонгация%')
)

od.UT_DealAccrual_EveryDayFT_TCB

----------------------------------------------------------------------------------
--30/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- снова проблемы с IPI 130215 => возникла проблема с меной в Пермском филиале (почему-то сформировался доход по никакому векселю) DPC_BillSumCorrectionDisc_TCB =>
-- проблема была из-за того, что на векселе была указана процентная ставка досрочного учета векселя                                                              ++

od.DPC_BillSumCorrectionDisc_TCB
od.DPC_BillSumCorrection_TCB

select distinct * from bbook b where b.debaccount in (
select account from dealaccount d where d.accintention in (select classified from dealaccintention where constintention in (15,16,17,18)) and doc = /*nDealID --*/209250460
and d.rsaccount is null -- смотрим только нереестровые счета
)
union
select * from bbook b where b.credaccount in (
select account from dealaccount d where d.accintention in (select classified from dealaccintention where constintention in (15,16,17,18)) and doc = /*nDealID --*/209250460
and d.rsaccount is null -- смотрим только нереестровые счета
)
union
-- этот кусок для реестровых счетов
select * from bbook where parent in (
select dt.parent from reestrdoc rd, doctree dt where dt.classified = rd.doc and rd.doc in
(
select doc from reestrdoc where reestrinit in
(
select doc from reestrdoc rd where initdoc in
(
select /*nDealID --*/209250460 from dual
--union
--select deal from dealrollover connect by prior deal = doc start with doc = /*nDealID --*/209250460
) and doc in (select rsaccount from dealaccount where doc = rd.initdoc and rsaccount is not null and accintention in (select classified from dealaccintention where constintention in (15,16,17,18)))
) --and docsum > 0
) 
--and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and doctype = 1047177856)
--and not EXISTS (select * from doctree where classified = od.parentdoc(rd.doc) and description like 'Пролонгация%')
)


select * from bbook where classified = 73844637
select * from doctree where classified = 73844637 
select * from doctype where classified = 1000135265
select * from doctree where classified = 73844628
select * from doctype where classified = 1033718051

select * from doctree where classified = 226349260
select * from doctree where classified = 209944798
select * from doctype where classified = 1047492427

select * from reestrdoc where doc = 209943962
select rd.* from reestrdoc rd, doctree dt where dt.classified = rd.doc and dt.parent = 209943962


select d.doc from deal d, doctree dtr where d.doc = dtr.classified and dtr.category = 908 and
EXISTS (
select * from dealaccount da where d.doc = da.doc and da.accintention in (select classified from dealaccintention where constintention in (15,16,17,18))
and (da.account in (select debaccount from bbook where parent = 209911382/*nBbookParent --*/) or account in (select credaccount from bbook where parent = 209911382/*nBbookParent --*/)) 
and ( 
(da.rsaccount is null)
or
exists (select rd.doc, rd.initdoc ,rd.reestrinit, rd.accountwithreestr from reestrdoc rd, doctree dt where dt.classified = rd.doc and da.rsaccount = rd.reestrinit 
  and dt.parent = 209911382/*nBbookParent --*/)
)
)


----------------------------------------------------------------------------------
--31/10/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_BillOper
select * from clienttype where classified = 1000001778
od.UT_DEALACCRUAL
select * from doctree where classified 

select DT.Classified, DT.GenIntention, DT.docstate, DT.DOCTYPE
     from EntityMethod EM, EntityPropValue EPV, EntityState ES, DocTree DT
    where EM.SQLNAME = 'DEALACCRUAL'  and DT.Doctype = 1179850206
      and EPV.PropValue = EM.Classified and EPV.PropType = 1
      and EPV.EntityState = ES.Classified
      and DT.DocType = ES.EntityClass and Dt.EntityState = ES.Classified
      and DT.SysFilial = 1
      and exists (select null from Deal
                   where Doc = DT.Classified
                     and ValueDate - 1 < trunc(td)
                     and (td <= MaturityDate or MaturityDate is null)
                     and DealDate <= (select s.ysdate from dual))
      and exists (select null from DealAccount DA, DealAccintention DAI
                   where DA.AccIntention = DAI.Classified
                     and DA.Doc = DT.Classified
                     and DAI.ConstIntention in (17, 18))

select * from DealSwapPayPeriod where paymentline in (select classified from DealSwapPayment where doc = 193953201)
(select * from DealSwapPayment where doc = 193953201)
select * from v_DealSwapIntLog

select * from DealSwapPayment where doc = 193953201
--delete from DealSwapInterestLog where doc = 193953201 and paydoc in (select classified from doctree where docstate = 1000000037)
select * from DealSwapInterestLog where doc = 229472529 and paydoc in (select classified from doctree where docstate = 1000000037)
select paydoc, (select description from doctree where classified = ds.paydoc) from DealSwapInterestLog ds where doc = 193953201 and paydoc in (select classified from doctree where docstate = 1000000037)


-- проблема с журналом начисления по ВТБ на 1 500 000 000 => делал update                                                                                           ++
--update DealSwapInterestLog set payperiod = 1256291109 where doc = 193953201 and classified in(1275669795,1275669796)
--update DealSwapInterestLog set payperiod = 1193578299 where doc = 193953201 and classified in(1256291115,1256291116)

-- Ледовская попросила, чтобы все события по Банку России просле В ДВР автоматически исполнялись => добавил в manager для операции "Обработать" "События депозитной
-- сделки" исполнение действия "Исполнить" с учловием "Клиент BKRZ?"                                                                                                ++

select 150000*0.0875*(15/365) from dual

---- выровнять реестр по сделке с CSOB от 23/08/2013      05/11/2013                                                                                                ++     
select * from account where code = '47426978150000000095'
select * from od.accountwithreestr where account = 174674393
select * from reestr where accountwithreestr = 1255933504
select * from reestrdoc where accountwithreestr = 1255933504

-- CSOB
update reestr set docsum = 4990.93 where docsum = 3940.21 and accountwithreestr = 1255933504;                     -- изменяем сумму в занесении
update reestr set docsum = 9062.48 where docsum = 8011.76 and accountwithreestr = 1255933504;                     -- изменяем сумму в занесении
update reestrdoc set docsum = 4990.93 where docsum = 3940.21 and accountwithreestr = 1255933504;                  -- изменяем сумму в занесении

select * from DealSwapInterestLog where doc = 229472529
--update DealSwapInterestLog set amount = 3940.21 where doc = 229472529 and paydoc = 234623852
--update DealSwapInterestLog set amount = 4071.55 where doc = 229472529 and paydoc = 239106406

4990.93

select 3940.21 + 1050.72 + 1050.72 from dual

select * from doctree where classified = 229472529


----------------------------------------------------------------------------------
--01/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 239203244

od.UT_DealAccrual_EveryDayFT_TCB
select sysdate from dual

select * from deal where doc = 238522794

-- Ледовская просила сделать более понятное сообщение, при невозможности "Обработать" событие, когда дата обработки <> дата валютирования =>
-- сделать процедуру DPC_FXEvent_CheckDate_TCB, аналогичную DPC_FXEvent_CheckDate, и повесить её для "События депозитной сделки" на "Обработать"
-- перед DPC_FXEvent_CheckDate                                                                                                                                     ++ 

od.DPC_FXEvent_CheckDate
select * from deal
select * from client

create or replace procedure DPC_FXEvent_CheckDate_TCB
/**********************************************************************************
 Описание: Проверка наступления даты валютирования для событий, на основе DPC_FXEvent_CheckDate 
05/11/2013 - Панфилов М.С. в описании ошибки показываем контрагента, дату сделки 
**********************************************************************************/
as
   dtValueDate             date;
   sClient                 Client.Label%type;
   dtValueDate2            date;
begin
   select ValueDate into dtValueDate from DealTransaction where Doc = Context.CurrentDoc;
   
   select clientlabel(counterparty), ValueDate into sClient, dtValueDate2 from deal where doc = parentdoc(Context.CurrentDoc);
   
   if dtValueDate is null then
      raise_application_error(-20000, 'По событию '||teller_proc.DocIdent( Context.CurrentDoc )||' не задана дата валютирования!');
   end if;
   if trunc(Context.OperDate) != trunc(dtValueDate) then
      raise_application_error(-20000, 'Дата валютирования по событию '||teller_proc.DocIdent( Context.CurrentDoc )||' от '|| to_char(dtValueDate,'DD/MM/YYYY') ||') по сделке с ' || sClient || ' от ('|| dtValueDate2 || ' не совпадает с датой обработки!');
   end if;
end DPC_FXEvent_CheckDate_TCB;




-- снова неверное назначение платежа у Бакумцевой (теперь вторая дата) => сделал отдельный тег в DEAL_GetPaymentPurpose + функцию DealBegProcDate3 + 
-- поправить MBC30 и MBC31 в справочнике назначений                                                                                                                 ++
create or replace function DealBegProcDate3(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления даты окончания предыдущего периода начисления процентов по траншу.
-- Автор: Панфилов М.С. (на основе DealBegProcDate2)
-- Версия: 14.04.2011
--         10.06.2013 адаптирована для сделок траншей МБК (Зам. № 46876)
--         13.06.2013 Панфилов М.С.
--         03/07/2013 Панфилов М.С. - теперь учтен вариант, когда уже была только одна дата учета процентов.
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference  -- идентификатор сделки
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
     dbms_output.put_line(' ppp0 dtPercBegDate  ='||dtPercBegDate);
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null or nIsTransh = 0 then
      --это не депозитная сделка
      return null;
   end if;
   if nIsTransh = 1 then
      dtPercbegdate := dtStartdealdate; -- 29/07/2013 Панфилов М.С. - если c DealSwapInterestLog всё плохо, то чтобы не вылетало
      -- дата начала предыдущего периода начисления процентов по траншу
      begin
      select bd into dtPercbegdate from
          (SELECT trunc(bd) as bd,
                  row_number () OVER (ORDER BY (trunc(bd)) DESC) rang
              FROM (select DISTINCT trunc(OperDate) as bd, doc from DealSwapInterestLog
                    union
                    select trunc(d.valuedate), d.doc from deal d
                   ) b
             WHERE doc = nDoc) x where x.rang = 1;
      exception when others then null;
      end;
   end if;
        dbms_output.put_line(' ppp1 dtPercBegDate  ='||dtPercBegDate);
   return dtPercBegDate;
end DealBegProcDate3;

create or replace function DEAL_GetPaymentPurpose
/******************************************************************************
 Автор: Цветков В.
 Описание: Получение шаблона строки назначения платежа из PAYMENTPURPOSE по ключу и раскрытие макросов
 24.06.2010 по заданию 2161-У.
 Версия:
 13.11.2010 Доработка 31804: function DEAL_GetPaymentPurpose -
                Исправлено раскрытие макроса <DocOperDate> и <DealDate>(формат)
 19.04.2011 Новые тэги
 16.05.2011 Тэг <TICKET> (тикет сделки)
 27.05.2011 вместо nDoc должен быть nDeal в вызове BEGPROCDATE и в процедуре
            LoadDealNettingRec.
 12.12.2012 добавлен тэг BEGACCRDATE - дата начала начисления процентов (Зам. № 44161, AGN)
 08.02.2013 добавлена возможность прямой распаковки шаблона строки без использования справочника (Дор. № 12438, AGN)
 13.06.2013 Панфилов М.С. добавлены тэги <CLLabel>, <CLVALUEDATE>, <BEGPROCDATE2>
 01.11.2013 Панфилов М.С. добавлен тэг <BEGPROCDATE3>
 ******************************************************************************/
(  sTemplateCode  DT.Text,        -- Код строки-шаблона
   nDeal          DT.Reference,   -- Сделка
   nDoc           DT.Reference,   -- Документ
   sExtraText     DT.Text,         -- Дополнительный текст
   nDirectExpand  DT.Status default 0 -- прямая распаковка шаблонов строки без справочника
)
return DT.Text as
   sPurpose       DT.Text;
   recDeal        Deal%rowtype;
   recDocTree     DocTree%rowtype;
   recDealReserv  DealReserv%rowtype;
   recDealROLL    Deal%rowtype;
   recDealDeposit DealDeposit%rowtype;
   recDealNetting DealNetting%rowtype;
   recDealTrans   DealTransaction%rowtype;
   recDocTreeCL   DocTree%rowtype;
   recDealCL      Deal%rowtype;
   --
   sCurrTag       Dt.Text;
   sDTFMT         constant Dt.Label := 'DD/MM/YYYY';
   sDTFMT1        constant Dt.Label := 'DD.MM.YY';
   dtDateTemp     Date;
   --
   procedure LoadDealRec as
      cursor c is select * from Deal where Doc = nDeal;
   begin
      if recDeal.Doc is null then
         open c;
         fetch c into recDeal;
         close c;
      end if ;
   end LoadDealRec;
   --
   procedure LoadDocRec as
      cursor c is select * from DocTree where Classified = nDoc;
   begin
      if recDoctree.Classified is null then
         open c;
         fetch c into recDocTree;
         close c;
      end if ;
   end LoadDocRec;
   --
   procedure LoadDealReservRec as
      cursor c is select * from DealReserv where Doc = nDoc;
   begin
      if recDealReserv.Doc is null then
         open c;
         fetch c into recDealReserv;
         close c;
      end if ;
   end LoadDealReservRec;
   --
   procedure LoadDealRollRec as
      cursor c is select * from Deal where Doc =
         (select Deal from DealRollover where Doc = nDeal);
   begin
      if recDealRoll.Doc is null then
         open c;
         fetch c into recDealRoll;
         close c;
      end if ;
   end LoadDealRollRec;
   --
   procedure LoadDealDepositRec as
      cursor c is select * from DealDeposit where Doc = nDeal;
   begin
      if recDealDeposit.Doc is null then
         open c;
         fetch c into recDealDeposit;
         close c;
      end if ;
   end LoadDealDepositRec;
   --
   procedure LoadDealNettingRec as
      cursor c is select * from DealNetting where Doc = nDeal;--nDoc;
   begin
      if recDealNetting.Doc is null then
         open c;
         fetch c into recDealNetting;
         close c;
      end if ;
   end LoadDealNettingRec;
   --
   procedure LoadDealTransRec as
      cursor c is select * from DealTransaction where Doc = nDoc;
   begin
      if recDealTrans.Doc is null then
         open c;
         fetch c into recDealTrans;
         close c;
      end if ;
   end LoadDealTransRec;
   --
   procedure LoadDocCLRec as
      cursor c is select * from DocTree where Classified = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDocTreeCL.Classified is null then
         open c;
         fetch c into recDocTreeCL;
         close c;
      end if ;
   end LoadDocCLRec;
   --
   procedure LoadDealCLRec as
      cursor c is select * from Deal where Doc = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDealCL.Doc is null then
         open c;
         fetch c into recDealCL;
         close c;
      end if ;
   end LoadDealCLRec;
   --
begin
      if nDirectExpand = 1 then
      sPurpose := sTemplateCode;
      else
        begin
        select value into sPurpose from dealpaymentpurpose where fullname =  sTemplateCode;
        exception when NO_DATA_FOUND then
        --raise_application_error(-20000, 'Шаблон не найден. Код ' || sTemplateCode) ;
        tm_proc.RaiseError(42212, sTemplateCode);
        end;
      end if;
--   dbms_output.put_line('1 ' || spurpose);

   sCurrTag := '<DealLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('2 ' || spurpose);

   sCurrTag := '<DealDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDeal.DealDate); --to_char(recDeal.DealDate,'DD.MM.YYYY'));
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT));
   end if ;

--   dbms_output.put_line('3 ' || spurpose);

   sCurrTag := '<ExtraText>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag, sExtraText);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocDescription>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Description);
   end if ;

--   dbms_output.put_line('5 ' || spurpose);

   sCurrTag := '<DocOperDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDocTree.OperDate);
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT));
   end if ;

--   dbms_output.put_line('6 ' || spurpose);

   sCurrTag := '<RiskGroup>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        if recDocTree.Category = 914 then
            LoadDealReservRec;
            sPurpose := replace(sPurpose, sCurrTag, PactRiskGrouplabel(NVL(recDealReserv.RiskGroup, recDealReserv.OldRiskGroup)));
        else
            sPurpose := replace(sPurpose, sCurrTag, '');
        end if;
   end if ;

--   dbms_output.put_line('7 ' || spurpose);

   sCurrTag := '<COUNTERPARTY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDeal.CounterParty));
--dbms_output.put_line('8 ' || spurpose);
   end if ;

   sCurrTag := '<TICKETROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, recDealRoll.Ticket);
--dbms_output.put_line('9 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealRoll.CounterParty));
--dbms_output.put_line('10 ' || spurpose);
   end if ;

   sCurrTag := '<ROLLDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealDepositRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealDeposit.RollOverStartDate,sDTFMT));
--dbms_output.put_line('11 ' || spurpose);
   end if ;


   sCurrTag := '<OPERDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT1));
--dbms_output.put_line('12 ' || spurpose);
   end if ;

   sCurrTag := '<EXTRACT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Extract);
--dbms_output.put_line('13 ' || spurpose);
   end if ;

   sCurrTag := '<TRANSACTDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT1));
--dbms_output.put_line('14 ' || spurpose);
   end if ;

   sCurrTag := '<VALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealNetting.ValueDate,sDTFMT1));
--dbms_output.put_line('15 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYNET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealNetting.CounterParty));
--dbms_output.put_line('16 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARYBANK>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.BeneficiaryBank));
--dbms_output.put_line('17 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.Beneficiary));
--dbms_output.put_line('18 ' || spurpose);
   end if ;

   sCurrTag := '<BEGPROCDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate(nDeal),sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;
   -- дата начала начисления %%
   sCurrTag := '<BEGACCRDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      dtDateTemp := trunc(DealBegProcDate(nDeal)); -- дата последнего начисления %%
      if dtDateTemp > recDeal.ValueDate + 1 then
         dtDateTemp := dtDateTemp + 1;
      else
         dtDateTemp := recDeal.ValueDate + 1;
      end if;
      sPurpose := replace(sPurpose, sCurrTag, to_char(dtDateTemp,sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONAMOUNT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        recDealTrans.Amount);
--dbms_output.put_line('20 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealTrans.ValueDate,sDTFMT));
--dbms_output.put_line('21 ' || spurpose);
   end if ;

   sCurrTag := '<DOCTREEDOCVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDocTree.DocValueDate,sDTFMT));
--dbms_output.put_line('22 ' || spurpose);
   end if ;

    --тикет сделки (Deal.TICKET)
   sCurrTag := '<TICKET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, recDeal.Ticket);
   end if ;

   --кредитная линия по траншу (Deal.CREDITLINE.Label)
   sCurrTag := '<CLLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocCLRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTreeCL.Label);
   end if ;

   --дата начала кредитной линии по траншу (Deal.CREDITLINE.VALUEDATE)
   sCurrTag := '<CLVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealClRec;
        sPurpose := replace(sPurpose, sCurrTag, to_char(recDealCL.ValueDate,sDTFMT));
   end if ;

   --дата начала предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE2>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate2(nDeal),sDTFMT));
   end if ;
   
   --дата окончания предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE3>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate3(nDeal),sDTFMT));
   end if ;

   return SUBSTR(sPurpose,1,254);

end DEAL_GetPaymentPurpose;

select * from DealSwapInterestLog where doc = 225709496

----------------------------------------------------------------------------------
--05/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
-- ищем банки для передачи в БКИ
select c.* from client c where c.type in (select classified from clienttype where cltypeconst = 2)
and 
(
c.classified in (select obj from od.objdesc where desctext = 0 and description = DescClass(5202))
or 
SYSDATE >= to_date(getobjdesc(c.classified,DescClass(5203)),'ddmmyyyyhh24miss')
)
----------------------------------------------------------------------------------



select to_date('23.12.2013','dd.mm.yyyy') - to_date('30.09.2013','dd.mm.yyyy') from dual

229 472 529

od.accountbalance

select * from dealaccount  where doc = 229472529
select reestrrestout(234623825,to_date('30.09.2013','dd.mm.yyyy')) from dual 

   select DocSum into nRest
     from Reestr
    where ReestrInit = idInitDoc
      and Type = nType
      and BegDate <= dtDate
      and EndDate > dtDate;

select * from account where code = '47426978150000000095'
select * from od.accountwithreestr where account = 174674393
select * from reestr where accountwithreestr = 1255933504
select * from reestrdoc where accountwithreestr = 1255933504


select * from DealSwapInterest  where doc = 226591114
select * from Dealswappayperiod  where interestperiod = 1285874279
select * from DealSwapInterestLog where doc = 193953201 and paydoc in (select classified from doctree where docstate = 1000000037)
select paydoc, (select description from doctree where classified = ds.paydoc) from DealSwapInterestLog ds where doc = 193953201 and paydoc in (select classified from doctree where docstate = 1000000037)


select * from doctree where classified =  233583223
select * from deal where doc =  233583223

select * from account where code = '31302810200000002733'
select * from od.accountwithreestr where account = 6942372
select * from reestr where accountwithreestr = 1116805260
select * from reestrdoc where accountwithreestr = 1116805260

select * from deal where doc = 234216149

----------------------------------------------------------------------------------
--06/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.UT_DealAccrual_EveryDayFT_TCB

select * from od.DealSwapInterest where doc = 225709496

select * from od.DealSwapInterest where doc = 222749473

select * from od.DealSwapInterest where doc = 224891050

select * from od.DealSwapPayPeriod where interestperiod in (1285876651,1275688099,1266328153)
select * from deal
od.getdealrate_tcb

-- отчет для Бакумцевой в RN "Отчеты - Афина - БэкОфис – Реестр сделок по привлечению МБК за период"                                                             ++
---- написать функцию DealCalcEqv_tcb => тестит Бакумцева                                                                                                        ++
---- написать функцию DealCalcEqv2_tcb => тестит Бакумцева                                                                                                       ++
---- доделать группировки по валютам                                                                                                                             ++
create or replace function DealCalcEqv_tcb(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления рублевого эквивалента суммы начисленных процентов на процентном периоде по траншу МБК.
-- для отчета для Бакумцевой в RN "Отчеты - Афина - БэкОфис – Реестр сделок по привлечению МБК за период"
-- Автор: Панфилов М.С.
-- Версия: 20/11/2013
----------------------------------------------------------------------------------------------
   nDealSwapInterest   in dt.reference,  -- идентификатор процентного периода (DealSwapInterest) 
   startdate           in date,
   enddate             in date,
   variant             in number
) return dt.Amount
is
  res dt.Amount := 0;
  dsi DealSwapInterest%rowtype; 
  dd  DealDeposit%rowtype; 
  std date;
  edd date;
  valuedate date;
begin
  select dsi.* into dsi from DealSwapInterest dsi where classified = nDealSwapInterest;
  select dd.* into dd from DealDeposit dd where dd.doc = (select doc from DealSwapInterest where classified = nDealSwapInterest);
  select valuedate into valuedate from Deal where doc = dd.doc;
    
  std := startdate;
  --if dsi.startdate = valuedate then std := std+1; end if; -- 21/11/2013 Панфилов М.С.
  while std <= enddate
    loop
      if last_day(std) < enddate then edd := last_day(std); else edd := enddate; end if;
           
if variant = 1 then
   res := res + round(round(nvl(((nvl(dsi.ntlamount,0) / (case when dd.interestbase = 0 or dd.interestbase = 360 then 360 when dd.interestbase = 1 or dd.interestbase = 365 then 365 end) / 100) * (dsi.rate + nvl(dsi.spread,0)) * (edd+1 - std)),0),2)*rate(dsi.ntlcurrency,1000001275,1000131199,edd),2);
elsif variant = 2 then
   res := res + round(round(nvl(((nvl(dsi.ntlamount,0) / (case when dd.interestbase = 0 or dd.interestbase = 360 then 360 when dd.interestbase = 1 or dd.interestbase = 365 then 365 end) / 100) * getdealrate_tcb(dsi.doc,dsi.startdate,1) * (edd+1 - std)),0),2)*rate(dsi.ntlcurrency,1000001275,1000131199,edd),2);
else null;
end if;

      std := edd+1;    
    end loop; 
  return res;
end DealCalcEqv_tcb;

create or replace function DealCalcEqv4_tcb(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления рублевого эквивалента суммы начисленных процентов на процентном периоде по траншу МБК.
-- для отчета для Бакумцевой в RN "Отчеты - Афина - БэкОфис – Реестр сделок по привлечению МБК за период"
-- Автор: Панфилов М.С.
-- Версия: 20/11/2013
----------------------------------------------------------------------------------------------
   nDealSwapInterest   in dt.reference,  -- идентификатор процентного периода (DealSwapInterest) 
   startdate           in date,
   enddate             in date,
   variant             in number
) return varchar2
is
  res varchar2(4000);
  dsi DealSwapInterest%rowtype; 
  dd  DealDeposit%rowtype; 
  std date;
  edd date;
  valuedate date;
begin
  select dsi.* into dsi from DealSwapInterest dsi where classified = nDealSwapInterest;
  select dd.* into dd from DealDeposit dd where dd.doc = (select doc from DealSwapInterest where classified = nDealSwapInterest);
  select valuedate into valuedate from Deal where doc = dd.doc;
  
  std := startdate;
  --if dsi.startdate = valuedate then std := std+1; end if; -- 21/11/2013 Панфилов М.С. 
  while std <= enddate
    loop
      if last_day(std) < enddate then edd := last_day(std); else edd := enddate; end if;
           
if variant = 1 then
   --res := res + round(round(nvl(((nvl(dsi.ntlamount,0) / (case when dd.interestbase = 0 or dd.interestbase = 360 then 360 when dd.interestbase = 1 or dd.interestbase = 365 then 365 end) / 100) * (dsi.rate + nvl(dsi.spread,0)) * (edd+1 - std)),0),2)*rate(dsi.ntlcurrency,1000001275,1000131199,edd),2);
   res := res || '  //' || std || ' - ' || edd || ' : ' || dsi.ntlamount || ' : ' || round(round(nvl(((nvl(dsi.ntlamount,0) / (case when dd.interestbase = 0 or dd.interestbase = 360 then 360 when dd.interestbase = 1 or dd.interestbase = 365 then 365 end) / 100) * (dsi.rate + nvl(dsi.spread,0)) * (edd+1 - std)),0),2)*rate(dsi.ntlcurrency,1000001275,1000131199,edd),2) || '  ' || (dsi.rate + nvl(dsi.spread,0)) || '% ' || rate(dsi.ntlcurrency,1000001275,1000131199,edd) || '  ' || round(nvl(((nvl(dsi.ntlamount,0) / (case when dd.interestbase = 0 or dd.interestbase = 360 then 360 when dd.interestbase = 1 or dd.interestbase = 365 then 365 end) / 100) * (dsi.rate + nvl(dsi.spread,0)) * (edd+1 - std)),0),2);
elsif variant = 2 then null;
   --res := res + round(round(nvl(((nvl(dsi.ntlamount,0) / (case when dd.interestbase = 0 or dd.interestbase = 360 then 360 when dd.interestbase = 1 or dd.interestbase = 365 then 365 end) / 100) * getdealrate_tcb(dsi.doc,dsi.startdate,1) * (edd+1 - std)),0),2)*rate(dsi.ntlcurrency,1000001275,1000131199,edd),2);
else null;
end if;

      std := edd+1;    
    end loop; 
  return res;
end DealCalcEqv4_tcb;



select * from DealSwapInterest where doc = 224614747
select od.DealCalcEqv4_tcb(1270578708,to_date('30.05.2013','dd.mm.yyyy'),to_date('30.05.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1270578710,to_date('31.05.2013','dd.mm.yyyy'),to_date('16.09.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285856446,to_date('17.09.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual
select od.DealCalcEqv4_tcb(1252482524,to_date('19.01.2013','dd.mm.yyyy'),to_date('18.07.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285861993,to_date('19.07.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual
select od.DealCalcEqv4_tcb(1252517180,to_date('08.06.2013','dd.mm.yyyy'),to_date('18.07.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285856472,to_date('19.07.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual

select round(nvl(((116500000 / 360 / 100) * 2.441 * (to_date('30.09.2013','dd.mm.yyyy')+1 - to_date('16.09.2013','dd.mm.yyyy'))),0),2) from dual

select round(nvl(((103500000 / 360 / 100) * 2.3 * (to_date('30.05.2013','dd.mm.yyyy') - to_date('29.05.2013','dd.mm.yyyy'))),0),2) +
round(nvl(((116500000 / 360 / 100) * 2.3 * (to_date('31.05.2013','dd.mm.yyyy') - to_date('30.05.2013','dd.mm.yyyy'))),0),2) from dual

  //08.06.13 - 30.06.13 : 12583 : 622,83  1,814% 42,718  14,58 
  //01.07.13 - 18.07.13 : 12583 : 486,33  1,814% 42,6232  11,41
  //19.07.13 - 31.07.13 : 12583 : 402,51  2,032% 43,609  9,23  
 //01.08.13 - 31.08.13 : 12583 : 969,16  2,032% 44,0129  22,02  
 //01.09.13 - 30.09.13 : 12583 : 930,18  2,032% 43,6497  21,31

select (42.718*14.58) + (42.6232*11.41) + (43.609*9.23) + (44.0129*22.02) + (43.6497*21.31) from dual


select * from DealSwapInterest where doc = 224631272
select od.DealCalcEqv4_tcb(1252513725,to_date('11.05.2013','dd.mm.yyyy'),to_date('18.07.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285872190,to_date('19.07.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual
select * from DealSwapInterest where doc = 224628550
select od.DealCalcEqv4_tcb(1252519935,to_date('19.04.2013','dd.mm.yyyy'),to_date('18.07.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285871577,to_date('19.07.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual
select * from DealSwapInterest where doc = 224624077
select od.DealCalcEqv4_tcb(1252500412,to_date('22.02.2013','dd.mm.yyyy'),to_date('18.07.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285870539,to_date('19.07.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual
select * from DealSwapInterest where doc = 224627499
select od.DealCalcEqv4_tcb(1252506864,to_date('21.03.2013','dd.mm.yyyy'),to_date('18.07.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285878571,to_date('19.07.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual

select 316661.24 + 674103.47 + 741861.14 + 736571.66 + 763532.3 + 770521.65 + 461287.02 +  398058.16 + 958007.23 + 919453.43 from dual


select * from DealSwapInterest where doc = 229993611
select od.DealCalcEqv4_tcb(1264978958,to_date('01.01.2013','dd.mm.yyyy'),to_date('02.04.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1275818612,to_date('03.04.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual

select * from DealSwapInterest where doc = 224660711
select od.DealCalcEqv4_tcb(1252701699,to_date('01.01.2013','dd.mm.yyyy'),to_date('15.03.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1275688418,to_date('16.03.2013','dd.mm.yyyy'),to_date('16.09.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285877188,to_date('17.09.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual

select * from DealSwapInterest where doc = 217676054
select od.DealCalcEqv4_tcb(1252701699,to_date('01.01.2013','dd.mm.yyyy'),to_date('15.03.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1275688418,to_date('16.03.2013','dd.mm.yyyy'),to_date('16.09.2013','dd.mm.yyyy'),1), od.DealCalcEqv4_tcb(1285877188,to_date('17.09.2013','dd.mm.yyyy'),to_date('30.09.2013','dd.mm.yyyy'),1) from dual

select 148125.660 + 1071737.580 + 2947193.950 from dual

select 155870.880 + 592696.020 + 3703141.390 from dual

select   round(nvl(((nvl(569351714.28,0) / 365 / 100) *
       (10) * (to_date('14.01.2013','dd.mm.yyyy') - to_date('01.01.2013','dd.mm.yyyy')+1)),0),2) from dual  
       select 2183814.79 + 2649804.970
from dual

select   ((569351714.28 / 365 / 100) * (10) * (14)) + ((568928714.28 / 365 / 100) * (10) * (17))  from dual  

select   ((569351714.28 / 365 / 100) * (10) * (14)) + ((568928714.28 / 365 / 100) * (10) * (17))  from dual  

-- проблема в январе 2013 с траншем по МСП 18/07/2012 от на 600000000 (Бакумцева не хочет сообщать Ледовской) =>   
-- сообщил Ледовской, она думает что делать                                                                                                                        +-
select * from DealSwapInterest where doc = 217676054
select * from DealSwapPayPeriod where InterestPeriod = 1236672090
select * from Dealswappayment where doc = 217676054

select 4833619.76 - 4880466.99 from dual

create or replace function DealCalcEqv2_tcb(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления рублевого эквивалента суммы начисленных процентов на процентном периоде по обычной МБК сделке.
-- для отчета для Бакумцевой в RN "Отчеты - Афина - БэкОфис – Реестр сделок по привлечению МБК за период"
-- Автор: Панфилов М.С.
-- Версия: 18/11/2013
----------------------------------------------------------------------------------------------
   nAmount             in dt.Amount,
   nBase               in dealdeposit.interestbase%Type,
   nRate               in dt.Relation,
   startdate           in date,
   enddate             in date,
   nCurrency           in dt.Reference
) return dt.Amount
is
  res dt.Amount := 0;
  std date;
  edd date;
begin
  std := startdate;
  while std <= enddate
    loop
      if last_day(std) < enddate then edd := last_day(std); else edd := enddate; end if;
      res := res + round(round(nvl(((nvl(nAmount,0) / (case when nBase = 0 or nBase = 360 then 360 when nBase = 1 or nBase = 365 then 365 end) / 100) * nRate * (edd+1 - std)),0),2)*rate(nCurrency,1000001275,1000131199,edd),2);
      std := edd+1;
    end loop;
  return res;
end DealCalcEqv2_tcb;

create or replace function DealCalcEqv3_tcb(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления рублевого эквивалента суммы начисленных процентов на процентном периоде по обычной МБК сделке.
-- для отчета для Бакумцевой в RN "Отчеты - Афина - БэкОфис – Реестр сделок по привлечению МБК за период"
-- Автор: Панфилов М.С.
-- Версия: 18/11/2013
----------------------------------------------------------------------------------------------
   nAmount             in dt.Amount,
   nBase               in dealdeposit.interestbase%Type,
   nRate               in dt.Relation,
   startdate           in date,
   enddate             in date,
   nCurrency           in dt.Reference
) return varchar2
is
  res varchar2(4000);
  std date;
  edd date;
begin
  std := startdate;
  while std <= enddate
    loop
      if last_day(std) < enddate then edd := last_day(std); else edd := enddate; end if;
      res := res || '  //' || std || ' - ' || edd || ': ' || round(round(nvl(((nvl(nAmount,0) / (case when nBase = 0 or nBase = 360 then 360 when nBase = 1 or nBase = 365 then 365 end) / 100) * nRate * (edd+1 - std)),0),2)*rate(nCurrency,1000001275,1000131199,edd),2) || ' rate:' || rate(nCurrency,1000001275,1000131199,edd);
      std := edd+1;
    end loop;
  return res;
end DealCalcEqv3_tcb;



select DealCalcEqv2_tcb(350000,360,4,to_date('01.01.2013','dd.mm.yyyy'),to_date('22.08.2013','dd.mm.yyyy'),1000119259) from dual
select DealCalcEqv3_tcb(350000,360,4,to_date('01.01.2013','dd.mm.yyyy'),to_date('22.08.2013','dd.mm.yyyy'),1000119259) from dual
select * from currency
select DealCalcEqv2_tcb(80000000,365,5,to_date('13.02.2013','dd.mm.yyyy'),to_date('13.02.2013','dd.mm.yyyy'),1000001275) from dual
select DealCalcEqv3_tcb(80000000,365,5,to_date('13.02.2013','dd.mm.yyyy'),to_date('13.02.2013','dd.mm.yyyy'),1000001275) from dual


select d.doc,
(select (round(( select nvl(sum (NVL(p.interestamount,0)),0)
          FROM dealswapinterest p
	      ,dealdeposit i
         WHERE i.doc = p.doc
	 AND p.enddate > add_months(td, 12)
         and p.rate is not null
         AND p.doc = d.doc),2)  +
round((SELECT nvl(SUM((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,td,1) * (p.enddate - p.startdate)),0)
          FROM dealswapinterest p
	      ,dealdeposit i
         WHERE i.doc = p.doc
         and p.rate is null
	  AND p.enddate > add_months(td, 12)
         AND p.doc = d.doc),2)) from dual 
 )  over_year
 from dealdeposit dd, deal d, doctree dt, dealaccount da1, dealaccount da2, DealSwapInterest dsi, Dealswappayperiod dspp 
where dd.doc = dt.classified and d.doc = dt.classified and d.doc = dsi.doc and dsi.classified = dspp.interestperiod 
and da1.doc = d.doc and da2.doc = d.doc
and dd.istransh = 1 and dt.category = 908
and dt.docstate not in ( 1000000037,1000000035)
and da1.accintention in (1000105424,1000105425)
and da2.accintention in (1000105426,1000105427)
and td > dsi.startdate and td <= dsi.enddate



select 
p.*,
/*sum(*/
case
 when p.rate is not null and p.startdate >= to_date('01.01.2013','dd.mm.yyyy') and p.enddate <= to_date('01.10.2013','dd.mm.yyyy') then
   round((NVL(p.interestamount,0)),2)
 when p.rate is not null and p.startdate <= to_date('01.01.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.01.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       (p.rate + p.spread) * (p.enddate - to_date('01.01.2013','dd.mm.yyyy')+1)),0),2)  
 when p.rate is not null and p.startdate <= to_date('01.10.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.10.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       (p.rate + p.spread) * (to_date('01.10.2013','dd.mm.yyyy') - p.startdate+1)),0),2)  
 when p.rate is null and p.startdate >= to_date('01.01.2013','dd.mm.yyyy') and p.enddate <= to_date('01.10.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (p.enddate - p.startdate+1)),0),2)
 when p.rate is null and p.startdate <= to_date('01.01.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.01.2013','dd.mm.yyyy') then 
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (p.enddate - to_date('01.01.2013','dd.mm.yyyy')+1)),0),2) 
 when p.rate is null and p.startdate <= to_date('01.10.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.10.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (to_date('01.10.2013','dd.mm.yyyy') - p.startdate+1)),0),2)
else null
end/*)
sp*/
from dealswapinterest p, dealdeposit i 
where p.doc = 217677727 and i.doc = p.doc


select 
p.*,
/*sum(*/
case
 when p.rate is not null and p.startdate >= to_date('01.01.2013','dd.mm.yyyy') and p.enddate <= to_date('01.10.2013','dd.mm.yyyy')-1 then
   round((NVL(p.interestamount,0)),2)
 when p.rate is not null and p.startdate <= to_date('01.01.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.01.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       (p.rate + nvl(p.spread,0)) * (p.enddate - to_date('01.01.2013','dd.mm.yyyy')+1)),0),2)  
 when p.rate is not null and p.startdate < to_date('01.10.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.10.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       (p.rate + nvl(p.spread,0)) * (to_date('01.10.2013','dd.mm.yyyy') - p.startdate-1)),0),2)  
 when p.rate is null and p.startdate >= to_date('01.01.2013','dd.mm.yyyy') and p.enddate <= to_date('01.10.2013','dd.mm.yyyy')-1 then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (p.enddate - p.startdate+1)),0),2)
 when p.rate is null and p.startdate <= to_date('01.01.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.01.2013','dd.mm.yyyy') then 
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (p.enddate - to_date('01.01.2013','dd.mm.yyyy')+1)),0),2) 
 when p.rate is null and p.startdate < to_date('01.10.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.10.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount,0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (to_date('01.10.2013','dd.mm.yyyy') - p.startdate-1)),0),2)
else null
end/*)
sp*/
from dealswapinterest p, dealdeposit i 
where p.doc = 221557792 and i.doc = p.doc


select 
(select 
sum(
case
 when p.rate is not null and p.startdate >= to_date('01.01.2013','dd.mm.yyyy') and p.enddate <= to_date('01.10.2013','dd.mm.yyyy')-1 then
   round((NVL(p.interestamount*rate(p.ntlcurrency,1000001275,1000131199,p.enddate),0)),2)
 when p.rate is not null and p.startdate <= to_date('01.01.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.01.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount*rate(p.ntlcurrency,1000001275,1000131199,p.enddate),0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       (p.rate + nvl(p.spread,0)) * (p.enddate - to_date('01.01.2013','dd.mm.yyyy')+1)),0),2)  
 when p.rate is not null and p.startdate < to_date('01.10.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.10.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount*rate(p.ntlcurrency,1000001275,1000131199,to_date('01.10.2013','dd.mm.yyyy')),0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       (p.rate + nvl(p.spread,0)) * (to_date('01.10.2013','dd.mm.yyyy') - p.startdate-1)),0),2)  
 when p.rate is null and p.startdate >= to_date('01.01.2013','dd.mm.yyyy') and p.enddate <= to_date('01.10.2013','dd.mm.yyyy')-1 then
   round(nvl(((nvl(p.ntlamount*rate(p.ntlcurrency,1000001275,1000131199,p.enddate),0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (p.enddate - p.startdate+1)),0),2)
 when p.rate is null and p.startdate <= to_date('01.01.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.01.2013','dd.mm.yyyy') then 
   round(nvl(((nvl(p.ntlamount*rate(p.ntlcurrency,1000001275,1000131199,p.enddate),0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (p.enddate - to_date('01.01.2013','dd.mm.yyyy')+1)),0),2) 
 when p.rate is null and p.startdate < to_date('01.10.2013','dd.mm.yyyy') and  p.enddate >= to_date('01.10.2013','dd.mm.yyyy') then
   round(nvl(((nvl(p.ntlamount*rate(p.ntlcurrency,1000001275,1000131199,to_date('01.10.2013','dd.mm.yyyy')),0) / decode(i.interestbase, 0, 360, 1, 365, 365, 365, 360, 360) / 100) *
       getdealrate_tcb(p.doc,p.startdate,1) * (to_date('01.10.2013','dd.mm.yyyy') - p.startdate-1)),0),2)
else null
end)
from dealswapinterest p, dealdeposit i 
where p.doc = 217677727 and i.doc = p.doc) sp
from dual



dd.interestsum 

(select ntlamount from DealSwapInterest where doc = 217677727 and enddate = (select max(enddate) 
from DealSwapInterest where doc = 217677727 and startdate < to_date('01.10.2013','dd.mm.yyyy')))



----------------------------------------------------------------------------------
--11/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select round(nvl(((500000000 / 365 / 100) * (5.75) * (to_date('01.10.2013','dd.mm.yyyy') - to_date('20.09.2013','dd.mm.yyyy')-1)),0),2) from dual 

select 500000000*0.0575*(10/365) from dual
select (to_date('01.10.2013','dd.mm.yyyy') - to_date('20.09.2013','dd.mm.yyyy')-1) from dual

-- валютный процентно-дисконтный вексель в Питере учли второй раз, пришлось поправить дату "начисление процентов с" и дату "фактического погашения"               ++
select * from bill where num = '0001067' 
--update bill set percentdate = to_date('05.11.2013','dd.mm.yyyy'), repaydate = null where classified = 1270696986

----------------------------------------------------------------------------------
--12/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from bill where classified = 1202243736
select * from billrepayinterval where bill = 1202243736

select * from repayinterval
od.makebilleveryday_tcb

SELECT CASE
            WHEN t1.paydatevar = 4 AND t1.date1 <= aftworkday(td) THEN
             t2.account
            WHEN t1.paydatevar = 1 AND add_months(t1.date1, 12) <= aftworkday(td) THEN
             t2.account
            WHEN t1.paydatevar = 3 AND t1.drawdate + t1.time <= aftworkday(td) THEN
             t2.account
            WHEN t1.paydatevar = 4 AND t1.status = 14 THEN -- для старых досрочных выкупов  
             t2.account
            ELSE
             null
          END --into res
   from bill t1, billaccount t2 where t1.classified = 1202243736/*billClassified*/ and t1.classified = t2.bill and t2.accintention = 1011996470
   
select * from bill where classified in (   
1101310675,
1116154664,
1136487358,
1149007370,
1149020664,
1163070591,
1163070596,
1163070599,
1163070602,
1163070606,
1163070609,
1163070612,
1163070616,
1163070619,
1284142699
)   
   
select acccode(account), ba.* from billaccount ba where bill in(
1101310675,
1116154664,
1136487358,
1149007370,
1149020664,
1163070591,
1163070596,
1163070599,
1163070602,
1163070606,
1163070609,
1163070612,
1163070616,
1163070619,
1284142699
)

select* from billaccintention where classified in (
1011996334,
1011996336,
1011996468
)

select * from dealpact where doc = 170103488
select * from client where classified = 63909337
----------------------------------------------------------------------------------
--14/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_DepositDeal_Events
od.FUNC_TCB_BILL_NAL

-- задача от Герасимовой IPI 164148 автоматизровать расчет и заполнение поля "Сумма налога" по процентным векселям при (досрочном) погашении                      ++++
-- написать процедуру DPC_SetBillOperTax_TCB                                                                                                                      ++++
-- повесить процедуру DPC_SetBillOperTax_TCB в manager для документа в обработку действия "Открыть" перед DPC_BillOper                                            ++++
-- поправить в схеме проводок для документов "Погашение и Досрочное погашение векселя" у проводок, где счет кредита 46.(60301), "сумма в валюте" = СЧЕТА ДЕБЕТА   
-- и "схема конверсии" = "Остальные конверсионные операции"                                                                                                       ++++
-- поправить в схеме проводок для документов "Погашение и Досрочное погашение векселя" у проводок, где счет кредита "25.Процентные расходы по векселю (70606)"
-- "сумма в валюте" = СЧЕТА ДЕБЕТА                                                                                                                                ++++
-- написать func_tcb_bill_nom_p_nal_2013 для суммы "ТКБ: Номинал + процент - налог 2013"                                                                          ++++
-- заменить в схеме проводок для документов "Погашение и Досрочное погашение векселя" везде сумму "26.(Номинал+%% по векселю)" на 
-- "ТКБ: номинал + проценты - налог 2013" перенести в схеме проводок для документов "Погашение и Досрочное погашение векселя" проводку 
-- по вычислению Налога (для %% векселей) до проводки "ТКБ: Номинал + процент - налог 2013"                                                                       ++++
-- дописать отдельную DPC для "Внутренних переводов (векселя)" с валютного счета на 60301, чтобы апдейтила bankoper и bankoperconversion DPC_RoundTaxForBillOper_TCB ++++
-- навесить DPC_RoundTaxForBillOper_TCB в конец операции "Постсоздание" для "Внутренних переводов (векселя)"                                                      ++++  
-- должна протестить Герасимова на athena3                                                                                                                        ++++
-- перенести на боевую                                                                                                                                            ++++
-- обновить инструкцию на портале                                                                                                                                 ++++

в общем, как я понял, в случае уплаты налога по валютному векселю мы делаем округление до  конвертации. После конвертации также делаем округление уже рублей, и остаток от округления возвращаем клиенту.

od.DPC_BillSumCorrection_TCB
od.DPC_BillSumCorrectionDisc_TCB
od.FUNC_TCB_BILL_NOM_PERC_NAL
od.FUNC_BILL_NOMPLUSACCRUAL
select * from billsum where bill = (select classified from bill where num = '0028563')
select * from billsumtype where classified = 1011996372

create or replace procedure DPC_SetBillOperTax_TCB
/**********************************************************************************
 Описание: Расчет суммы налога на доход для физ.лиц при погашении процентных векселей
14/11/2013 - Панфилов М.С.
**********************************************************************************/
as
  tsum           dt.Amount;
  tallsum        dt.Amount := 0;                -- вся сумма налога по операции
  allsum         dt.Amount := 0;                -- вся сумма по операции
  nClient        dt.Reference;
  nPercent       Bill.Percent%type;
begin

dbms_output.put_line('DPC_SetBillOperTax_TCB ->');

begin

  for rec in (select br.*, b.billsum from BillRange br, bill b where br.Doc=CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      nPercent := 0;
      select nvl(Percent,-1) into nPercent from Bill where Classified = rec.bill;
      if nPercent >= 0 then -- если процентный вексель
        select Client into nClient from BillOper where Doc=CONTEXT.CurrentDoc; 
      -- вычислим сумму налога для резидентов физ. лиц
      if nvl(ObjAttr.GetOneProp(nClient, ObjAttr.PropClass(6)), 0) = 1 and nvl(GetClientIsPhys(nClient),0) = 1 then
        tsum := round(rec.percentsum*0.13/**rate(rec.rowpricecurr,1000001275,1000131199,CONTEXT.OperDate)*/);
      end if;
      -- вычислим сумму налога для нерезидентов физ. лиц
      if nvl(ObjAttr.GetOneProp(nClient, ObjAttr.PropClass(6)), 0) = 0 and nvl(GetClientIsPhys(nClient),0) = 1 then
        tsum := round(rec.percentsum*0.3/**rate(rec.rowpricecurr,1000001275,1000131199,CONTEXT.OperDate)*/);
      end if;
      update BillRange set tax = tsum where bill = rec.bill and Doc=CONTEXT.CurrentDoc;
      tallsum := tallsum + tsum;
      dbms_output.put_line('DPC_SetBillOperTax_TCB <- ' || tsum);
      end if;
    end loop;

  if nvl(tallsum,0) != 0 then
     update billpercent set taxesum = tallsum where doc = Context.CurrentDoc;
  end if;

exception
  when others then null;
end;
end DPC_SetBillOperTax_TCB;


select * from bankoper where doc = 245466162
update bankoper set sumconv = 3287 /*round(sumconv)*/ where doc = 245466162 
select * from bankoperconversion where doc = 245466162
update bankoperconversion set isspecial = 1, exchangerate = 32.87, truerate = 32.87, sumto = 3287 /*round(sumconv)*/ where doc = 245466162 

create or replace function func_tcb_bill_nom_p_nal_2013
/******************************************************************************
 Назначение:   Функция возвращает номинал + проценты - налог 2013
               
 Версия от : 17/12/2013 Панфилов М.С.
******************************************************************************/
return DT.Amount as
begin
return nvl(BC.recBill.nBillSum,0) + nvl(bc.getbillsum(bc.getbill, 14),0) - nvl(bc.getbillsum(bc.getbill, 13),0);
end func_tcb_bill_nom_p_nal_2013;

create or replace procedure DPC_RoundTaxForBillOper_TCB
/**********************************************************************************
 Описание: Округляем до целых единиц сумму налога в рублях (с изменением курса)
17/12/2013 - Панфилов М.С.
**********************************************************************************/
as
curfrom  dt.Reference;
accdeb   dt.Label;
begin

dbms_output.put_line('DPC_RoundTaxForBillOper_TCB ->');

begin
  select currencyfrom into curfrom from bankoperconversion where doc = Context.CurrentDoc;
  select acccode(account) into accdeb from preparemoney where doc = Context.CurrentDoc;                                               
  if curfrom != 1000001275 and accdeb like '60301%' then
     update bankoper set sumconv = round(sumconv) where doc = Context.CurrentDoc;
     update bankoperconversion set isspecial = 1, exchangerate = round(sumto)/sumfrom, truerate = round(sumto)/sumfrom, sumto = round(sumto) where doc = Context.CurrentDoc; 
  end if;

exception
  when others then null;
end;

end DPC_RoundTaxForBillOper_TCB;

od.DPC_RoundTaxForBillOper_TCB

declare
begin
od.reopenaccount(240717030);
end;



select 39528004.44*0.105*((14+31+30)/365) - 39528004.44*0.05*((14+31+30)/365) from dual -- излишние проценты
select 39528004.44*0.05*((14+31+30)/365) + 92051.52 from dual -- проценты к уплате

select 39528004.44*0.05*((14+31+30)/365) + 92051.52 + 39528004.44 from dual -- проценты к уплате

od.FUNC_BILL_ACCRUALRETURN_TY_TCB

od.FUNC_TCB_BILL_NOM_PERC_NAL

select * from preparemoney where doc = 240717018


select * from bankoperconversion where doc = 240717018
select * from bankoper where doc = 240717018


select * from billpercent where taxesum != 0
select * from doctree where classified = 230916666
select * from sysfilial
select * from billrange
select * from client

(select 1,2,3 from dual
union
select 4,5,6 from dual)

select 1,2,3,4,5,6 from dual

select deptno,
    max(sys_connect_by_path
       (ename, ' ' )) scbp
  from (select deptno, ename,
            row_number() over
           (partition by deptno
            order by ename) rn
         from emp
          )
start with rn = 1
connect by prior rn = rn-1
and prior deptno = deptno
  group by deptno
  order by deptno
  
  select label from clientregiontree connect by prior classified = parent start with classified = 1000043360

select * from account where code = '52503810000000030602'

select * from billaccount where account = 206884537
select * from department where classified = 1000360245

select* from bill where classified in (
1273254764,
1211874704)

select * from sysfilial
select 1000000000*60*60*24 from dual

----------------------------------------------------------------------------------
--15/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- чистил billaccount от задвоений по просьбе Миши                                                                                                                  ++
select * from
(
select (select sysfilial from account where classified = ba.account) a, acccode(account) b, count(account) c, account d from billaccount ba group by account
) where c=2 and b like '525%00306__'

delete billaccount where account in (
select d from
(
select (select sysfilial from account where classified = ba.account) a, acccode(account) b, count(account) c, account d from billaccount ba group by account
) where c=2 and b like '525%00306__'
) and department is null


select * from
(
select (select sysfilial from account where classified = ba.account) a, acccode(account) b, count(account) c, account d from billaccount ba group by account
) where c=2 and b like '525%'

select * from billaccount where account = 60475926
select * from bill where classified in (
1066859295,
1066859334
)

select * from billaccount where account = 109506810
select * from bill where classified in (
1107558150,
1107544711
)

select * from billaccount where account = 149660246
select * from bill where classified in (
1149020664,
1149020664
)

select * from billaccount where account = 208215823
select * from bill where classified in (
1214116394,
1214116400
)

select * from billaccount where account = 149660180
select * from bill where classified in (
1149007370,
1149007370
)

select (select sysfilial from bill where classified = bs.bill), bs.* from billstatushistory bs where status = 24

select * from bill where classified in (
1199338173,
1199613367
)

select (select sysfilial from bill where classified = bs.bill), bs.* from billstatushistory bs where status = 44 and startdate != enddate

select * from bill where classified in (
1102253511
)

select (select sysfilial from bill where classified = bs.bill),
(select client from filial where sysfilial = (select sysfilial from bill where classified = bs.bill)),
 (select maker from bill where classified = bs.bill), bs.* from billstatushistory bs where status in (6,8,41,42,46) and
               (select client from filial where sysfilial = (select sysfilial from bill where classified = bs.bill)) = 
               (select maker from bill where classified = bs.bill)

select * from filial

select b.* from bill b, filial f where b.sysfilial = f.sysfilial and b.maker = f.client 

----------------------------------------------------------------------------------
--18/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billaccount where account in (select classified from account where code = '52503810400000021651')
select * from bill where classified = 1163070622
52503810400000021651


select * from billaccount where account in (select classified from account where code = '52503810700000019787')
select * from bill where classified = 1134047568
52503810700000019787

select * from billaccount where account in (select classified from account where code = '52303810601300025969')
select * from bill where classified = 1172464949
52303810601300025969

select * from sysfilial

select rowid, b.* from bill b where num = '0021701' -- правил группу векселя в Москве на Краснодарскую, по просьбе Филимоновой                                    ++



----------------------------------------------------------------------------------
--20/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил процентную ставку по просьбе Филимоновой                                                                                                                ++
select rowid, b.* from bill b where num in ('0028568','0028569')                                                                                                   

select * from doctree where classified = 241786512 
select * from objprop where prop = 1000234835 and obj = 241786512
select * from objprop where prop = 1000234835 and obj = 241486175
--update objprop set status = 0 where prop = 1000234835 and obj = 241786512 -- правил по задаче IPI 165083                                                        ++ 
select * from proplist where constprop = 704
704

----------------------------------------------------------------------------------
--21/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- привязал счет к клиенту для Герасимовой                                                                                                                        ++
select rowid, d.* from doctree d where classified = 237235743

 select * from ClBankRel where ClBank = 237725915
 select * from accounttype where classified = 1065836540
 
 insert into ClBankRel(classified,clbank,Corrclbank,Relation,Currency,Code,Description,Opendate,closedate,commentary,Nsysfilial) values 
        (od.classified.nextval,237725915,1,1000136542,1000001171,'52306840000000028564', null,to_date('23.10.2013','dd.mm.yyyy'),TO_DATE( '4444-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS'),null,null)
 
 1000136542
 
----------------------------------------------------------------------------------
--22/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- задача от Герасимовой IPI 165402 коды VO                                                                                                                        ++
--- написать условие для векселей "клиент ЮЛ резидент и счета валютные"                                                                                            ++
--- написать условие для векселей "клиент ЮЛ НЕрезидент и счета рублевые"                                                                                          ++
--- разбить проводки, которые идут на клиентский счет для "Погашения векселя" и "Досрочного погашения собственного векселя" на три варианта с разными назначениями ++

select * from BillOper where doctype in (1065658588,1065672640)
select * from currency where classified = 1000001275
select * from doctype

DECLARE              
nPhis   NUMBER;
nRez    NUMBER;
BEGIN
nPhis := nvl(GetClientIsPhys(bc.recBillOper.client),0) ; 
nRez := nvl(ObjAttr.GetOneProp(bc.recBillOper.client, ObjAttr.PropClass(6)), 1) ;

IF   nPhis = 0 AND nRez = 1 AND nvl(bc.recBillOper.currencyfrom,0) != 1000001275 AND nvl(bc.recBillOper.currencyto,0) != 1000001275 THEN
  :ncondresult := 1 ;
ELSE 	
  :ncondresult := 0 ;
END IF; 
END;

DECLARE              
nPhis   NUMBER;
nRez    NUMBER;
BEGIN
nPhis := nvl(GetClientIsPhys(bc.recBillOper.client),0) ; 
nRez := nvl(ObjAttr.GetOneProp(bc.recBillOper.client, ObjAttr.PropClass(6)), 1) ;

IF   nPhis = 0 AND nRez = 0 AND nvl(bc.recBillOper.currencyfrom,0) = 1000001275 AND nvl(bc.recBillOper.currencyto,0) = 1000001275 THEN
  :ncondresult := 1 ;
ELSE 	
  :ncondresult := 0 ;
END IF; 
END;

----------------------------------------------------------------------------------
--26/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.FUNC_BILL_ACCRUALRETURN_TY_TCB

select * from customer c where c.custid like '%OLD%Углемет%'

-- поправить старый спрэд по COMMERZ                                                                                                                               ++ 
select rowid, d.* from DealSwapInterest d where doc = 224614747
select * from DealSwapInterestLog where doc = 224614747

----------------------------------------------------------------------------------
--27/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.FUNC_BILL_NOM_OWNRED

select * from bill where num = '0032906'
select * from billsum where bill = 1293426431
select * from billsumtype where classified = 1011996370

delete from billsum where bill = 1293426431

-- проблема с "Меной и новацией векселя" в Перми (Якушина Ирина)                                                                                                   ++
--- посмотреть процедуру, меняющую сумму в операции для дисконтных векселей в manager -> позвонить Якушиной, попросить отписать в задаче IPI 130215 =>
--- => обещали отписать в задачу => наверно нужно будет прицепить условие "Родитель-мена?" в manager => 24/12/2013 за месяц ничего не отписали, наверно не нужно им++
od.DPC_BillSumCorrectionDisc_TCB

----------------------------------------------------------------------------------
--28/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from dealaccount where account in (select classified from account where code like '47426810550001603340')

select * from doctree where classified in (217671332,217676054)
select * from deal where doc in (217671332,217676054)

select * from od.account

select * from od.accountassoc

select * from account where code = '52501810000150000252'
select * from pactaccvariant where code = '52501810000150000252'
select * from sysfilial

select * from doctree where classified = 238093427
select * from doctree where classified = 1044337966

select * from doctree where classified = 238093402

select * from doctype where classified = 1000166362
select * from doccategory where cate = 201

select * from 1044337966

select * from doctree where classified in (select classified from account) and parent in (select classified from doctree where category = 201)
select * from od.account where classified not in (select classified from doctree where parent in (select classified from doctree where category = 201))
and code in (
'52501810000150000252',
'52501810020100000006',
'52501810020100000019',
'52501810020100100003',
'52501810100140100237',
'52501810101200100181',
'52501810120100000016',
'52501810200000520202',
'52501810200100100533',
'52501810200140000240',
'52501810220100003395',
'52501810220100100007',
'52501810300150100247',
'52501810300160100240',
'52501810300160100525',
'52501810320100000010',
'52501810320100000023',
'52501810320100100004',
'52501810400000520002',
'52501810400150000250',
'52501810400160100522',
'52501810400400100096',
'52501810420100000017',
'52501810420100003399',
'52501810420100100001',
'52501810500100100521',
'52501810500140000241',
'52501810500150000244',
'52501810500300010136',
'52501810520100003396',
'52501810600150000238',
'52501810600150000241',
'52501810620100000024',
'52501810620100100005',
'52501810700000520003',
'52501810700001000001',
'52501810700100000243',
'52501810700130100236',
'52501810700150000251',
'52501810700160100523',
'52501810701500100410',
'52501810720100000005',
'52501810720100000018',
'52501810720100003400',
'52501810720100100002',
'52501810800150000245',
'52501810800150100242',
'52501810800160100232',
'52501810820100003397',
'52501810900100100231',
'52501810900150000242',
'52501810900160100239',
'52501810920100100006'
)


select * from ProductAccount
select * from od.productaccount

SELECT C.Classified, A.Classified, PA.Classified
 FROM Currency C, AccountType A, ProductAccount PA
 WHERE PA.Product = 1269402270
AND PA.OpenContext in (1,2,3)
    AND A.Classified = PA.AccountType
    AND (PA.CurrOption = 1 AND C.Classified = PA.Currency
       OR PA.CurrOption = 2 AND C.Classified IN (SELECT Assoc FROM  V_ObjAssoc WHERE Category = 51 AND Obj = PA.Currency)
       OR PA.CurrOption = 3 AND C.Classified = (SELECT Currency FROM V_Pact WHERE Doc = 238860905)
       OR PA.CurrOption = 4 AND C.Classified = (SELECT CurrencyInt FROM V_Pact WHERE Doc = 238860905)
       OR PA.CurrOption = 5 AND (C.Classified = (SELECT Currency FROM V_Account WHERE Classified = NULL) OR (NULL IS NULL AND C.IsWork = 1))
       OR PA.CurrOption is null AND C.IsWork = 1)
    AND Exists (SELECT * FROM AccTypeToGeneral ATTG, GeneralAccParent GAP, GeneralAccTree GAT
        WHERE ATTG.AccountType = A.Classified
            AND  ATTG.GeneralAccount = GAT.Classified
            AND GAT.Lev = ( SELECT MaxLev FROM GeneralAccStruct
                WHERE GeneralAcc = 1000018728)
            AND GAT.Classified = GAP.GeneralAcc
            AND GAP.Parent = 1000018728) 
    AND C.Classified = 1000001275
 ORDER BY A.Label, PA.Label, C.CodeISOalph

----------------------------------------------------------------------------------
--29/11/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select 5011*0.0875*(10/365) + 13011*0.0875*(5/365) + 3641*0.0875*(15/365) from dual

select 200000*0.0875*(30/365) from dual

----------------------------------------------------------------------------------
--02/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.dealdep_proc

select 808437.17*2.131*(10/365)

select * from DealSwapInterest where doc = 226133843

select * from DealSwapPayPeriod where InterestPeriod = 1285862234
select * from Dealswappayment where doc = 226133843
select * from DealSwapInterestLog where doc = 226133843

delete from DealSwapInterestLog where doc = 226133843 and classified =1285862238

od.MAKEBILLEVERYDAY_TCB

(select Classified Bill
               from v_Bill
               where Status = 6
                 and (
                     (nBill is null and nBillGroup is null)
                     or
                     (nBill is null and nBillGroup is not null and nBillGroup = BillGroup)
                     or
                     (nBill is not null and nBill = Classified)
                     )
                 and (nvl(nToRepay, 0) = 0 or nToRepay = 1 and bill_p.RepayDateNoNull(Classified) = trunc(dtOperDate))
              )

select * from bill where num = '0001067'

od.UT_DealAccrual

-- менял дату "начисление %% с" по векселю 0019437 для Нижнего Новгорода                                                                                           ++
select * from bill where num = '0019437'
--update bill set percentdate = to_date('25.11.2013','dd.mm.yyyy') where classified = 1293340956

-- Для определения остатка по реестру на дату можно пользоваться вот такой функцией:
select od.reestrrestout((select rsaccount from dealaccount where doc = 224535563/*nDealID*/ and 
account = (select classified from account where code = '47426978150000000095'/*счет*/))
, td) from dual


-- зачистить удаленные документы из DealSwapInterestLog - просила Ледовская, чтобы не возникало ошибки "о невозможности росписи остатка по периодам начисления"    ++  
select * from DealSwapInterest where doc = 217673359   
select * from DealSwapPayPeriod where InterestPeriod = 1236447838
select * from Dealswappayment where doc = 217673359
select * from DealSwapInterestLog where doc = 217673359  
select * from doctree where classified = 217673359       
select * from deal where doc = 217673359                                                                                              

select * from doctree where classified in (select paydoc from DealSwapInterestLog) and docstate = 1000000037

select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

--delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

od.DPC_FxEvent_PercentAccountDoc
 

----------------------------------------------------------------------------------
--03/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- отключить порождение проводок (DPC_FxEvent_PercentAccountDoc в manager) на действии "В ДВР" для "События депозитной сделки", если "Родитель Транш МБК"
-- просила Бакумцева                                                                                                                                               ++ 

declare
nIsTransh        DT.Status;
begin
select nvl(istransh,0) into nIsTransh from DealDeposit where doc=parentdoc(Message.idobject); 
     if nIsTransh = 1 then
        :nCondResult := 1;
     else
        :nCondResult:= 0;
     end if;
exception when others then
     :nCondResult := 0;
end;


select 7524035*(0.06/365) + 2521.54 from dual

select * from DealSwapInterestLog where doc = 217774415
select * from doctree

select sysdate from dual

----------------------------------------------------------------------------------
--06/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- патчирование 08/12/2013                                                                                                                                         ++
od.dpc_createpercentaccountdoc
od.getbillaccount
od.dealdep_proc.CreateDepSheduleOfPayments                   ++
od.deal_getpaymentpurpose                                    ++
od.dealbegprocdate                                           ++
od.dpc_deallimit_close
od.ut_dealaccrual

procedure CreateDepSheduleOfPayments(
   /******************************************************************************
    Автор:    Шубин Р.
    Описание: Создать график платежей на основе графика процентов.
    Версия:   17.04.2012
              08.06.2012 AGN
              04.12.2012 - учтен расчет подробностей без округления (Зам. № 44099, AGN)
              16.01.2013
              --28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
   *****************************************************************************/
      idDoc    DT.Reference,       -- документ.
      nInit    DT.Status default 1 -- инициализация переменных
   ) as
      idPaymentLine   DT.Reference;                  --
      nAmountPay      DT.Amount;
   begin
      if nvl(nInit, 1) = 1 then
         InitVariables(idDoc);
      end if;
      -- выплаты по процентам:
      -- nSign := i.f(recDealDep.IsReceive = 1, -1, 1);
--28/05/2013 Панфилов М.С. теперь складываем уже округленное по просьбе Ледовской
for recDSI in
         (
            select sum(P.AMOUNT) Amount, P.PayDate InterestDate, NTLCurrency,
                   P.PaymentLine
              from DealSwapInterest DSI, DealSwapPayPeriod P
             where DSI.Doc = idDoc
               and P.InterestPeriod = DSI.Classified
          group by P.PaymentLine, P.PayDate, NTLCurrency
         )
      loop
         nAmountPay :=  round(recDSI.Amount, nvl(MinorUnit(recDSI.NTLCurrency), 2));
         update DealSwapPayment
            set Amount = nAmountPay,
                Currency = recDSI.NTLCurrency,
                IsNetting = recDeal.IsNetting
          where Doc = idDoc and Classified = recDSI.PaymentLine;
         if sql%notfound then
            insert into DealSwapPayment (Doc, ValueDate, Currency, Amount,
                                          PaymentType, IsNetting, NettAmount)
               values (idDoc, recDSI.InterestDate, recDSI.NTLCurrency, nAmountPay,
                        nPaymentType_Interest, 0, null)
               returning Classified into idPaymentLine;
            update DealSwapPayPeriod
               set PaymentLine = idPaymentLine
             where PayDate = recDSI.InterestDate
               and InterestPeriod in (select Classified from DealSwapInterest
                                       where NTLCurrency = recDSI.NTLCurrency
                                         and Doc = idDoc);
         end if;
      end loop;
      -- основные суммы + амортизация.
      GeneralAmountExchange;
      -- перенумерация платежей.
      ReCalculateSheduleOfPayments(idDoc);
   end CreateDepSheduleOfPayments;
   
create or replace function DEAL_GetPaymentPurpose
/******************************************************************************
 Автор: Цветков В.
 Описание: Получение шаблона строки назначения платежа из PAYMENTPURPOSE по ключу и раскрытие макросов
 24.06.2010 по заданию 2161-У.
 Версия:
 13.11.2010 Доработка 31804: function DEAL_GetPaymentPurpose -
                Исправлено раскрытие макроса <DocOperDate> и <DealDate>(формат)
 19.04.2011 Новые тэги
 16.05.2011 Тэг <TICKET> (тикет сделки)
 27.05.2011 вместо nDoc должен быть nDeal в вызове BEGPROCDATE и в процедуре
            LoadDealNettingRec.
 12.12.2012 добавлен тэг BEGACCRDATE - дата начала начисления процентов (Зам. № 44161, AGN)
 08.02.2013 добавлена возможность прямой распаковки шаблона строки без использования справочника (Дор. № 12438, AGN)
 13.06.2013 Панфилов М.С. добавлены тэги <CLLabel>, <CLVALUEDATE>, <BEGPROCDATE2>
 01.11.2013 Панфилов М.С. добавлен тэг <BEGPROCDATE3>
 ******************************************************************************/
(  sTemplateCode  DT.Text,        -- Код строки-шаблона
   nDeal          DT.Reference,   -- Сделка
   nDoc           DT.Reference,   -- Документ
   sExtraText     DT.Text,         -- Дополнительный текст
   nDirectExpand  DT.Status default 0 -- прямая распаковка шаблонов строки без справочника
)
return DT.Text as
   sPurpose       DT.Text;
   recDeal        Deal%rowtype;
   recDocTree     DocTree%rowtype;
   recDealReserv  DealReserv%rowtype;
   recDealROLL    Deal%rowtype;
   recDealDeposit DealDeposit%rowtype;
   recDealNetting DealNetting%rowtype;
   recDealTrans   DealTransaction%rowtype;
   recDocTreeCL   DocTree%rowtype;
   recDealCL      Deal%rowtype;
   --
   sCurrTag       Dt.Text;
   sDTFMT         constant Dt.Label := 'DD/MM/YYYY';
   sDTFMT1        constant Dt.Label := 'DD.MM.YY';
   dtDateTemp     Date;
   --
   procedure LoadDealRec as
      cursor c is select * from Deal where Doc = nDeal;
   begin
      if recDeal.Doc is null then
         open c;
         fetch c into recDeal;
         close c;
      end if ;
   end LoadDealRec;
   --
   procedure LoadDocRec as
      cursor c is select * from DocTree where Classified = nDoc;
   begin
      if recDoctree.Classified is null then
         open c;
         fetch c into recDocTree;
         close c;
      end if ;
   end LoadDocRec;
   --
   procedure LoadDealReservRec as
      cursor c is select * from DealReserv where Doc = nDoc;
   begin
      if recDealReserv.Doc is null then
         open c;
         fetch c into recDealReserv;
         close c;
      end if ;
   end LoadDealReservRec;
   --
   procedure LoadDealRollRec as
      cursor c is select * from Deal where Doc =
         (select Deal from DealRollover where Doc = nDeal);
   begin
      if recDealRoll.Doc is null then
         open c;
         fetch c into recDealRoll;
         close c;
      end if ;
   end LoadDealRollRec;
   --
   procedure LoadDealDepositRec as
      cursor c is select * from DealDeposit where Doc = nDeal;
   begin
      if recDealDeposit.Doc is null then
         open c;
         fetch c into recDealDeposit;
         close c;
      end if ;
   end LoadDealDepositRec;
   --
   procedure LoadDealNettingRec as
      cursor c is select * from DealNetting where Doc = nDeal;--nDoc;
   begin
      if recDealNetting.Doc is null then
         open c;
         fetch c into recDealNetting;
         close c;
      end if ;
   end LoadDealNettingRec;
   --
   procedure LoadDealTransRec as
      cursor c is select * from DealTransaction where Doc = nDoc;
   begin
      if recDealTrans.Doc is null then
         open c;
         fetch c into recDealTrans;
         close c;
      end if ;
   end LoadDealTransRec;
   --
   procedure LoadDocCLRec as
      cursor c is select * from DocTree where Classified = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDocTreeCL.Classified is null then
         open c;
         fetch c into recDocTreeCL;
         close c;
      end if ;
   end LoadDocCLRec;
   --
   procedure LoadDealCLRec as
      cursor c is select * from Deal where Doc = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDealCL.Doc is null then
         open c;
         fetch c into recDealCL;
         close c;
      end if ;
   end LoadDealCLRec;
   --
begin
      if nDirectExpand = 1 then
      sPurpose := sTemplateCode;
      else
        begin
        select value into sPurpose from dealpaymentpurpose where fullname =  sTemplateCode;
        exception when NO_DATA_FOUND then
        --raise_application_error(-20000, 'Шаблон не найден. Код ' || sTemplateCode) ;
        tm_proc.RaiseError(42212, sTemplateCode);
        end;
      end if;
--   dbms_output.put_line('1 ' || spurpose);

   sCurrTag := '<DealLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('2 ' || spurpose);

   sCurrTag := '<DealDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDeal.DealDate); --to_char(recDeal.DealDate,'DD.MM.YYYY'));
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT));
   end if ;

--   dbms_output.put_line('3 ' || spurpose);

   sCurrTag := '<ExtraText>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag, sExtraText);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;

--   dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocDescription>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Description);
   end if ;

--   dbms_output.put_line('5 ' || spurpose);

   sCurrTag := '<DocOperDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDocTree.OperDate);
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT));
   end if ;

--   dbms_output.put_line('6 ' || spurpose);

   sCurrTag := '<RiskGroup>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        if recDocTree.Category = 914 then
            LoadDealReservRec;
            sPurpose := replace(sPurpose, sCurrTag, PactRiskGrouplabel(NVL(recDealReserv.RiskGroup, recDealReserv.OldRiskGroup)));
        else
            sPurpose := replace(sPurpose, sCurrTag, '');
        end if;
   end if ;

--   dbms_output.put_line('7 ' || spurpose);

   sCurrTag := '<COUNTERPARTY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDeal.CounterParty));
--dbms_output.put_line('8 ' || spurpose);
   end if ;

   sCurrTag := '<TICKETROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, recDealRoll.Ticket);
--dbms_output.put_line('9 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRollRec;
        sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealRoll.CounterParty));
--dbms_output.put_line('10 ' || spurpose);
   end if ;

   sCurrTag := '<ROLLDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealDepositRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealDeposit.RollOverStartDate,sDTFMT));
--dbms_output.put_line('11 ' || spurpose);
   end if ;


   sCurrTag := '<OPERDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(Message.dtDate,sDTFMT1));
--dbms_output.put_line('12 ' || spurpose);
   end if ;

   sCurrTag := '<EXTRACT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTree.Extract);
--dbms_output.put_line('13 ' || spurpose);
   end if ;

   sCurrTag := '<TRANSACTDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDeal.DealDate,sDTFMT1));
--dbms_output.put_line('14 ' || spurpose);
   end if ;

   sCurrTag := '<VALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealNetting.ValueDate,sDTFMT1));
--dbms_output.put_line('15 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYNET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealNettingRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealNetting.CounterParty));
--dbms_output.put_line('16 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARYBANK>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.BeneficiaryBank));
--dbms_output.put_line('17 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        ClientLabel(recDealTrans.Beneficiary));
--dbms_output.put_line('18 ' || spurpose);
   end if ;

   sCurrTag := '<BEGPROCDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate(nDeal),sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;
   -- дата начала начисления %%
   sCurrTag := '<BEGACCRDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      dtDateTemp := trunc(DealBegProcDate(nDeal)); -- дата последнего начисления %%
      if dtDateTemp > recDeal.ValueDate + 1 then
         dtDateTemp := dtDateTemp + 1;
      else
         dtDateTemp := recDeal.ValueDate + 1;
      end if;
      sPurpose := replace(sPurpose, sCurrTag, to_char(dtDateTemp,sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONAMOUNT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        recDealTrans.Amount);
--dbms_output.put_line('20 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealTransRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDealTrans.ValueDate,sDTFMT));
--dbms_output.put_line('21 ' || spurpose);
   end if ;

   sCurrTag := '<DOCTREEDOCVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocRec;
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(recDocTree.DocValueDate,sDTFMT));
--dbms_output.put_line('22 ' || spurpose);
   end if ;

    --тикет сделки (Deal.TICKET)
   sCurrTag := '<TICKET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, recDeal.Ticket);
   end if ;

   --кредитная линия по траншу (Deal.CREDITLINE.Label)
   sCurrTag := '<CLLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocCLRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTreeCL.Label);
   end if ;

   --дата начала кредитной линии по траншу (Deal.CREDITLINE.VALUEDATE)
   sCurrTag := '<CLVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealClRec;
        sPurpose := replace(sPurpose, sCurrTag, to_char(recDealCL.ValueDate,sDTFMT));
   end if ;

   --дата начала предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE2>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate2(nDeal),sDTFMT));
   end if ;

   --дата окончания предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE3>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate3(nDeal),sDTFMT));
   end if ;

   return SUBSTR(sPurpose,1,254);

end DEAL_GetPaymentPurpose;

create or replace function DealBegProcDate(
----------------------------------------------------------------------------------------------
-- Описание: Функция для вычисления предыдущей даты начисления процентов по депозитной сделке.
-- Автор: Цветков В.
-- Версия: 14.04.2011
--         10.06.2013 адаптирована для сделок траншей МБК (Зам. № 46876)
--         03/07/2013 Панфилов М.С. - теперь учтен вариант, когда начислений процентов ещё не было.
--         17/09/2013 Панфилов М.С. - для траншей МБК, когда начисления процентов уже были, + 1 день.
----------------------------------------------------------------------------------------------
   nDoc   in        dt.reference  -- идентификатор сделки
) return date
is
   dtStartdealdate date;
   dtEnddealdate   date;
   dtPercbegdate   date;
   nIsReceive      dealdeposit.IsReceive%type;
   nAccount        dt.reference;
   nRSAccount      dt.reference;
   nDDDoc          dt.reference;
   nIsTransh       dt.status;
begin
   select D.valuedate, D.maturitydate, DD.IsReceive, DD.Doc, DD.IsTransh
     into dtStartdealdate, dtEnddealdate, nIsReceive, nDDDoc, nIsTransh
     from deal D, dealdeposit DD
    where D.doc = nDoc
      and D.doc = DD.doc(+);
   --
   if nDDDoc is null then
      --это не депозитная сделка
      return null;
   end if;
   --
   if nIsTransh = 1 then
      -- последняя дата учета процентов по сделке.
      select nvl(max(ds.OperDate)+1,d.valuedate) into dtPercbegdate
        from DealSwapInterestLog ds, deal d
      where d.Doc = nDoc and d.doc = ds.doc(+) group by d.valuedate;
   else
      select DA.Account,DA.rsAccount
        into nAccount,nRSAccount
        from DealAccount DA, DealAccIntention DAI
       where DA.Doc = nDoc
         and DA.AccIntention = DAI.Classified
         and DAI.ConstIntention = decode(nIsReceive, 1, 18, 17);
      --
      if nRSAccount is null then
         select max(BegDate) into dtPercbegdate
           from Balance
          where Account = nAccount
            and EndDate > dtStartdealdate
            and Type = 1
            and EndTurn = 0
            and trunc(BegDate) < trunc(EndDate);
           -- order by EndDate ASC;
      else
         select max(BegDate) into dtPercbegdate
           from Reestr
          where ReestrInit = nRSAccount
            and EndDate > dtStartdealdate
            and Type = 1
            and trunc(BegDate) < trunc(EndDate);
      end if;
   end if;
   return dtPercBegDate;
end DealBegProcDate;


select * from od.dealtransaction where doc = 243785485
select * from od.dealtransaction where doc in ( 243789955,243789958)
select * from od.dealtransaction where doc = 243789958
select * from od.doctree where classified = 243789955
----------------------------------------------------------------------------------
--09/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
select * from doctype

select * from deal where doctype = 1179850206

select count(account), account from dealaccount where rsaccount is null and doc in (select classified from doctree where doctype = 1179850206)
                                group by account
                                
select * from account where classified in (
187447675,
36452487,
172287753,
201489370,
194369246,
217868442,
125550196,
194369887,
233446026,
212400533,
176245921,
222130794,
37736468,
36452493,
36452490,
73153312
)
   
--                             
select * from dealaccount where rsaccount is null and doc in (select classified from doctree where doctype = 1179850206)
                               and account in (201489370,194369246) 
                               
select * from dealaccount where doc in (select classified from doctree where doctype = 1179850206)
                               and account in (74661393)                              
                               
                               

select * from dealaccount where doc in (select classified from doctree where doctype = 1179850206)
                               and account in (174673748)
                               
select * from reestrdoc where initdoc in (229472529,
224535563,
224506446,
224533878
) and classified in (
239106377,
239098836,
239095957,
235037548
)   

select * from reestr where accountwithreestr = 1276027062
 reestrinit in (
224506446,
224533878,
224535563,
229472529)


1255933504                        

select * from dealaccintention where classified = 1000105424

select * from account where classified in (
187447675,
36452487,
172287753,
217868442,
125550196,
201489370,
194369887,
194369246,
233446026,
212400533,
222130794,
176245921,
37736468,
36452493,
36452490,
73153312
)

select * from deal where doc in (
224599602,
224600868,
224603092,
227691106,
224549226,
224550701,
224551222,
232125624,
238103420,
240754896,
224614747,
224624077,
224627499,
224628550,
224631272,
224633243
)

select * from doctree where classified in (
224599602,
224600868,
224603092,
227691106,
224549226,
224550701,
224551222,
232125624,
238103420,
240754896,
224614747,
224624077,
224627499,
224628550,
224631272,
224633243
)

31409840000000000086
31409978000197010097

select * from account where code = '31409840000000000086'

select bill_p.RepayDateNoNull(1270696986) from dual

select * from bill where num = '0001067'

----------------------------------------------------------------------------------
--10/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- отчет для Бакумцевой в RN "Отчеты - Афина - БэкОфис – Реестр сделок по размещению МБК за период"                                                               ++

select * from dealaccintention

----------------------------------------------------------------------------------
--12/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select rowid, d.* from doctree d where classified = 118457458  

select * from doctype where classified = 1015067763

select * from DP where ticket = 2727533

----------------------------------------------------------------------------------
--13/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проблема со счетами 31409840000000000086 31409978000197010097 в задаче IPI 146810 (выровнять реестры)                                                           ++
--- 09/12/2013 сделал счета реестровыми                                                                                                                            ++
--- удалить/восстановить плановое поступление в день выдачи (сформируются нулевые записи в reestr и reestrdoc), создать "изменения реестра"
--- (сформируются записи с суммами в reestr и reestrdoc, которые нужно потом проапдейтить) => 16/12/2013 сделал для 31409978000197010097 (COMMERZ) =>    
--- 17/12/2013 сделал для 31409840000000000086 (LANDERS)                                                                                                           ++
--- закрыть наконец задачу IPI 146810 => c 02/2014 за задачу взялся Миша                                                                                           ++

select rowid,  da.* from dealaccount da where /*rsaccount is null and*/ doc in (select classified from doctree where doctype = 1179850206)
                               and account in (201489370,194369246) 
  
224603092
227691106
238103420
224614747
224633243

227691106 245249852
                             
select * from dealaccount where doc in (select classified from doctree where doctype = 1179850206)
                               and account in (74661393)     

select * from accountwithreestr where account in (201489370,194369246) 

select * from accountwithreestr where account = 74661393

select * from reestr where accountwithreestr in (1298583435,1298582954) 
select * from reestrdoc where accountwithreestr in (1298583435,1298582954)  

select * from reestr where accountwithreestr = 1263223218 
select * from reestrdoc where accountwithreestr = 1263223218 

select * from doctree where classified in (
224549226,
224599602,
224600868,
224624077,
224627499,
232125624,
240754896
)

245138463
244519998
244519966
244615063
244622219
245137190
244520065


select * from doctree where classified = 224549226
select * from doctype where classified = 1179850206

select * from doctree where classified in (224614747,224633243)
select * from doctree where classified in (224628550)

od.dpc_billoper

----------------------------------------------------------------------------------
--16/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- завел в справочник RN нового контрагента ООО НПП "РАДИКО"                                                                                                        ++

select * from doctree where classified = 100104049

select * from doctree where classified in (
224614747,
224628550,
224633243,

224550701,
224551222,
224603092,
227691106
)

select rowid,  da.* from dealaccount da where /*rsaccount is null and*/ doc in (select classified from doctree where doctype = 1179850206)
                               and account in (201489370,194369246) 

select * from accountwithreestr where account in (201489370,194369246) 

select * from reestr where accountwithreestr in (1298583435,1298582954) 
select * from reestrdoc where accountwithreestr in (1298583435,1298582954)  

/*insert into reestrdoc (Classified, Doc, Sysfilial, Doctype, Ishidden, Type, accountwithreestr, Docsum, Reestrinit, Initdoc, Isclear, Rate) values 
                      (Classified.nextval, Classified.nextval, 1, 1000135223, '', 1, 1298582954, 12439586.69, 224614747, null, 1, null)*/
update reestr set enddate = to_date('16/12/2013 18:22:42','dd/mm/yyyy hh24:mi:ss') where reestrinit = 245632925 and accountwithreestr in (1298583435,1298582954) 
update reestr set reestrinit = 245632925 where reestrinit = 245688216 and accountwithreestr in (1298583435,1298582954)  
delete from reestrdoc where doc = 245688216 and accountwithreestr in (1298583435,1298582954) 
update reestrdoc set reestrinit = 245632925, docsum = abs(docsum) where doc = 245688215 and accountwithreestr in (1298583435,1298582954) 

update reestr set enddate = to_date('16/12/2013 18:39:48','dd/mm/yyyy hh24:mi:ss') where reestrinit = 245689080 and accountwithreestr in (1298583435,1298582954) 
update reestr set reestrinit = 245689080 where reestrinit = 245692495 and accountwithreestr in (1298583435,1298582954)  
delete from reestrdoc where doc = 245692495 and accountwithreestr in (1298583435,1298582954) 
update reestrdoc set reestrinit = 245689080, docsum = abs(docsum) where doc = 245692494 and accountwithreestr in (1298583435,1298582954) 

delete from reestrdoc where doc in (245690208,245690211) and accountwithreestr in (1298583435,1298582954)

update reestr set enddate = to_date('16/12/2013 18:48:56','dd/mm/yyyy hh24:mi:ss') where reestrinit = 245693842 and accountwithreestr in (1298583435,1298582954) 
update reestr set reestrinit = 245693842 where reestrinit = 245693858 and accountwithreestr in (1298583435,1298582954)  
delete from reestrdoc where doc = 245693858 and accountwithreestr in (1298583435,1298582954) 
update reestrdoc set reestrinit = 245693842, docsum = abs(docsum) where doc = 245693857 and accountwithreestr in (1298583435,1298582954) 

----------------------------------------------------------------------------------
--17/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select rowid,  da.* from dealaccount da where /*rsaccount is null and*/ doc in (select classified from doctree where doctype = 1179850206)
                               and account in (194369246) 

select * from accountwithreestr where account in (194369246) 

select * from reestr where accountwithreestr in (1298583435) 
select * from reestrdoc where accountwithreestr in (1298583435)  

update reestr set enddate = to_date('17/12/2013 11:04:59','dd/mm/yyyy hh24:mi:ss') where reestrinit = 245757790 and accountwithreestr in (1298583435) 
update reestr set reestrinit = 245757790 where reestrinit = 245770141 and accountwithreestr in (1298583435)  
delete from reestrdoc where doc = 245770141 and accountwithreestr in (1298583435) 
update reestrdoc set reestrinit = 245757790, docsum = abs(docsum) where doc = 245770139 and accountwithreestr in (1298583435) 

update reestr set enddate = to_date('17/12/2013 11:12:01','dd/mm/yyyy hh24:mi:ss') where reestrinit = 245771926 and accountwithreestr in (1298583435) 
update reestr set reestrinit = 245771926 where reestrinit = 245772707 and accountwithreestr in (1298583435)  
delete from reestrdoc where doc = 245772707 and accountwithreestr in (1298583435) 
update reestrdoc set reestrinit = 245771926, docsum = abs(docsum) where doc = 245772704 and accountwithreestr in (1298583435) 

update reestr set enddate = to_date('17/12/2013 11:16:40','dd/mm/yyyy hh24:mi:ss') where reestrinit = 245775457 and accountwithreestr in (1298583435) 
update reestr set reestrinit = 245775457 where reestrinit = 245775684 and accountwithreestr in (1298583435)  
delete from reestrdoc where doc = 245775684 and accountwithreestr in (1298583435) 
update reestrdoc set reestrinit = 245775457, docsum = abs(docsum) where doc = 245775683 and accountwithreestr in (1298583435) 

update reestr set enddate = to_date('17/12/2013 11:25:09','dd/mm/yyyy hh24:mi:ss') where reestrinit = 245776085 and accountwithreestr in (1298583435) 
update reestr set reestrinit = 245776085 where reestrinit = 245777513 and accountwithreestr in (1298583435)  
delete from reestrdoc where doc = 245777513 and accountwithreestr in (1298583435) 
update reestrdoc set reestrinit = 245776085, docsum = abs(docsum) where doc = 245777512 and accountwithreestr in (1298583435) 


select /*+ INDEX(PA cU_PortfolioAccount_All) */
    PA.Classified,
    PA.Security, substr( SecurityLabel( PA.Security ), 1, 50 ) SecurityLabel,
    PA.Currency, C.CodeISOAlph CurrencyCode, PA.ContractCurr, substr( CurrencyISO(PA.ContractCurr),1,3),
    PA.AccIntention, AI.Label IntentionLabel,
    PA.Market, substr( CompetitorLabel( PA.Market ), 1, 50 ) MarketLabel,
    PA.Account,
    substr( decode( PA.IsDepoAcc, 0, AccountCode( PA.Account ), 1, DepoAccountCode( PA.Account ), 2, DepoAccountCode( PA.Account ), 3, DepoCode( PA.Account )), 1, 50 ) AccountCode,
    PA.IsDepoAcc,
    PA.CompetitorType, CT.Label, PA.OperationType, ConstantLabel( PA.OperationType, 'PortfolioAccount','OperationType' ),
    PA.SecurityType, SecurityTypeLabel( PA.SecurityType ), PA.IsResident, decode( PA.IsResident, 0, 'нерезидент', 1, 'резидент', '' ),
    PA.TradeSession, PA.TradeClearingAccount, TCA.Code, ETV.Classified, ETV.Label,
    decode(PA.BegDate, Min_Date, null, PA.BegDate), decode(PA.EndDate, Max_Date, null, PA.EndDate),
    to_number(null), '', to_number(null), ''
  from PortfolioAccount PA, Currency C, AccIntention AI,
          ClientType CT, TradeClearingAccount TCA, EnumTypeValue ETV
  where PA.Portfolio = 1033604031 and PA.TradeClearingAccount=TCA.Classified(+)
     and PA.AccIntention = AI.Classified
     and PA.Currency = C.Classified(+)
     and AI.AccCategory in ( select Category from DocCategory )
     and PA.CompetitorType = CT.Classified(+)      
     and PA.EnumValue = ETV.Classified(+)
  order by AI.AccCategory, IntentionLabel, SecurityLabel, CurrencyCode, MarketLabel, PA.EndDate
  
  select * from PortfolioAccount where account in (select classified from account where code = '30601810100000010527')
  select * from portfolio where classified = 1061966541
  select* from doctree where classified = 227693162
  select* from doctree where classified = 245515814
  select* from doctype where classified in (1033592053,1026865354)
  
-- отключил проверку "процедура для проверки даты составления векселя" при заведении векселя для Нижнего Новгорода по задаче IPI 168638                     ++       

----------------------------------------------------------------------------------
--18/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------  

CODESYSTEM

select * from account where classified =  245983026 
od.dpc_partialcommisdischarge


select AccountBalance(null, td-1) from dual

select AccountBalance(245578164, td-1) from dual
select AccountBalance(245577044, td-1) from dual
select Context.OperDate from dual
select AccountBalance(245753372, to_date('17122013','ddmmyyyy')) from dual
select AccountBalance(245578977, to_date('17122013','ddmmyyyy')) from dual
select AccountBalance(245578777, to_date('17122013','ddmmyyyy')) from dual

select * from account where classified = 245577044

declare
begin
  for rec in
    select account from od.portfolioaccount where accintention = 1000044815
end;

select * from od.accintention where classified = 1000044815
select * from od.portfolioaccount where accintention = 1000044815 and portfolio not in (1033589735)  and market is not null
select * from portfolio where classified = 1304475208
1304475208

-- Политова привязала счета в портфели с Рынком, из-за этого не отрабатывала процедура "Начисление и проведение %%" => пришлось апдейтить                   ++  
update portfolioaccount set market = null where accintention = 1000044815 and portfolio not in (1033589735) and market is not null
--select * from od.portfolioaccount where accintention = 1000044815 and portfolio not in (1033589735)

select PortfolioAccountNm(1304550620, 1, null, 1000001275) from dual
select PortfolioAccountNm(1033547187, 1, null, 1000001275) from dual

select PortfolioAccountCl(1033547187, null, null, null, 1, null) from dual


-- отчет "Ежеквартальный отчет сделок swap (своп-договоров)" для Ледовской по задаче IPI 168665                                                             ++
--- осталось доделать: 
---- подсчет количества сделок swap                                                                                                                         ++
---- 26/12/2013 добавил ticket в сложные запросы с union для currency                                                                                       ++
---- 09/01/2014 добавить доп.признак "Передача в репозитарий отдельно по сделке" (-2002), навесить его на "Форексные сделки"                                ++
---- 09/01/2014 поправить отчет с учётом этого доп.признака                                                                                                 ++
---- закрыть задачу                                                                                                                                         ++

select substr('96901840500000003466',1,2)||'9'||substr('96901840500000003466',4,5)||'_'||substr('96901840500000003466',10,11) from dual;

select * from account t where t.code like substr('96901840500000003466',1,2)||'9'||substr('96901840500000003466',4,5)||'_'||substr('96901840500000003466',10,11)
248294425
 select d.Parent, d.DocType, d.OperDate, d.GenIntention, b.Account, b.SumAccount, p.Account, p.Amount, d.SubSystem, b.RO, d.Label, d.Description
--- into idParent, idDocType, dtOper, idIntention, idDebet, nDebAmount, idCredit, nCredAmount, idSubSystem, idRO, sLabel, sDesc
  from DocTree d, BankOper b, PrepareMoney p
  where p.Doc = d.Classified and b.Doc = d.Classified and d.Classified = 248552878

select * from proplist

SELECT * FROM objprop WHERE prop = (SELECT classified FROM proplist WHERE constprop = -2002)


declare
begin
  objattr.SaveOneProp(246834874,246834874,objattr.propclass(-2002),1);
  objattr.SaveOneProp(246834875,246834875,objattr.propclass(-2002),1);
end;

select * from deal t where 
           t.valuedate between to_date('05112013','ddmmyyyy') and to_date('31122013','ddmmyyyy')
           AND t.counterparty <>23762560   
           AND getdocstate(t.doc) <> 1000000037
           AND t.dealtype in (select classified from dealtype where consttype = 2)
           AND t.counterparty = 16298
           
           
select nvl(sum(amounts),0) as amounts, currs, nvl(sum(amounts2),0) as amounts2 from 
(
SELECT 
              t.amounts as amounts
              ,getcurrencyname(t.currencys) as currs
              ,0 as amounts2
              ,t.ticket
                   
          FROM deal t
              
           WHERE t.dealdate between to_date('05112013','ddmmyyyy') and to_date('31122013','ddmmyyyy')
           AND t.counterparty <>23762560   
           AND getdocstate(t.doc) <> 1000000037
           AND t.dealtype in (select classified from dealtype where consttype = 2)
           AND t.counterparty = 16298
           
union

SELECT 
              0 as amounts
              ,getcurrencyname(t.currencys) as currs
              ,t.amounts as amounts2
              ,t.ticket
                   
          FROM deal t
              
           WHERE t.valuedate between to_date('05112013','ddmmyyyy') and to_date('31122013','ddmmyyyy')
           AND t.counterparty <>23762560   
           AND getdocstate(t.doc) <> 1000000037
           AND t.dealtype in (select classified from dealtype where consttype = 2)
           AND t.counterparty = 16298
)	 
GROUP BY currs




select * from client where classified = 23762560

select * from deal

select * from dealtype

select getclientcode(149101733,1000104502) from dual

REPORT.TCB_LOAN_PKG.CURRENTRISKGROUP
REPORT.TCB_LOAN_PKG.currentRiskPercent

REPORT.isLoanInHolding

REPORT.GetHoldingRiskGroup_TCB

REPORT.GetHoldingPercent_TCB
REPORT.GetDocHolding 
REPORT.ReservGetElementHolding

----------------------------------------------------------------------------------
--19/12/2013----------------------------------------------------------------------
---------------------------------------------------------------------------------- 

-- привязал к группам собственных векселей Москвы счет 90705810900000000068, вместо 90705*125 по письму Герасимовой                                         ++ 

report.tcb_loan_pkg.currentRate
report.getFlowRate_tcb_IGM
report.GETFLOWRATE_TCB

report.tcb_loan_pkg.isDocValid

-- удаляем из RN кривую сделку
UPDATE fx SET fx.status = '0', fx.flag_upd = 'Y',/*U*/ mistakeback = '0'/*2*/ WHERE fx.ticket = '2734209' ;      

select * from fx where ticket = '2734209'

select * from od.Loanreservpercent
select * from od.riskgrouphistory

select * from od.riskgrouphistory
select * from od.holiday
SELECT HolidayDate FROM Holiday
WHERE HolidaySchema
select * from HolidaySchema


----------------------------------------------------------------------------------
--20/12/2013----------------------------------------------------------------------
---------------------------------------------------------------------------------- 

od.RiskGroupHistory

SELECT DISTINCT clientlabeltcb(t.counterparty) client
              ,'Обязательства ' || clientlabeltcb(t.counterparty) || ' (второй стороны)' client_dop
              ,t.counterparty as counterparty
              --,:DB as db
              --,:DE as de
              ,getclientcode(t.counterparty,1000104502) as clientcode
              ,count(t.ticket)/2
              --,t1.ticket as ticket1
    
          FROM deal t, deal t1
              
         WHERE t.dealdate between td-60 and td
           AND t.counterparty <>23762560  
           AND getdocstate(t.doc) <> 1000000037
           AND t.dealtype in (select classified from dealtype where consttype = 2)

-- for calculate counts swap-deals
           AND t.dealdate = t1.dealdate   
           AND substr(t.ticket,1,INSTR(t.ticket,'-')-1) =substr(t1.ticket,1,INSTR(t1.ticket,'-')-1)
           AND t.counterparty = t1.counterparty 
	   AND getdocstate(t1.doc)<> 1000000037   
           AND ((t.amountb = t1.amounts AND t.currencyb = t1.currencys)
           OR  (t.amounts = t1.amountb AND t.currencys = t1.currencyb)) 
           GROUP BY t.counterparty
			ORDER BY clientlabeltcb(t.counterparty)


select
704/2 - ( 
196 +
29 +
8 +
39 +
28 +
25 +
1 +
8 + 
9 +
7 +
2
)
 from dual
 
 od.SRP_LOADBICDIRECTORY_CCH_TCB
 
----------------------------------------------------------------------------------
--23/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
 
report.tcb_loan_pkg.currentRate
report.getFlowRate_tcb_IGM
report.GETFLOWRATE_TCB
report.tcb_loan_pkg.isDocValid

od.tcb_dwh.DWH_getAccrualRate
od.CALCACCRUALRATE
od.DPC_CreatePairAccount_TCB
od.DPC_CreatePairAccount
od.DPC_FXDEAL_ACCSET

----------------------------------------------------------------------------------
--25/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------
report.getFlowRate_tcb_IGM

select od.GETFLOWRATE_TCB(185761857,'001',to_date(130131,'YYMMDD')) from dual

-- патчи для ЦБ 3107-У (Изменения Положения ЦБ РФ ?385-П) и 3106-У (Изменения Положения ЦБ РФ ? 372-П)                                                            ++
od.dpc_createpercentaccountdoc
od.getbillaccount                                 -- full на Desktope     
od.dealdep_proc.CreateDepSheduleOfPayments                   
od.deal_getpaymentpurpose                         -- full на Desktope                                    
od.dealbegprocdate                                           
od.dpc_deallimit_close
od.ut_dealaccrual

od.CMP_CalcConvACCFXLong_A_TCB

----------------------------------------------------------------------------------
-- переход на 385-П
----------------------------------------------------------------------------------
-- сначала донастраиваем 372-П (от 2012 года):
--- привязать в manager для "Перевод с учетом ТСС на к.р." на действие "Исполнить" ДО ОСНОВНЫХ ДЕЙСТВИЙ РОД. ОБРАБОТЧИКА DPC_PartConvSumTransClosing (не обязательно) ++
--- подвязать к "Перевод с учетом ТСС на к.р."  в pact схему конверсии  (не обязательно)                                                                         ++
--- привязать в manager для "Форекс межбанковский" на операцию "В День 1" DPC_Option_TransfToBalance (после DPC_FXDeal_Conv) (НЕ НУЖНО, а то будут вылазить 716 счета)
--- добавить в manager для "Форекс межбанковский" на состояние "ДВР" порождение дочерних документов "Перевод с учетом ТСС на к.р." 
--- с назначением "Перевод с учетом ТСС на к.р." (не обязательно) ???????????????????????????????????????????????????????????????????????????????????????????????????
--- привязать в manager DPC_DealCFVRevaluation и DPC_PFIRevalTrans  для "Форекс межбанковский" на операции "Утвердить" после DPC_FXDeal_AccSet                   ++
--- Для действия «Переоценка ТСС» с кодом «PFIRevaluation» для всей подсистемы «дилинг» последовательно устанавливаются процедуры 
--- DPC_DealCFVRevaluation , DPC_PFIRevalTrans                                                                                                                   ++
--- привязать в manager DPC_DealCFVRevaluation и DPC_PFIRevalTrans  для "Форекс межбанковский" на операции "Исполнить"                                           ++

----------------------------------------------------------------------------------
--- 939/969 вместо 930/960 => при открытии срочного счета отключить DPC_SETCONVACC_TCB и включить DPC_OpenDiffForTimedAcc                                        ++
----------------------------------------------------------------------------------
---- привязал к Форексным сделкам Назначения счетов 70613, 70614 (нац. валюта)                                                                                   ++
---- изменил "условия" на привязках к Форексным сделкам для "Наличных и срочных назначений" (теперь 101/102 103/104)                                             ++
---- привязать в manager DPC_EditDealAccMethod для "Форекс межбанковский" на операции "Утвердить" после DPC_FXDeal_SetTimed                                      ++
---- проблема в od.DPC_FXDEAL_ACCSET (пришлось пока занулять ошибку в "select FRADate into dtFraDate from DealSwap where Doc = Context.CurrentDoc;") =>
---- после скриптов 26/12/2013 проблемы нет                                                                                                                      ++
---- добавить в manager для "Форекс межбанковский" на состояние "ДВР" порождения дочерних документов "Перевод по срочным счетам" с причинами "Перенос на баланс" и 
---- "Постановка на внебаланс" => пока не нужно                                                                                                                  ++
---- повернуть ключ ..CorrAccContext в 2                                                                                                                         ++
---- открыть и привязать (в CorrespondAccount или AccountAssoc) счета 99996 и 99997 => написал в НА, 26/12/2013 зарегистрировали замечание 29781 =>              ++
---- !!!!CorrespondAccount есть в интерфейсе!!!!
insert into CorrespondAccount
      ( Classified, Category, sysfilial, currency, accforactive, accforpassive, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 66, 1, null, 243330615, 243330614, 
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));
/*insert into CorrespondAccount
      ( Classified, Category, sysfilial, currency, accforactive, accforpassive, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 66, 1, 1000119259, 243330615, 243330614, 
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));
insert into CorrespondAccount
      ( Classified, Category, sysfilial, currency, accforactive, accforpassive, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 66, 1, 1000001171, 243330615, 243330614, 
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));*/
---- в manager для "Срочные операции" на операции "Исполнить" отключить DPC_MO_IT290 и DPC_SetTimedRs                                                           ++ 
---- добавить в manager для "Перевод по срочным счетам" на операции "Исполнить" DPC_TermDeal_OpenClose и DPC_SetTimedRs                                         ++
---- сделать новый тип документа "Перевод по срочным (технический)"                                                                                             ++
---- добавить в manager для "Перевод по срочным счетам" на состояние "Исполнен" порождение дочерних документов "Перевод по срочным (технический)" 
---- с назначением "Другие платежи"                                                                                                                             ++
---- в справочнике "Назначения счетов" для назначений 52601 и 52602 сделать "по нац. валюте"                                                                    ++

---- тесты на athena3 
---- нужно ли 52601 и 52602 / 70613 и 70614 делать парными 
---- для сделок более 2-х дней нужны парные счета 52601 и 52602 => нужно сделать дочерний тип счета в "прочих внутрибанковских" (такой же, только парный 
---- "ПФИ") и завязать 52601 и 52602 друг на друга                                                                                                                ++
---- завязать уже существующие счета друг на друга и сменить им тип на ПФИ                                                                                        ++
---- для сделок более 2-х дней нужны парные счета 70613 и 70614 => нужно сделать новые типы счетов (такие же, только парные "...ПФИ" и "...ПФИ")      
---- и завязать 70613 и 70614 друг на друга                                                                                                                       ++
---- завязать уже существующие счета друг на друга и сменить им тип на ПФИ (пока только для INTF) => 08/04/2014 вроде всё завязано, обращений давно не было        
---- задать в manager порождение документов по-умолчанию для "Переоценка ТСС" "Внутренний перевод Дилинг"                                                         ++
---- добавить в manager для "Форекс межбанковский" на состояние "ДВР" и "День1" порождение дочерних документов "Внутр перевод Дилинг" с назначением 
---- "Свертка парных счетов"                                                                                                                                      ++
---- перенести в manager процедуру DPC_FXDeal_Conv с действия "В День1" на операцию "В День2"                                                                     ++
---- в проводке 47407/47408 отвод курсовой разницы должен быть на 52601/52602 => сделать новую схему конверсии (точность - 6 знаков), 
----- сделать новую таблицу счетов дох/расх по кур.разн с использованием вычисляемых объектов CMP_CalcConvACCFXLong_A_TCB и CMP_CalcConvACCFXLong_P_TCB
---- !!! (пока \GeneralParam\PFI\FoldPairAccOnConv - Свертка парных перед конв. расчетами ПФИ = 0, чтобы не было свертки перед конверсионными расчетами)          ++
---- написать процедуру расчета ТСС с insert
---- отвязал от типов сделок "Форексная сделка" счета 61601                                                                                                       ++

---- проблема с Дт Кт при положит. и отриц. переоценке => 27/01/2014 докопался до поиска рабочего счета в паре при первой проводке переоценки по сделке 
---- (loc_CreateBlTrans), похоже, что на счетах 52601/52602 и 70613/70614 нужно ставить признак "Игнорировать ..."                                              

---- написать ежедневную процедуру для формирования проводки по ТСС по всем контрагентам с длинными сделками UT_DealCalcTSS_TCB (на основе UT_DealCFVRevaluation) 
---- => осталось дать права и тесты Ледовской => вроде всё ок                                                                                                   ++

---- написать ежедневную процедуру для свертки остатков на парных счетах 52601/52602 и 70613/70614 (ClsPairFolding_52601_70613_TCB на основе ClsPairFolding)
---- => осталось дать права и тесты Ледовской => вроде всё ок                                                                                                   ++

---- настроить удаления срочных операций в manager                                                                                                              
---- настроить банкнотные сделки                                                                                                                                
---- настроить фондовый модуль                                                                                                                                  

---- настроить на BEGIN                                                                                                                                         ++
---- накатить скрипты на боевую (кроме guid0240.sql)                                                                                                            ++
---- проверить замещаемые функции                                                                                                                               ++

---- 22/01/2014 для "Перевод по срочным (технический)" привязали схему конверсии                                                                                ++

od.UT_DealCalcTSS_TCB
od.ClsPairFolding_52601_70613_TCB
select * from docstate

update accounttype set ispaired = 1 where classified in (1000064948)

select * from generalacctree where classified in (1153458668, 1153458657)


-- завязываем парные ТИПЫ счетов друг на друга (52601 и 52602)
insert into GeneralAccLink
      ( Classified, genplanfrom, genaccfrom, genplanto, genaccto, Category)
      values
      ( od.Classified.Nextval, 1000018728, 1153458617, 1000018728, 1153458628, 1);
insert into GeneralAccLink
      ( Classified, genplanfrom, genaccfrom, genplanto, genaccto, Category)
      values
      ( od.Classified.Nextval, 1000018728, 1153458628, 1000018728, 1153458617, 1);
      
-- завязываем парные ТИПЫ счетов друг на друга (70613 и 70614)
insert into GeneralAccLink
      ( Classified, genplanfrom, genaccfrom, genplanto, genaccto, Category)
      values
      ( od.Classified.Nextval, 1000018728, 1153458668, 1000018728, 1153458657, 1);
insert into GeneralAccLink
      ( Classified, genplanfrom, genaccfrom, genplanto, genaccto, Category)
      values
      ( od.Classified.Nextval, 1000018728, 1153458657, 1000018728, 1153458668, 1);
      
-- завязываем парные счета по CITI (52601 и 52602) друг на друга 
update account set pairaccount = 155752525 where classified = 155752391;      
update account set pairaccount = 155752391 where classified = 155752525;   
-- завязываем парные счета по CITI (70613 и 70614) друг на друга 
update account set pairaccount = 155753237 where classified = 155753344;      
update account set pairaccount = 155753344 where classified = 155753237; 

-- завязываем парные счета по INTF (52601 и 52602) друг на друга 
update account set pairaccount = 248294506 where classified = 248294505;      
update account set pairaccount = 248294505 where classified = 248294506;   
-- завязываем парные счета по INTF (70613 и 70614) друг на друга 
update account set pairaccount = 248294514 where classified = 248294509;      
update account set pairaccount = 248294509 where classified = 248294514; 

-- 30/01/2014 завязываем парные счета по ФакторРус (52601 и 52602) друг на друга 
update account set pairaccount = 248294311 where classified = 248294312;      
update account set pairaccount = 248294312 where classified = 248294311; 

-- 30/01/2014 завязываем парные счета по ФакторРус (70613 и 70614) друг на друга 
update account set pairaccount = 248294305 where classified = 248294310;      
update account set pairaccount = 248294310 where classified = 248294305;

-- 22/04/2014 перезавязываем парные счета по ФакторРус (70613 и 70614) друг на друга по просьбе Ледовской (так как изначально счет 70613 бял не тот)
update account set pairaccount = 248335797 where classified = 248294310;
update account set pairaccount = 248294310 where classified = 248335797;
update account set pairaccount = null where classified = 248294305;

-- 10/02/2014 завязываем парные счета по NCCB (52601 и 52602) друг на друга 
update account set pairaccount = 248294428 where classified = 248294432;      
update account set pairaccount = 248294432 where classified = 248294428; 

-- 10/02/2014 завязываем парные счета по NCCB (70613 и 70614) друг на друга 
update account set pairaccount = 248294441 where classified = 248294438;      
update account set pairaccount = 248294438 where classified = 248294441; 

-- 13/02/2014 завязываем парные счета по COMMERZBANK AG (52601 и 52602) друг на друга 
update account set pairaccount = 253535360 where classified = 253535371;      
update account set pairaccount = 253535371 where classified = 253535360; 

-- 13/02/2014 завязываем парные счета по COMMERZBANK AG (70613 и 70614) друг на друга 
update account set pairaccount = 253536052 where classified = 253535835;      
update account set pairaccount = 253535835 where classified = 253536052; 

-- 13/02/2014 завязываем парные счета по LATE –  Норвик (52601 и 52602) друг на друга 
update account set pairaccount = 248294457 where classified = 248294456;      
update account set pairaccount = 248294456 where classified = 248294457; 

-- 13/02/2014 завязываем парные счета по LATE –  Норвик (70613 и 70614) друг на друга 
update account set pairaccount = 248294458 where classified = 248294459;      
update account set pairaccount = 248294459 where classified = 248294458; 

-- 16/04/2014 завязываем парные счета по ALFT – Альфа (52601 и 52602) друг на друга 
update account set pairaccount = 249746854 where classified = 249746866;      
update account set pairaccount = 249746866 where classified = 249746854; 

-- 16/04/2014 завязываем парные счета по ALFT – Альфа (70613 и 70614) друг на друга 
update account set pairaccount = 249746933 where classified = 249746960;      
update account set pairaccount = 249746960 where classified = 249746933; 

-- 16/04/2014 завязываем парные счета по JPFX – JPMORGAN CHASE BANK, N.A. (52601 и 52602) друг на друга 
update account set pairaccount = 263020919 where classified = 263020872;      
update account set pairaccount = 263020872 where classified = 263020919; 

-- 16/04/2014 завязываем парные счета по JPFX – JPMORGAN CHASE BANK, N.A. (70613 и 70614) друг на друга 
update account set pairaccount = 263021458 where classified = 263021880;      
update account set pairaccount = 263021880 where classified = 263021458; 

-- 17/04/2014 завязываем парные счета по CSBN – CREDIT SUISSE AG (52601 и 52602) друг на друга 
update account set pairaccount = 249746612 where classified = 249746613;      
update account set pairaccount = 249746613 where classified = 249746612; 

-- 17/04/2014 завязываем парные счета по CSBN – CREDIT SUISSE AG (70613 и 70614) друг на друга 
update account set pairaccount = 249747027 where classified = 249747093;      
update account set pairaccount = 249747093 where classified = 249747027; 

-- 17/04/2014 завязываем парные счета по IPBM – ЗАО АКБ "ИНТЕРПРОМБАНК" (52601 и 52602) друг на друга 
update account set pairaccount = 248294392 where classified = 248294391;      
update account set pairaccount = 248294391 where classified = 248294392; 

-- 17/04/2014 завязываем парные счета по IPBM – ЗАО АКБ "ИНТЕРПРОМБАНК" (70613 и 70614) друг на друга 
update account set pairaccount = 248294417 where classified = 248294410;      
update account set pairaccount = 248294410 where classified = 248294417; 

-- 21/04/2014 перезавязываем парные счета по MDM (70613 и 70614) друг на друга по просьбе Ледовской (так как изначально счет 70613 был не тот)
update account set pairaccount = 262085875 where classified = 249746995;      
update account set pairaccount = 249746995 where classified = 262085875; 

-- 10/07/2014 завязываем парные счета по РАДИКО (52601 и 52602) друг на друга 
update account set pairaccount = 276332342 where classified = 276332524;      
update account set pairaccount = 276332524 where classified = 276332342; 

-- 10/07/2014 завязываем парные счета по РАДИКО (70613 и 70614) друг на друга 
update account set pairaccount = 276334116 where classified = 276333285;      
update account set pairaccount = 276333285 where classified = 276334116; 

select * from account where classified in (276332342,276332524)  
select * from account where classified in (276333285,276334116) 

update account set pairaccount = 248294305 where classified = 248294310;
update account set pairaccount = 248294310 where classified = 248294305;

select * from account where classified in (248294428)
select * from balance where account = 248294428

select * from account where classified in (248294305,248294310, 248335797)      

select rowid, d.* from dealaccount d where doc in (261158586)
select * from deal where doc in (262949785,263086134)

-- вычисляем и записываем ТСС
delete from CurrentFairValue where ValidFrom = TO_DATE('2014-01-17','YYYY-MM-DD')
insert into CurrentFairValue
      ( Classified, doc, type, currency, value, ValidFrom, ValidTo )
      values
      ( od.Classified.Nextval, 250514950, 1156809306, 1000001275, 15000,
      TO_DATE('2014-01-17','YYYY-MM-DD'), TO_DATE('4444-01-01','YYYY-MM-DD'));
insert into CurrentFairValue
      ( Classified, doc, type, currency, value, ValidFrom, ValidTo )
      values
      ( od.Classified.Nextval, 250514907, 1156809306, 1000001275, 7000,
      TO_DATE('2014-01-24','YYYY-MM-DD'), TO_DATE('4444-01-01','YYYY-MM-DD'));
      
      
od.DPC_DealCFVRevaluation

create or replace procedure DPC_DealCalcTSS_TCB
-----------------------------------------------------------------------------------------------------------
-- Описание: Расчет суммы для проводок ТСС по сделкe на операционную дату (с учётом действующей бух. ТСС)
-- 24/01/2014 Панфилов М.С.
-----------------------------------------------------------------------------------------------------------
is 
   nSumB          DT.Amount;                                      -- сумма покупки
   nCurrB         DT.Reference;                                   -- валюта покупки
   nSumS          DT.Amount;                                      -- сумма продажи
   nCurrS         DT.Reference;                                   -- валюта продажи
   nTempSum       DT.Amount;                                      -- сумма ТСС
begin
  
  select AMOUNTB, CURRENCYB, AMOUNTS, CURRENCYS into nSumB, nCurrB, nSumS, nCurrS from deal where doc = Message.IdObject;
  
  nTempSum := nvl(GetTSSByDeal(Message.IdObject, 1, trunc(Context.OperDate), pref.ExchMatrix, 0),0) 
  + round((nSumB*Rate(nCurrB,1000001275,pref.exchmatrix,trunc(Context.OperDate))),2) 
  - round((nSumS*Rate(nCurrS,1000001275,pref.exchmatrix,trunc(Context.OperDate))),2);
  
   dbms_output.put_line('nTempSum = '||nTempSum);
   
   insert into CurrentFairValue
      ( Classified, doc, type, currency, value, ValidFrom, ValidTo )
      values
      ( od.Classified.Nextval, Message.IdObject, 1156809306, 1000001275, nTempSum,
      trunc(Context.OperDate), TO_DATE('4444-01-01','YYYY-MM-DD'));
   
end DPC_DealCalcTSS_TCB;

od.UT_DealCFVRevaluation


select * from genintention

select dp.doc from dealpact dp where exists 
(
select d.doc from deal d, doctree dt where d.pact = dp.doc and dt.classified = d.doc
  and dt.category = 901 and d.AccMethod in(1,2)
  and td >= d.dealdate and td <= d.valuedate
)

select * from deal where doc = 250414326
select * from doctree where classified = 250414326
DCT.EntityState in(select /*EW.EntityState*/ * from V_EntityStateWindow EW where EW.WindowName = 'TSSRevalueUT')

select* from account where classified =248294506
select * from accountwithreestr where account in (248294506, 248294505, 248294514, 248294509)

DealPFI.CFVRevalTrans
od.UT_DealAccrual_EveryDayFT_TCB
select * from dealpact

select * from doctype
select account into acc52601, acc52602, acc70613, acc70614 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (83));
select * from dealaccintention
select * from dealaccount where doc = 166998604
select * from doctree where classified = 76111755
select* from doctype where classified = 1047124628

od.constants
select * from docstate where classified = DocState

od.DPC_FXDeal_Conv

select dp.doc, dtr.subsystem from dealpact dp, doctree dtr where dp.doc = dtr.classified 
and exists  (select d.doc from deal d, doctree dt where d.pact = dp.doc and dt.classified = d.doc  
             and dt.category = 901 and d.AccMethod in(1,2) and to_date('10/01/2014','dd/mm/yyyy') >= d.dealdate  and to_date('10/01/2014','dd/mm/yyyy') <= d.valuedate)

 select account from dealaccount 
         where doc = 166998604 and accintention in (select classified from dealaccintention where constintention in (83));
         select account into acc52602 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (84));
         select account into acc70614 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (85));
         select account into acc70613 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (86))



create or replace procedure UT_DealCalcTSS_TCB(
----------------------------------------------------------------------------------------------------------------------------
-- Описание: Переоценка ТСС по сделкам ПФИ. (на основе UT_DealCFVRevaluation)
-- 29/01/2014 Панфилов М.С.
-- Параметры:
--       dtiDate         - дата переоценки
--       nCategory_      - категория документов (все ПФИ)
--       nMode           - режим работы утилиты: переоценка - 1 / откат - 2
--       nIsEchDealLog   - вести ли логирование успешной обработки сделок (сделка, документы переоценки, расчетов)
--       nIsCommitDoc    - фиксации транзакции после каждой успешной обработки сделки ("да" по умолчанию) нет
--       nProcessLockDoc - режим переоценки даже заблокированных сделок (по-умолчанию нет) да
----------------------------------------------------------------------------------------------------------------------------
   dtiDate         Date,
   nCategory_      DT.ConstValue default null,
   nMode           DT.Status     default 1,
   nIsEchDealLog   DT.Status     default 1,
   nIsCommitDoc    DT.Status     default 0,
   nProcessLockDoc DT.Status     default 1
) is
   dtDate          Date := s.ysDate;
   nCategory       DT.ConstValue;
   nTSS913Group    DT.ConstValue;        -- ведется ли учет ТСС по группе
   nTSS914Group    DT.ConstValue;        -- ведется ли учет ТСС по группе
   nCnt            DT.Counter := 0;
   nErr            DT.Counter := 0;
   nSucc           DT.Counter;
   --  для отбора
   sSqlExpr        DT.Text4000;         -- текст запроса
   type            T_PactType is ref cursor;
   curPact         T_PactType;  -- курсор
   -- тип для отбора сделок;
   type            tPact       is record(nDoc           DT.Reference,
                                         nSubSystem     DocTree.SubSystem%type);
   recPact         tPact;
   recPact2        DealPact%RowType;
   nDeal           DT.Reference;
   nIsMid          Dt.Status;
   idMessage       DT.Reference;
   sReturn         DT.LongText;
   sUTDesc         DT.Description;
   sMessage        DT.Label;
   nExists         Dt.Status;
   nextdeal        exception;
   --
   sPact           Dt.Text;
   sGroup          Dt.Label;
   sCatGroup       Dt.Label;
   nTssAmount      Dt.Amount;
   sDesc           Dt.Text;
   sCrlf           constant DT.Label := CHR(13)||CHR(10);
   nSysContext     DT.Reference;
   nLockMode       DT.Status;   -- режим блокировки
   nRequest_status DT.Quantity;

   nTransfer       DT.Reference;
   tempSum         DT.Amount;   -- остаток, который должен быть на счетах 52601/52602 после этой переоценки
   acc52601        DT.Reference;
   acc52602        DT.Reference;
   acc70614        DT.Reference;
   acc70613        DT.Reference;
   nRest526Old     DT.Amount;   -- сумма остатка на счетах 52601/52602 до этой переоценки
   accDeb          DT.Reference;
   accCred         DT.Reference;

   -- определение отбора сделок
   function loc_GetSql
   --
   return DT.Text4000
   is
      sRet  DT.Text4000;
   begin
               sRet := 'select dp.doc, dtr.subsystem from dealpact dp, doctree dtr where dp.doc = dtr.classified and exists '||
                        ' (select d.doc from deal d, doctree dt where d.pact = dp.doc and dt.classified = d.doc '||
                        ' and dt.category = 901 and d.AccMethod in(1,2) and dt.docstate not in (1000000036, 1000000037) '||
                        ' and to_date('''|| trunc(dtDate) ||''',''dd/mm/yyyy'') >= d.dealdate '||
                        ' and to_date('''|| trunc(dtDate) ||''',''dd/mm/yyyy'') <= d.valuedate)';
      return sRet;
   end loc_GetSql;
begin
   if nMode not in (1, 2) then
      return;
   end if;
   dtDate := nvl(dtiDate, s.ysDate);
   -- проверка операционной даты
   if trunc(dtDate) != trunc(s.ysDate) then
      -- если архивная дата отличается от параметра, выставим архивную дату - переоценка скореее всего выполняется за пред. день
      nSysContext := Context.SetContext(null, trunc(dtDate)+1 -1/86400, 9);
   end if;
   nCategory := nvl(nCategory_, 0);
   nTSS913Group := i.f(DealPFI.IsTSS913Group = 1, 913, 0);
   nTSS914Group := i.f(DealPFI.IsTSS914Group = 1, 914, 0);
   if nMode = 1 then
      sUTDesc := 'Переоценка ТСС по сделкам ПФИ за ' ||dtDate;
      sMessage := 'PFIRevaluation';
   else
      sUTDesc := 'Откат переоценки ТСС по сделкам ПФИ за ' ||dtDate;
      sMessage := 'PFIRevaluation_RB';
   end if;
   sDesc :=  'Параметры операции: '||sCrlf||
             'Дата "'||dtDate||'"'||sCrlf||
             'Категория сделок "'||i.f(nCategory = 0, 'FXLong', CategoryLabel(nCategory))||'"'||sCrlf||
             'Режим "'||i.f(nMode = 1, 'Переоценка','Откат переоценки')||'"'||sCrlf||
             'Подробный отчет по сделкам в журнале "'||i.f(nIsEchDealLog = 1, 'Да','Нет')||'"'||sCrlf||
             'Фиксация транзакции после каждой успешной обработки сделки "'||i.f(nIsCommitDoc = 1, 'Да','Нет')||'"'||sCrlf||
             'Режим переоценки даже заблокированных сделок "'||i.f(nProcessLockDoc = 1, 'Да','Нет')||'".';
   EventService.StartLog(3, 0, 'UT_DealCalcTSS_TCB', sUTDesc);
   EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sUTDesc, sDesc);
   sSqlExpr := loc_GetSql;
   -- insert into DealTemp(sSql) values (sSqlExpr); commit;
   dbms_output.put_line('nCategory = '||nCategory||' nTSS913Group = '||nTSS913Group||' nTSS914Group = '||nTSS914Group||' sSqlExpr = '||sSqlExpr);
   open curPact for sSqlExpr/* using in trunc(dtDate), trunc(dtDate), nCategory, nTSS913Group, nTSS914Group,
                                      trunc(dtDate), trunc(dtDate), nCategory, nTSS913Group, nTSS914Group*/;
   loop
      begin
         dbms_output.put_line('open curPact');
         fetch curPact into recPact;
         --
         exit when curPact%notfound;
         --
         savepoint sp1;
         nCnt := nCnt + 1;
         tempSum := 0;
         nRest526Old := 0;
         
         dbms_output.put_line('---1 rec.nDoc = '|| recPact.nDoc ||' dtDate = '|| dtDate);
         
         -- определим счета по договору
         select account into acc52601 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (83));
         select account into acc52602 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (84));
         select account into acc70614 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (85));
         select account into acc70613 from dealaccount 
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (86));
         
         dbms_output.put_line('--- 2');
         
         -- определим остаток на счетах 52601/52602, который должен быть после переоценки
         select sum( - round((AMOUNTB*Rate(CURRENCYB,1000001275,pref.exchmatrix,trunc(dtDate))),2)
                + round((AMOUNTS*Rate(CURRENCYS,1000001275,pref.exchmatrix,trunc(dtDate))),2)) into tempSum
         from deal d, doctree dt where d.pact = recPact.nDoc and dt.classified = d.doc
                        and dt.category = 901 and d.AccMethod in(1,2) and dt.docstate not in (Constants.State_RollBack, Constants.State_Cancel)
                        and dtDate >= d.dealdate and dtDate <= d.valuedate;

         sPact := 'Договор № '||DoctreeLabel(recPact.nDoc);
         EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sPact);
         sDesc := 'Переоценка ТСС по договору " № '||DoctreeLabel(recPact.nDoc)||' ". Сумма переоценки "'||abs(tempSum)||'" RUR';
           
         
         -- в зависимости от tempSum определим счета Дт Кт в результирующей проводке 
         if tempSum >= 0 then
           accDeb  := acc52602;
           accCred := acc70613;
         else 
           accDeb  := acc70614;
           accCred := acc52601;
         end if;
         
         -- создаем и исполняем перевод
         nTransfer := Easy_IntTransCreate(1047492427,                      -- тип документа (Внутренний перевод Дилинг)
                                          Constants.GetGenIntention(927),  -- назначение генерации
                                          null,                            -- родительский документ
                                          recPact.nSubSystem,              -- подсистема
                                          accDeb,                          -- cчет дебета
                                          accCred,                         -- cчет кредита
                                          abs(tempSum),                    -- cумма
                                          1000001275,                      -- валюта суммы (рубли)
                                          dtDate,                          -- дата создания
                                          DoctreeLabel(recPact.nDoc),      -- номер документа
                                          sDesc,                           -- назначение платежа
                                          dtValidDate => dtDate            -- дата валютирования
                                          );
         DocProcessForChild(nTransfer, Context.OperDate, recPact.nSubSystem, Constants.State_Close, false, false);
         
         EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sDesc, sDesc);
         EventService.PutEvent(45, 'UT_DealCalcTSS_TCB', sDesc, sDesc);

         --  манипуляции с параметром nProcessLockDoc
         /*if nProcessLockDoc = 1 then
            dbms_output.put_line('nProcessLockDoc = 1');
            -- проверяем блокировку сделки
            nRequest_status := teller_proc.lock_doc(recDeal.nDoc);
            dbms_output.put_line('nRequest_status='||nRequest_status);
            if nRequest_status = 0 then
               -- Разблокируем объект
               teller_proc.lock_release(recDeal.nDoc);
               dbms_output.put_line('lock_release');
               -- сделка свободна - штатная работа с обычной блокировкой
               nLockMode := 2;
            else
               -- Сделка уже заблокирована - обработка в спец. режиме
               nLockMode := 0;
               sDeal2 := 'Сделка('||DealTypeLabel(recDeal2.DealType)||') № '||DoctreeLabel(recDeal.nDoc)||'('||recDeal.nDoc||')'||
                     i.f(GetSwappedDeal(recDeal.nDoc) is not null, ', FX своп ', ' ')||' обработана заблокированной.';

               EventService.PutEvent(56, 'UT_DealCFVRevaluation', sDeal2, 'В процессе переоценки сделка была заблокирована другим пользователем !');
            end if;
         else
            -- обычный режим
            nLockMode := 2;
         end if;*/
         --
         /*idMessage := Message.Send(sReturn, Constants.GetEntityMessage(sMessage), recDeal.nDoc, GetDocType(recDeal.nDoc), Context.OperDate, nLockMode => nLockMode);*/
         --


         -- статистика
         /*if nIsEchDealLog = 1 then
            -- сумма текущей ТСС
            nTssAmount := GetTssByDeal(nDeal, 1, dtDate, DealPFI.GetTSSExchMatrix);
            EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDeal, 'Сумма расcчитанной переоценки "'||nTssAmount||'" RUR');
            -- проводки переоценки
            for rec in (select BO.SumAccount, DCT.Label, BO.Doc
                          from Doctree DCT, GenIntention GI, BankOper BO
                         where DCT.Parent = recDeal.nDoc
                           and DCT.Classified = BO.Doc
                           and DCT.DocType in (select Classified from Doctype where Category = 5)
                           and DCT.GenIntention = GI.Classified
                           and GI.ConstIntention in (927)
                           and trunc(DCT.ValidFromDate) = trunc(dtDate)
                           and DCT.DocState not in (Constants.State_RollBack, Constants.State_Cancel)
                      order by DCT.Classified asc )
            loop
               sDesc := 'Документ "'||rec.Label||'('||rec.Doc||')" сумма переоценки "'||rec.SumAccount||'" RUR';
               EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDesc, sDesc);
               EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDesc, sDesc);
            end loop;
            -- инициированные расчеты
            for rec in (select DCT.Label, BO.Doc
                          from Doctree DCT, GenIntention GI, BankOper BO, PrepareMoney PM
                         where DCT.Parent = recDeal.nDoc
                           and DCT.Classified = BO.Doc
                           and BO.Doc = PM.Doc
                           and DCT.DocType in (select Classified from Doctype where Category = 5)
                           and DCT.GenIntention = GI.Classified
                           and GI.ConstIntention in (923, 926, 4)
                           and trunc(DCT.ValidFromDate) = trunc(dtDate)
                           and DCT.DocState not in (Constants.State_RollBack, Constants.State_Cancel)
                           and (BO.Account in (select Account from DealAccount
                                                where Doc = DCT.Parent
                                                  and AccIntention in (select Classified from DealAccIntention
                                                                        where ConstIntention in(83,84,85,86,87,11,12,36,37,29,30,38,39))
                                               )
                                or
                                PM.Account in (select Account from DealAccount
                                                where Doc = DCT.Parent
                                                  and AccIntention in (select Classified from DealAccIntention
                                                                      where ConstIntention in(83,84,85,86,87,11,12,36,37,29,30,38,39))
                                               )
                                )
                      order by DCT.Classified asc )
            loop
               sDesc := 'Документ "'||rec.Label||'('||rec.Doc||')"';
               EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDesc, sDesc);
               EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDesc, sDesc);
            end loop;
            -- Срочные переводы
            for rec in (select DCT.Label, DCT.Classified
                          from Doctree DCT, GenIntention GI
                         where DCT.Parent = recDeal.nDoc
                           and DCT.DocType in (select Classified from Doctype where Category = 70)
                           and DCT.GenIntention = GI.Classified
                           and GI.ConstIntention in (923, 37, 941)    -- Закрытие срочных сделок, перенос на баланс
                           and trunc(DCT.ValidFromDate) = trunc(dtDate)
                           and DCT.DocState not in (Constants.State_RollBack, Constants.State_Cancel)
                         order by DCT.Classified asc)
            loop
               sDesc := 'Документ срочного перевода "'||rec.Label||'('||rec.Classified||')"';
               EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDesc, sDesc);
               EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDesc, sDesc);
            end loop;
            --
            EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDeal, 'Сумма раcсчитанной переоценки "'||nTssAmount||'" RUR');
         end if;*/
         --
         dbms_output.put_line('executed');
         if nIsCommitDoc = 1 then
            commit;
         end if;
      exception
         when nextdeal then
            null;
         when others then
            rollback to sp1;
            nErr := nErr + 1;
            EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sPact, sPact);
            EventService.PutEvent(121, 'UT_DealCalcTSS_TCB', 'Ошибка при обработке договора', SqlErrm);
            EventService.PutEvent(45, 'UT_DealCalcTSS_TCB', sPact, sPact);
            dbms_output.put_line('ОШИБКА на Pact = '||recPact.nDoc||' SqlErrm = '||SqlErrm);
      end;
   end loop;
   if curPact%IsOpen then
      close curPact;
   end if;
   nSucc := nCnt - nErr;
   EventService.PutEvent(45, 'UT_DealCalcTSS_TCB', sUTDesc,
    'Обработано сделок "'||nCnt||'" '||sCrlf||
    'Из них успешных "'||nSucc||'" '||sCrlf||
    'Ошибочных "'||nErr||'".');
   EventService.EndLog;
   if nSysContext is not null then
      Context.RestoreContext(nSysContext);
   end if;
exception
   when others then
      if nSysContext is not null then
         Context.RestoreContext(nSysContext);
      end if;
      raise;
end UT_DealCalcTSS_TCB;


od.CLSPAIRFOLDING
od.ClsPairFoldingus
select * from account where 

select a.Classified aAccount,
          nvl(AccRest(a.Classified,td,1,0),0) Sa,
          GetObjProp(a.Classified, 1000011793, td ) Wa,
          a.PairAccount pAccount,
          nvl(AccRest(a.PairAccount,td,1,0),0) Sp,
          GetObjProp(a.PairAccount, 1000011793, td ) Wp
     from Account a
    where a.SysFilial = 1
      and a.PairAccount is not null
      and a.Opened <= td
      and a.Closed = TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')
      and a.IsActiveInReport =1
	  and ((substr(a.CODE,1,5) = '52601') or (substr(a.CODE,1,5) = '70613') or (substr(a.CODE,1,5) = '52602') or (substr(a.CODE,1,5) = '70614'))
      and ( 0 = 0 or 0 = 1 and a.Category != 66 or
            0 = 2 and a.Category = 66)
            
            
            select * from account where classified  = 248294311
            
            select * from account where code = '70613810911201620199' -- 248294305


create or replace procedure FoldPairTotal_52601_70613_TCB
--------------------------------------------------------------------------------
-- Свертка парных счетов на указанную дату. (на основе FoldPairTotal)
-- 31/01/2014 Панфилов М.С.
--------------------------------------------------------------------------------
(
 nParentDoc  in  DocTree.Classified%type, -- родительский документ
 nSubSystem  in  SubSystem.Code%type,     -- подсистема
 dtFoldDate  in  date,                    -- дата свертки остатков
 nIsEndTurn  in  dt.Status default 0,   -- признак ЗО
 nTimedLess  in  dt.Status default null   -- 0 - все счета, 1 - все, кроме "Г", 2 - только  "Г"
)
as
   nIsEnd       dt.Status := nvl(nIsEndTurn,0); -- признак ЗО
   nTimedMode   dt.Status := nvl(nTimedLess,0);   -- режим работы со срочными счетами
   -- Курсор на счета, требующие свертки
   cursor curFold( dtDate date, nProp dt.Reference, nEndTurn dt.Status, nTimed dt.Status ) is
   select a.Classified aAccount,
          nvl(AccRest(a.Classified,dtDate,1,nEndTurn),0) Sa,
          GetObjProp(a.Classified, nProp, dtDate ) Wa,
          a.PairAccount pAccount,
          nvl(AccRest(a.PairAccount,dtDate,1,nEndTurn),0) Sp,
          GetObjProp(a.PairAccount, nProp, dtDate ) Wp
     from Account a
    where a.SysFilial = (select C_Access.GetFilial from dual)
      and a.PairAccount is not null
      and a.Opened <= dtDate
      and a.Closed = TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')
      and a.IsActiveInReport =1
	  and ((substr(a.CODE,1,5) = '52601') or (substr(a.CODE,1,5) = '70613'))
      and ( nTimed = 0 or nTimed = 1 and a.Category != 66 or
            nTimed = 2 and a.Category = 66);
   --
   nMOType DocType.Classified%type;
   nPropWorkAcc dt.Reference;
begin
   --
   nMOType := teller_proc.DChildType(nParentDoc,nSubSystem,7,Constants.Pay_PairFolding);
   nPropWorkAcc := PropClass(49);
   -- цикл по обычным парным счетам
   for rec in curFold( dtFoldDate, nPropWorkAcc, nIsEnd, nTimedMode ) loop
     dbms_output.put_line('--- FoldPairTotal_52601_70613_TCB dtFoldDate = '|| dtFoldDate ||' nPropWorkAcc = '|| nPropWorkAcc ||' nIsEnd = '|| nIsEnd ||' nTimedMode = '|| nTimedMode);
      FoldPairBalance(rec.aAccount,
                      rec.Sa,
                      rec.Wa,
                      rec.pAccount,
                      rec.Sp,
                      rec.Wp,
                      FALSE,
                      nMOType,
                      nParentDoc,
                      nSubSystem,
                      dtFoldDate,
                      nPropWorkAcc,
                      nIsEnd);
   end loop;
end FoldPairTotal_52601_70613_TCB;
create or replace procedure ClsPairFolding_52601_70613_TCB
------------------------------------------------------------------------------------
-- Свертка парных счетов на интервале (на основе ClsPairFolding)
-- 31/01/2014 Панфилов М.С.
------------------------------------------------------------------------------------
(
 dtFoldingBeg   in  date,                  -- начало интервала
 dtFoldingEnd   in  date,                  -- конец интервала
 nIsEndTurn     in  dt.Status default 0, -- признак ЗО
 nTimedLess     in  dt.Status default null -- 0 - все счета, 1 - все, кроме "Г", 2 - только  "Г"
 )
as
   nDocType     dt.Reference; -- тип головного документа по свертке
   nDoc         dt.Reference; -- головной документ по свертке
   dtFoldDate   date;         -- один из моментов свертки остатков
   dtFoldEnd    date;         -- конец интервала свертки остатков
   nSubSystem   dt.Reference default nvl(Context.SubSystem,1); -- подсистема
   nIsEnd       dt.Status := nvl(nIsEndTurn,0); -- признак ЗО
   sFoldTime    dt.Label;     -- Время свертки в формате "hh24:mi:ss"
   nFoldTime    dt.Relation;  -- Время свертки - доли суток
   dtDate       date;         -- вспомогательная дата.
   nTimedMode   dt.Status default nvl(nTimedLess,0); -- режим работы со срочными счетами
begin
   SetNoCheckRights;
   if dtFoldingBeg is null or dtFoldingEnd is null or dtFoldingEnd < dtFoldingBeg then
      --raise_application_error(-20000,'Неверно указаны временные границы.');
      ErrorMessage.RaiseError(1031);
   elsif trunc(dtFoldingBeg) = trunc(dtFoldingEnd) then
      dtFoldEnd := trunc(dtFoldingBeg)+1;  -- конец интервала свертки остатков
   else
      dtFoldEnd := dtFoldingEnd;
   end if;
   -- найдем время свертки
   sFoldTime := nvl(ltrim(rtrim(Registry.GetValue('GeneralParam'||'\'||'BankOper'||'\'||'PairFoldingTime'))),'23:59:59');
   begin
      dtDate := to_date(sFoldTime,'hh24:mi:ss');
   exception
      when OTHERS then
         raise_application_error(-20000,
         'Некорректный формат времени свертки парных счетов в ключе <PairFoldingTime>');
   end;
   -- время свертки в долях суток, итог:
   nFoldTime := dtDate - trunc ( dtDate );
   --
   -- Определить тип головного документа по свертке остатков
   nDocType := teller_proc.DChildType( Context.CurrentDoc, nSubSystem,
                                       54, Constants.Pay_PairFolding);
   -- Осуществить свертку на каждой из границ суток выбранного периода
   dtFoldDate := TRUNC(dtFoldingBeg) + nFoldTime;
   --
   -- цикл по всем суткам внутри интервала
   loop
      exit when dtFoldDate > dtFoldEnd;
      CreateCommonParent
                   (nDoc,                      -- newClassified
                    nSubSystem,                -- newSubSystem
                    nDocType,                  -- newType
                    Context.CurrentDoc,        -- newParent
                    'Свертка парных счетов',   -- newLabel
                    'Свертка остатков на парных счетах', -- newDescription
                    NULL,                      -- newObj
                    NULL,                      -- newValidFromDate
                    NULL,                      -- newValidToDate
                    NULL,                      -- newPriority
                    NULL,                      -- newInitObj
                    dtFoldDate,                -- newOperDate
                    NULL,                      -- newOperCause
                    Constants.Pay_PairFolding, -- newIntention
                    FALSE  );
      -- зафиксируем режим работы со срочными счетами
      update DocTree set OperObj = nTimedMode where Classified = nDoc;
      -- свертка
      dbms_output.put_line('--- FoldPairTotal_52601_70613_TCB ');
      FoldPairTotal_52601_70613_TCB (nDoc, nSubSystem, dtFoldDate, nIsEnd, nTimedMode);
      DocProcessTurbo(nDoc,dtFoldDate,nSubSystem,null);
      dtFoldDate := dtFoldDate + 1;
   end loop;
   RestoreCheckRights;
   exception
      when OTHERS then
         RestoreCheckRights;
         raise;
end ClsPairFolding_52601_70613_TCB;



create or replace function CMP_CalcConvACCFXLong_A_TCB
--------------------------------------------------------------------------------
-- Назначение: Счет для отвода курсовой разницы по длинным срочным сделкам (находим в счетах 52601/52602 под сделкой)
-- 28/01/2014 Панфилов М.С. 
--------------------------------------------------------------------------------
(
 idCurrFrom    dt.Reference,              -- валюта "из"
 idCurrTo      dt.Reference,              -- валюта "в"
 idCurrDiff    dt.Reference,              -- валюта разницы
 nType         dt.Status,                 -- тип таблицы
 nCategory     dt.Reference               -- категория счета
)
return dt.Reference
as
acc dt.Reference;
begin
  select account into acc from dealaccount where doc = parentdoc(Context.CurrentDoc) and accintention in (select classified from dealaccintention where constintention in (83));
  dbms_output.put_line('doc = ' || Context.CurrentDoc);
  return acc;
 exception
   when others then
        raise_application_error(-20000,'Ошибка при определении счета курс.разницы');
end CMP_CalcConvACCFXLong_A_TCB;

create or replace function CMP_CalcConvACCFXLong_P_TCB
--------------------------------------------------------------------------------
-- Назначение: Счет для отвода курсовой разницы по длинным срочным сделкам (находим в счетах 52601/52602 под сделкой)
-- 28/01/2014 Панфилов М.С. 
--------------------------------------------------------------------------------
(
 idCurrFrom    dt.Reference,              -- валюта "из"
 idCurrTo      dt.Reference,              -- валюта "в"
 idCurrDiff    dt.Reference,              -- валюта разницы
 nType         dt.Status,                 -- тип таблицы
 nCategory     dt.Reference               -- категория счета
)
return dt.Reference
as
acc dt.Reference;
begin
  select account into acc from dealaccount where doc = parentdoc(Context.CurrentDoc) and accintention in (select classified from dealaccintention where constintention in (84));
  dbms_output.put_line('doc = ' || Context.CurrentDoc);
  return acc;
 exception
   when others then
        raise_application_error(-20000,'Ошибка при определении счета курс.разницы');
end CMP_CalcConvACCFXLong_P_TCB;


 INSERT INTO ConvVariant( Classified, sysfilial, ConvType, Label, Code, Description, Category, ValidFrom, HideConvAcc, DealRate, NBRateType )
 VALUES( Classified.Nextval, 1, 3 , 'КР Для валютного дилинга (FXLong)', 'DealFXLong', NULL,
    2, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), -1, 0, 0 )
    
 INSERT INTO convdiffmatrix( Classified, sysfilial, variant, Type, currdiff, ValidFrom, computeaccinc, computeaccexp)
 VALUES( Classified.Nextval, 1, 1321045907, 0, 1000001275, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), 1321045786, 1321045787)    
    
 
 INSERT INTO ConvVariant( Classified, sysfilial, ConvType, Label, Code, Description, Category, ValidFrom, DealRate, NBRateType )
 VALUES( Classified.Nextval, 1, 0 , 'Схема для валютного дилинга (FXLong)', 'DealFXLong', NULL,
    2, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), 1, 0 ) 

 INSERT INTO convschema( Classified, sysfilial, variant, DateFrom, exchmatrix, diffmatrix)
 VALUES( Classified.Nextval, 1, 1321049933, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), 1000131199, 1321045907)   
 
 
-- 1101895902 - 1000131199
 INSERT INTO ConvVariant( Classified, sysfilial, ConvType, Label, Code, Description, Category, ValidFrom, HideConvAcc, DealRate, NBRateType )
 VALUES( Classified.Nextval, 1, 3, 'КР Для валютного дилинга (FXLong)', 'DealFXLong', NULL,
    2, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), -1, 0, 0 )
    
 INSERT INTO convdiffmatrix( Classified, sysfilial, variant, Type, currdiff, ValidFrom, computeaccinc, computeaccexp)
 VALUES( Classified.Nextval, 1, 1321583869, 0, 1000001275, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), 1321564776, 1321564815)    
    
 
 INSERT INTO ConvVariant( Classified, sysfilial, ConvType, Label, Code, Description, Category, ValidFrom, DealRate, NBRateType )
 VALUES( Classified.Nextval, 1, 0 , 'Схема для валютного дилинга (FXLong)', 'DealFXLong', NULL,
    2, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), 1, 0 ) 

 INSERT INTO convschema( Classified, sysfilial, variant, DateFrom, exchmatrix, diffmatrix)
 VALUES( Classified.Nextval, 1, 1321585478, TO_DATE( '2014-01-01-12.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), 1101895902, 1321583869)
 
 
select rowid, c.* from ConvVariant c  

select * from computeobject
   
select rowid, c.* from convdiffmatrix c where variant in (1052521722,1052522085,1321049933,1321045907)

select rowid, c.* from od.convschema c where variant in (1052521722,1052522085,1321049933,1321045907)
    
        
od.FXDeal_TimedEnd
od.FXDeal_Conv    
      
select * from dealaccintention
select * from doctype where classified = 1000135223
select * from doccategory
select * 
FROM GenIntention 
select * from account where code = '52601810450002401202'
select * from accountwithreestr where account = 248294506

select * from reestr where accountwithreestr = 1320073001
select * from reestrdoc where accountwithreestr = 1320073001

select * from account where code = '70613810914001610102'
select * from accountwithreestr where account = 155753237
      
update accounttype set ispaired = null where classified in (1107083106,1107083107) -- это 47407/47408 и возможно их не обязательно делать парными
      
select * from GeneralAccLink where genaccto = 1023806910 or genaccfrom = 1023806910
select * from GeneralAccLink where genaccfrom = 1023806910 

od.DPC_CreatePairAccount_TCB
od.DPC_SynchronizePair_TCB
od.DPC_CreatePairAccount

select * from od.account where classified = 243330888
select * from od.account where classified = 243330889
select * from od.account where classified = 243330890
select * from od.account where pairaccount is not null





select * from accounttype
update accounttype set ispaired = null where classified in (1107083106,1107083107)

delete from CorrespondAccount
select * from CorrespondAccount

select * from account where classified = 243330614
select * from currency

od.DPC_TERMDEAL_OPENCLOSE
od.DPC_FXDEAL_ACCSET 

declare
begin
AccAssoc_proc.LinkRateDiffAcc(150134460,243330614,1);
AccAssoc_proc.LinkRateDiffAcc(150134460,243330615,2);
end;

select * from AccountAssoc where account = 150134460

od.DPC_TERMDEAL_OPENCLOSE
od.DPC_FXDeal_SetTimed
od.FXDeal_SetTimed

select * from doccategory 

od.EditDealAccMethod(recDeal, niAccMethod);

select * from account where code like '99997%' 

od.DPC_FXDEAL_ACCSET
od.DPC_EditDealAccMethod

-- 24/01/2014 привязать счета 52601/52602 к сделке "ФакторРус" 246887728                                                                                        ++
-- 24/01/2014 привязать счета 52601/52602 к сделке "ФакторРус" 246887728                                                                                        ++
select * from dealaccintention where classified in (1156809334, 1156809332)
select * from dealaccintention where classified in (1156809338, 1156809336)

select rowid, da.* from dealaccount da where accintention in (1156809334, 1156809332)
select rowid, da.* from dealaccount da where accintention in (1156809338, 1156809336)

select * from AcctAssocIntention

FXDeal_SetTimed

select * from od.dealswap

select * from AccountAssoc where assoc = 243330614
select * from AccountAssocIntention
select * from account where classified = 150470346

-- привязываем вручную счета корреспонденции к срочным счетам (если не настроен случай общих для филиала счетов корреспонденции)
insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 150470346, 243330614, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));
      
insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 150470345, 243330615, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));

select * from account where classified =150470346

insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 225377812, 243330614, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));
   
insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 150411931, 243330614, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));

insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 150134460, 243330614, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));   

insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 225393596, 243330615, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));

insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 150134456, 243330615, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));


insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 198519827, 243330614, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));

insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 204687844, 243330614, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));
      
insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 204687842, 243330615, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));

insert into AccountAssoc
      ( Classified, Category, Intention, account, assoc, ASSOCORDER, ValidFromDate, ValidToDate )
      values
      ( od.Classified.Nextval, 4, 1, 198519825, 243330615, null,
      TO_DATE('1980-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'), TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS'));     
      

select * from account where classified = 155752391
od.DPC_SynchronizePair_TCB

SELECT L.Classified, L.GenPlanTo, L.GenAccTo, T.Label,
    rtrim(ltrim(T1.Code)) || ' : ' || rtrim(ltrim(T1.Label)), L.Category, nvl(CL.Label,'<íå óêàçàíà>')
FROM GeneralAccTree T, GeneralAccTree T1,  GeneralAccLink L, ConstantsLabel CL
WHERE L.GenPlanFrom = 1000018728 AND L.GenAccFrom = 1153458668
    AND T.Classified = L.GenPlanTo
    AND T1.Classified =  L.GenAccTo
    AND L.Category = CL.ConstValue (+)
    AND CL.Table_Name (+) = 'GENERALACCLINK'
    AND CL.Column_Name (+) = 'CATEGORY'
ORDER BY 4, 7, 5


select * from GeneralAccLink where genaccto = 1023806910 or genaccfrom = 1023806910
select * from GeneralAccLink where genaccfrom = 1023806910

od.GetTimedCorrAcc

od.DPC_DEALCFVREVALUATION

create or replace function GetTimedCorrAcc
--------------------------------------------------------------------------------
-- Назначение: Найти счет корреспонденции для срочного лицевого счета
-- Версия от : 11/12/13 (17/10/13)
-- Автор     : А.Коновалов.
-- Параметры :
--------------------------------------------------------------------------------
(
 idAccount    dt.Reference,           -- счет
 dtDate       date default s.ysdate   -- дата
)
return dt.Reference
as
   idCorrAcc    dt.Reference;         -- счет корреспонденции
   nIsActive    dt.Status;            -- активность счета
   nSysFilial   dt.ConstValue;        -- филиал
   nCategory    dt.Reference;         -- категория счета
   idCurrency   dt.Reference;         -- валюта счета
begin
   -- если счета ведутся на уровне сделки
   if Timed_proc.GetCorrAccContext = 1 then
      -- ищем инд. привязку корр. счета
      select Assoc into idCorrAcc
        from AccountAssoc
       where Account = idAccount
         and Category = 4
         and Intention = 1
         and ValidFromDate <= dtDate
         and ValidToDate > dtDate;
      -- возвращаем результат
      return idCorrAcc;
      --
      -- если на уровне филиала, то ищем счет в справочнике
   else
      -- параметры счета операции
      select SysFilial, IsActiveInReport, Category, Currency
        into nSysFilial, nIsActive, nCategory, idCurrency
        from Account
       where Classified = idAccount;
      -- счета корреспонденции филиала:
      for rec in ( select AccForActive, AccForPassive, Currency
                     from CorrespondAccount
                    where SysFilial = nSysFilial
                      and Category = nCategory
                      and (Currency = idCurrency or Currency is null)
                      and ValidFromDate <= dtDate
                      and ValidToDate > dtDate
                   order by Currency )
      loop
         if nIsActive = 1 then
            -- счет активный
            return rec.AccForActive;
         else
            -- счет пассивный
            return rec.AccForPassive;
         end if;
      end loop;
      --
   end if;
   -- не нашли
   return null;
   --
exception
   when OTHERS then
      return null;
end GetTimedCorrAcc;



CurrentFairValue

----------------------------------------------------------------- 

----------------------------------------------------------------------------------
--30/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doccategory

select * from dealaccintention where classified = (1000105427)

select * from 
nvl((select sum(abs((amount*rate(d.currencyb,1000001275,1000131199,:DT))/1000)) from dealswappayment where doc = d.doc and amount < 0 and paymenttype in (1,4) and valuedate >= :DT and valuedate < :DT+30),0)


nvl((select sum(abs((amount*rate(d.currencyb,1000001275,1000131199,:DT))/1000)) from dealswappayment where doc = d.doc and amount < 0 and paymenttype in (1,4) and valuedate >= :DT+731 and valuedate <= :DT+1825),0)

select * from dealswappayment where doc =  217676054



select p.COMPETITOR                 as  classified
        ,OD.CLIENTLABEL(p.COMPETITOR) as  client
        ,trim(c.CODE)                 as  code
        ,s.LABEL                      as  issue
        ,s.REGISTRCODE                as  regCode
        ,OD.GET_BANKCODE(s.CLASSIFIED, 1000127805) as ISIN
        ,sum(OD.GET_DEPOBAL(r.classified, to_date('20131227 23:59:59','yyyymmdd hh24:mi:ss'))) as  amt
        ,s.classified
    from OD.DEPO         d
        ,OD.DEPOACCOUNT  a
        ,OD.DEPOACCOUNT  r
        ,OD.PORTFOLIO    p
        ,od.COMPETITORMARKETINFO c
        ,od.SYSDEPO      y
        ,od.DEPOSECURITY s
   where d.TYPE          in (1021767785, 
                             1021767792, 
                             1021767797, 
                             1021767798, 
                             1201024558)
     and a.DEPO          = d.CLASSIFIED
     and p.COMPETITOR    = d.CLIENT(+)
     and c.PORTFOLIO(+)     = p.CLASSIFIED
     and c.MARKET        = 1033590798
     and r.DEPOPARTITION = a.CLASSIFIED
     and (r.CLOSED       > to_date('20131227 23:59:59','yyyymmdd hh24:mi:ss') 
      or  r.CLOSED       is null)
     and (a.CLOSED       > to_date('20131227 23:59:59','yyyymmdd hh24:mi:ss') 
      or  a.CLOSED       is null)
     and y.CLASSIFIED    = r.SYSDEPO
     and s.SYSSECURITY   = y.SECURITY and s.classified = 1021766734
group by p.COMPETITOR
        ,c.CODE
        ,s.LABEL
        ,s.REGISTRCODE
        ,s.CLASSIFIED

select * from depo where  TYPE          in (1021767785, 
                             1021767792, 
                             1021767797, 
                             1021767798, 
                             1201024558)

select * from depotype where classified = 1021767785

select c.*, CLIENTLABEL(c.COMPETITOR) from COMPETITORMARKETINFO c




select NG.*, DT.Label, DT.GenIntention from DealNetting NG, TransferMessage TM, ClearingHouse CH, DocTree DT
                        where NG.Doc = 247866133
                          and NG.TMAdvise = TM.Classified
                          and TM.ConstMsg = 160
                          and NG.CHAdvise = CH.Classified
                          and CH.Const IN (1,16) --srb добавлено 16 (для телекса)
                          and DT.Classified = NG.Doc

select NG.*, DT.Label, DT.GenIntention from DealNetting NG, TransferMessage TM, ClearingHouse CH, DocTree DT
                        where NG.Doc = 247576684
                          and NG.TMAdvise = TM.Classified
                          and TM.ConstMsg = 160
                          and NG.CHAdvise = CH.Classified
                          and CH.Const IN (1,16) --srb добавлено 16 (для телекса)
                          and DT.Classified = NG.Doc

od.dpc_tcb_dealswift_mt399

----------------------------------------------------------------------------------
--31/12/2013----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.GetBillAccount

od.DPC_FXDeal_Conv
od.FXDeal_Conv
od.DPC_Option_TransfToBalance
od.DPC_DEALCFVREVALUATION 

select * from doccategory

if 
checkmulticonditions('-dilling_qwe,-isExistChildValPP')  = 1 
then :nCondResult := 1;
else :nCondResult := 0;
end if;

select C.Value, C.Currency, T.Const
                       from CurrentFairValue C, CurrentFairValueType T
                      where C.Doc = idDoc
                        and C.Type = T.Classified
                        and dtDate = C.ValidFrom
                        and dtDate < C.ValidTo
                        and T.Const = nIntention
                        
select *
                       from CurrentFairValue 
select *
                       from CurrentFairValueType

DealPFI.CFVRevaluation

----------------------------------------------------------------------------------
--03/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from accounttype
select * from od.acctype

select * from doccategory

od.DPC_EDITGENERALACCTREE

od.DPC_SetConvAcc_TCB

od.DPC_SetConvAcc

select * from dealaccount where doc = 248188496 and accintention in (1000105440,1000105441)

-- привязывал новые счета 969/939 к сделкам
update dealaccount set account = 248294778 where doc = 248188496 and accintention in (1000105440)
update dealaccount set account = 248294795 where doc = 248188496 and accintention in (1000105441)

update dealaccount set account = 248294785 where doc = 248188498 and accintention in (1000105440)
update dealaccount set account = 248294794 where doc = 248188498 and accintention in (1000105441)

update dealaccount set account = 248294785 where doc = 248195551 and accintention in (1000105440)
update dealaccount set account = 248294796 where doc = 248195551 and accintention in (1000105441)

update dealaccount set account = 248294784 where doc = 247832066 and accintention in (1000105440)
update dealaccount set account = 248294795 where doc = 247832066 and accintention in (1000105441)

update dealaccount set account = 248294785 where doc = 247832915 and accintention in (1000105440)
update dealaccount set account = 248294794 where doc = 247832915 and accintention in (1000105441)

update dealaccount set account = 248294779 where doc = 247832064 and accintention in (1000105440)
update dealaccount set account = 248294795 where doc = 247832064 and accintention in (1000105441)

update dealaccount set account = 248294343 where doc = 247837918 and accintention in (1000105440)
update dealaccount set account = 248294352 where doc = 247837918 and accintention in (1000105441)

update dealaccount set account = 248294359 where doc = 247904601 and accintention in (1000105440)
update dealaccount set account = 248294355 where doc = 247904601 and accintention in (1000105441)

update dealaccount set account = 248294370 where doc = 247857225 and accintention in (1000105440)
update dealaccount set account = 248294390 where doc = 247857225 and accintention in (1000105441)

update dealaccount set account = 248294810 where doc = 247819245 and accintention in (1000105440)
update dealaccount set account = 248294805 where doc = 247819245 and accintention in (1000105441)

update dealaccount set account = 248294808 where doc = 247816716 and accintention in (1000105440)
update dealaccount set account = 248294805 where doc = 247816716 and accintention in (1000105441)

update dealaccount set account = 248294426 where doc = 247969753 and accintention in (1000105440)
update dealaccount set account = 248294422 where doc = 247969753 and accintention in (1000105441)

update dealaccount set account = 248294426 where doc = 247969755 and accintention in (1000105440)
update dealaccount set account = 248294422 where doc = 247969755 and accintention in (1000105441)

update dealaccount set account = 248294426 where doc = 247890129 and accintention in (1000105440)
update dealaccount set account = 248294423 where doc = 247890129 and accintention in (1000105441)

update dealaccount set account = 248294425 where doc = 247980793 and accintention in (1000105440)
update dealaccount set account = 248294421 where doc = 247980793 and accintention in (1000105441)

update dealaccount set account = 248294425 where doc = 247981004 and accintention in (1000105440)
update dealaccount set account = 248294421 where doc = 247981004 and accintention in (1000105441)

update dealaccount set account = 248294425 where doc = 247980794 and accintention in (1000105440)
update dealaccount set account = 248294421 where doc = 247980794 and accintention in (1000105441)

update dealaccount set account = 248294425 where doc = 247772703 and accintention in (1000105440)
update dealaccount set account = 248294421 where doc = 247772703 and accintention in (1000105441)

update dealaccount set account = 248294425 where doc = 247763807 and accintention in (1000105440)
update dealaccount set account = 248294421 where doc = 247763807 and accintention in (1000105441)

update dealaccount set account = 248294424 where doc = 247765803 and accintention in (1000105440)
update dealaccount set account = 248294421 where doc = 247765803 and accintention in (1000105441)

select * from dealaccintention where classified in (1000105440,1000105441)

----------------------------------------------------------------------------------
--05/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_SetTimedRs
-- включал для Прозоровой на "Переводах по срочным счетам" доп. признак "Не проводить проверок" (103) => сделал спец.операцию "Без проверок" для простановки этого
-- доп.признака => забрал потом права                                                                                                                             ++

select 3681*0.0875*(27/365) + 8681*0.0875*(4/365) from dual

od.DPC_OPTION_TRANSFTOBALANCE
select * from dealaccintention
od.DPC_FXDeal_AccSet
DPC_FXDeal_SetTimed 
od.EditDealAccMethod

od.DPC_RECALCACCOUNTNATIONSUM
od.RecalcEquivEngine
od.DPC_DOCCHECKOPERDATE

select * --ArcDate, OperDateBeg, OperDateEnd --into dtArcDate, dtOperDateBeg, dtOperDateEnd
        from OperDateSet where DocType = 1000135286 and SysFilial = 1;
        
        select * from doctype where classified in (
        1000135244,
1000135265,
1000135286
)

od.DPC_DEALCFVREVALUATION

od.UT_CFVRevaluation
od.DealPFI.CFVRevalTrans

select * from CurrentFairValue
select * from CurrentFairValueType
select * from currency

-- вычисляем и записываем ТСС
delete from CurrentFairValue where ValidFrom = TO_DATE('2013-12-27','YYYY-MM-DD')
insert into CurrentFairValue
      ( Classified, doc, type, currency, value, ValidFrom, ValidTo )
      values
      ( od.Classified.Nextval, 243331672, 1156809306, 1000001275, 1000000,
      TO_DATE('2013-12-22','YYYY-MM-DD'), TO_DATE('4444-01-01','YYYY-MM-DD'));
insert into CurrentFairValue
      ( Classified, doc, type, currency, value, ValidFrom, ValidTo )
      values
      ( od.Classified.Nextval, 243331909, 1156809306, 1000001275, 1000050,
      TO_DATE('2013-11-19','YYYY-MM-DD'), TO_DATE('4444-01-01','YYYY-MM-DD'));
insert into CurrentFairValue
      ( Classified, doc, type, currency, value, ValidFrom, ValidTo )
      values
      ( od.Classified.Nextval, 243331853, 1156809306, 1000001275, 1000055,
      TO_DATE('2013-12-27','YYYY-MM-DD'), TO_DATE('4444-01-01','YYYY-MM-DD'));

----------------------------------------------------------------------------------
--09/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_ChangeTimedAcc_TCB
select * from PrepareMoney

-- правил bbr.BBR_BANKLETTER_MBC_TCB для Бакумцевой (уменьшал высоту страницы 110 -> 100, чтобы не глючил многостраничный отчет по МСП) => вернуть назад          ++
bbr.BBR_BANKLETTER_MBC_TCB

SELECT c.Classified,  c.Label 
FROM  Client c 
WHERE
 c.Type = 1000001778
 --AND c.Label LIKE '''||sClntLabel||''' 
 AND exists ( select a.classified 
             from Account a, Currency cur, doctree dt
             where a.Client = c.Classified
             and cur.Classified = a.Currency
             and a.Code LIKE '3%'
             and dt.classified = a.doc
             and dt.docstate!=1000000037
             and a.sysfilial=1
             and 
             (
             ((a.code like '312%' or a.code like '313%' or a.code like '319%' or a.code like '320%')
             and (a.code not like '32015%'))
             or
             ((a.code like '322%3466' or a.code like '47423%3466' or a.code like '315%3466')
             and a.client = 23762560)
             )
             and a.closed> to_date('2014-01-01','YYYY-MM-DD') )
             
select a.classified, a.code, cur.classified, abs(NVL(AccountRest(a.Classified,to_date('2014-01-01','YYYY-MM-DD'),1,0),0)), 
       cur.CodeISONUMB, abs(NVL(AccountRest(a.Classified,to_date('2014-01-01','YYYY-MM-DD'),5,0),0))
             from Account a, Currency cur, doctree dt 
             where a.Client = 16822
             and cur.Classified = a.Currency
             and a.Code LIKE '3%'
             and dt.classified = a.doc
             and dt.docstate!=1000000037
             and a.sysfilial=1
             and 
             (
             ((a.code like '312%' or a.code like '313%' or a.code like '319%' or a.code like '320%')
             and (a.code not like '32015%'))
             or
             ((a.code like '322%3466' or a.code like '47423%3466' or a.code like '315%3466')
             and a.client = 23762560)
             )
             and a.closed>to_date('2014-01-01','YYYY-MM-DD')


od.DPC_ChangeTimedAcc_TCB

create or replace procedure DPC_ChangeTimedAcc_TCB
/**********************************************************************************
Описание: управление журналами проведения и погашения процентов.
Версия от 14/06/07 (27/09/05,26/11/03,20/08/03)
Автор: Алексей Коновалов
-- 09/01/2014 Панфилов М.С.
**********************************************************************************/
as
   idDoc           dt.Reference;
   idSubSystem     dt.Reference;
   idRO            dt.Reference;
   idParent        dt.Reference;
   idDocType       dt.Reference;
   idDebet         dt.Reference;
   idCredit        dt.Reference;
   id99996         dt.Reference;
   id99997         dt.Reference;
   idIntention     dt.Reference;
   nDebAmount      DT.Amount;
   nCredAmount     DT.Amount;
   n99996Amount    DT.Amount;
   n99997Amount    DT.Amount;
   dtOper          DATE;
   sLabel          DT.Label;
   sDesc           DT.Description;

   idSchema        DT.Reference;
   nLink2SumTo     DT.Status;
   nIsSpecial      DT.Status;
   idCurrFrom      DT.Reference;
   idCurrTo        DT.Reference;
   nRate           DT.Relation;
   nTrueRate       DT.Relation;
   nBaseCurr       DT.Reference;
   nQuoteCurr      DT.Reference;
   nBaseMult       DT.Quantity;

   sParam          DT.LongText;
   sOut            DT.LongText;
   idaMessage      DT.ClassType;                           -- массив операций
   dtaDate         DT.DateType;                            -- массив дат

begin
 select d.Parent, d.DocType, d.OperDate, d.GenIntention, b.Account, b.SumAccount, p.Account, p.Amount, d.SubSystem, b.RO, d.Label, d.Description
 into idParent, idDocType, dtOper, idIntention, idDebet, nDebAmount, idCredit, nCredAmount, idSubSystem, idRO, sLabel, sDesc
  from DocTree d, BankOper b, PrepareMoney p
  where p.Doc = d.Classified and b.Doc = d.Classified and d.Classified = Context.CurrentDoc;
 if substr(acccode(idDebet),3,1) != '9' then -- 10/01/2014 Панфилов М.С.
  raise_application_error(-20000,'Сделка не короткая! ');
 end if;
 begin
  select Classified into idDebet from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idDebet),1,2)||'9'||substr(acccode(idDebet),4,5)||'_'||substr(acccode(idDebet),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по дебету! ');
 end;
  /*begin  -- 09/01/2014 Панфилов М.С.
  select Classified into idDebet from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idDebet),1,2)||'3'||substr(acccode(idDebet),4,5)||'_'||substr(acccode(idDebet),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по дебету! ');
 end;*/
 begin
  select Classified into idCredit from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idCredit),1,2)||'9'||substr(acccode(idCredit),4,5)||'_'||substr(acccode(idCredit),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по кредиту!');
 end;
 /*begin  -- 09/01/2014 Панфилов М.С.
  select Classified into idCredit from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idCredit),1,2)||'3'||substr(acccode(idCredit),4,5)||'_'||substr(acccode(idCredit),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по кредиту!');
 end;*/
 
 if substr(acccode(idDebet),2,1) = '3' then -- 09/01/2014 Панфилов М.С.
 begin
  select Classified into id99996 from Account
   where SysFilial = c_access.getfilial and Code like '99996810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99996*!');
 end;
 begin
  select Classified into id99997 from Account
   where SysFilial = c_access.getfilial and Code like '99997810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99997*!');
 end;
 else
 begin
  select Classified into id99997 from Account
   where SysFilial = c_access.getfilial and Code like '99996810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99996*!');
 end;
 begin
  select Classified into id99996 from Account
   where SysFilial = c_access.getfilial and Code like '99997810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99997*!');
 end;   
 end if;
 
 
 s.setoperdate(dtOper);
 idCurrFrom := AccountCurrency(idDebet);
 idCurrTo := AccountCurrency(idCredit);
 n99996Amount:= NULL;
 n99997Amount:= NULL;


      if idCurrFrom = pref.Currency then
         idSchema := null;
         nLink2SumTo := null;
         nRate := null;
         nBaseCurr := null;
         nQuoteCurr := null;
         nBaseMult := null;
     n99997Amount := nDebAmount;
                        --raise_application_error(-20000,nDebAmount);
      else
         select min(ConvVariant) into idSchema from DocTypeConversion
          where DocType = idDocType and SysFilial = c_access.GetFilial and IsDefault = 1;
         if idSchema is null then
            raise_application_error(-20000,'Не найдена схема конверсии для типа документа "'||DocTypeLabel(idDocType)||'"!');
         else

            nLink2SumTo := 0;
            if n99997Amount is null or nDebAmount is null then
               nIsSpecial := 0;

               exch_proc.CurrencyConvert(
                  idSchema, dtOper,
                  idCurrFrom, pref.Currency, nLink2SumTo,
                  nDebAmount, n99997Amount,
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult);
--          raise_application_error(-20000,n99997Amount);
               nRate := n99997Amount/nDebAmount;
            else
               nTrueRate  := null;
               nBaseCurr  := null;
               nQuoteCurr := null;
               nBaseMult  := null;
               nIsSpecial := 1;
               nRate      := n99997Amount/nDebAmount;
               exch_proc.Rate_To_TrueForm(
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult,
                  nRate, idCurrFrom, pref.Currency, idSchema);
            end if;
         end if;
      end if;
  --  raise_application_error(-20000,n99996Amount);
      idDoc := Createinternaltransfer(
            idDocType,        -- тип документа
            idIntention,   -- назначение генерации
            idParent,   -- родительский документ
            idSubSystem,      -- подсистема
            idRO,             -- Род операции
            sLabel,        -- Номер документа
            idDebet,    -- Счет дебета
            nDebAmount,         -- Сумма
            idCurrFrom,       -- Валюта платежа
            id99997,      -- Счет кредита
            n99997Amount,           -- Сумма после конверсии
            pref.Currency,         -- Валюта после конверсии
            idSchema,         -- Схема конверсии
            nRate,            -- курс обмена
            nBaseCurr,        -- базовая валюта
            nQuoteCurr,       -- валюта котировки
            nBaseMult,        -- множитель базовой валюты
            sDesc,            -- Назначение платежа
            dtOper, -- Дата
            0,     -- признак зак. оборотов
            dtOper,      -- Дата валютирования.
            null,             -- Код назначения движения ден. средств
            null,             -- Код направления движения ден. средств
            null,             -- приоритет платежа
            false,            -- признак проверки прав
            null,     -- номер пачки
            null,             -- дата платежа
            null,             -- очередность платежа
            null,             -- RsFrom
            null,             -- RsTo
            nLink2SumTo,
            null,    -- idNotblObj
            null,    -- idDocObj
            null,    -- idDocInitObj
            null);

      -- идентификатор внешней системы
--      ObjAttrNoCheckRights.SaveOneType(idDoc, idDoc, null, nIDExtSystem, null, null, ObjAttr.TypeClass(-1));
      -- УНИК.ВНЕШ.ИДЕНТ
--      ObjAttrNoCheckRights.SaveOneDesc(idDoc, idDoc, ObjAttr.DescClass(-1), 0, sTicket);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000039;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000035;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);


      if pref.Currency = idCurrTo then
         idSchema := null;
         nLink2SumTo := null;
         nRate := null;
         nBaseCurr := null;
         nQuoteCurr := null;
         nBaseMult := null;
     n99996Amount := ncredAmount;
      else
         select min(ConvVariant) into idSchema from DocTypeConversion
          where DocType = idDocType and SysFilial = c_access.GetFilial and IsDefault = 1;
         if idSchema is null then
            raise_application_error(-20000,'Не найдена схема конверсии для типа документа "'||DocTypeLabel(idDocType)||'"!');
         else
            nLink2SumTo := 1;
            if nCredAmount is null or n99996Amount is null then
               nIsSpecial := 0;
               exch_proc.CurrencyConvert(
                  idSchema, dtOper,
                  pref.Currency, idCurrTo, nLink2SumTo,
                  n99996Amount, nCredAmount,
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult);
               nRate := nCredAmount/n99996Amount;
            else
               nTrueRate  := null;
               nBaseCurr  := null;
               nQuoteCurr := null;
               nBaseMult  := null;
               nIsSpecial := 1;
               nRate      := nCredAmount/n99996Amount;
               exch_proc.Rate_To_TrueForm(
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult,
                  nRate, pref.Currency, idCurrTo, idSchema);
            end if;
         end if;
      end if;
      idDoc := Createinternaltransfer(
            idDocType,        -- тип документа
            idIntention,   -- назначение генерации
            idParent,   -- родительский документ
            idSubSystem,      -- подсистема
            idRO,             -- Род операции
            sLabel,        -- Номер документа
            id99996,    -- Счет дебета
            n99996Amount,         -- Сумма
            pref.Currency,       -- Валюта платежа
            idCredit,      -- Счет кредита
            nCredAmount,           -- Сумма после конверсии
            idCurrTo,         -- Валюта после конверсии
            idSchema,         -- Схема конверсии
            nRate,            -- курс обмена
            nBaseCurr,        -- базовая валюта
            nQuoteCurr,       -- валюта котировки
            nBaseMult,        -- множитель базовой валюты
            sDesc,            -- Назначение платежа
            dtOper, -- Дата
            0,     -- признак зак. оборотов
            dtOper,      -- Дата валютирования.
            null,             -- Код назначения движения ден. средств
            null,             -- Код направления движения ден. средств
            null,             -- приоритет платежа
            false,            -- признак проверки прав
            null,     -- номер пачки
            null,             -- дата платежа
            null,             -- очередность платежа
            null,             -- RsFrom
            null,             -- RsTo
            nLink2SumTo,
            null,    -- idNotblObj
            null,    -- idDocObj
            null,    -- idDocInitObj
            null);

      -- идентификатор внешней системы
--      ObjAttrNoCheckRights.SaveOneType(idDoc, idDoc, null, nIDExtSystem, null, null, ObjAttr.TypeClass(-1));
      -- УНИК.ВНЕШ.ИДЕНТ
--      ObjAttrNoCheckRights.SaveOneDesc(idDoc, idDoc, ObjAttr.DescClass(-1), 0, sTicket);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000039;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000035;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);
  sParam := Content.PackHierarchy('1',NULL);
  teller_proc.Lock_Release(Context.CurrentDoc);
  idaMessage(1) := 1000000037;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,Context.CurrentDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(Context.CurrentDoc);

end DPC_ChangeTimedAcc_TCB;



----------------------------------------------------------------------------------
--10/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

create or replace procedure DPC_L_ChangeTimedAcc_TCB
/**********************************************************************************
Описание: управление журналами проведения и погашения процентов.
Версия от 14/06/07 (27/09/05,26/11/03,20/08/03)
Автор: Алексей Коновалов
-- 10/01/2014 Панфилов М.С. (для длинных сделок 933/963)
**********************************************************************************/
as
   idDoc           dt.Reference;
   idSubSystem     dt.Reference;
   idRO            dt.Reference;
   idParent        dt.Reference;
   idDocType       dt.Reference;
   idDebet         dt.Reference;
   idCredit        dt.Reference;
   id99996         dt.Reference;
   id99997         dt.Reference;
   idIntention     dt.Reference;
   nDebAmount      DT.Amount;
   nCredAmount     DT.Amount;
   n99996Amount    DT.Amount;
   n99997Amount    DT.Amount;
   dtOper          DATE;
   sLabel          DT.Label;
   sDesc           DT.Description;

   idSchema        DT.Reference;
   nLink2SumTo     DT.Status;
   nIsSpecial      DT.Status;
   idCurrFrom      DT.Reference;
   idCurrTo        DT.Reference;
   nRate           DT.Relation;
   nTrueRate       DT.Relation;
   nBaseCurr       DT.Reference;
   nQuoteCurr      DT.Reference;
   nBaseMult       DT.Quantity;

   sParam          DT.LongText;
   sOut            DT.LongText;
   idaMessage      DT.ClassType;                           -- массив операций
   dtaDate         DT.DateType;                            -- массив дат
   
   dValidfromdate  DATE; -- 10/01/2014 Панфилов М.С.

begin
 select d.Parent, d.DocType, d.OperDate, d.GenIntention, b.Account, b.SumAccount, p.Account, p.Amount, d.SubSystem, b.RO, d.Label, d.Description, d.validfromdate
 into idParent, idDocType, dtOper, idIntention, idDebet, nDebAmount, idCredit, nCredAmount, idSubSystem, idRO, sLabel, sDesc, dValidfromdate
  from DocTree d, BankOper b, PrepareMoney p
  where p.Doc = d.Classified and b.Doc = d.Classified and d.Classified = Context.CurrentDoc;
 if substr(acccode(idDebet),3,1) != '3' then -- 10/01/2014 Панфилов М.С.
  raise_application_error(-20000,'Сделка не длинная! ');
 end if;
 /*begin
  select Classified into idDebet from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idDebet),1,2)||'9'||substr(acccode(idDebet),4,5)||'_'||substr(acccode(idDebet),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по дебету! ');
 end;*/
 begin  -- 10/01/2014 Панфилов М.С.
  select Classified into idDebet from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idDebet),1,2)||'3'||substr(acccode(idDebet),4,5)||'_'||substr(acccode(idDebet),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по дебету! ');
 end;
 /*begin
  select Classified into idCredit from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idCredit),1,2)||'9'||substr(acccode(idCredit),4,5)||'_'||substr(acccode(idCredit),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по кредиту!');
 end;*/
 begin  -- 10/01/2014 Панфилов М.С.
  select Classified into idCredit from Account
   where SysFilial = c_access.getfilial 
   and ( Code like substr(acccode(idCredit),1,2)||'3'||substr(acccode(idCredit),4,5)||'_'||substr(acccode(idCredit),10,11));
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт по кредиту!');
 end;
 
 if substr(acccode(idDebet),2,1) = '3' then -- 09/01/2014 Панфилов М.С.
 begin
  select Classified into id99996 from Account
   where SysFilial = c_access.getfilial and Code like '99996810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99996*!');
 end;
 begin
  select Classified into id99997 from Account
   where SysFilial = c_access.getfilial and Code like '99997810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99997*!');
 end;
 else
 begin
  select Classified into id99997 from Account
   where SysFilial = c_access.getfilial and Code like '99996810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99996*!');
 end;
 begin
  select Classified into id99996 from Account
   where SysFilial = c_access.getfilial and Code like '99997810%';
 exception when OTHERS then
  raise_application_error(-20000,'Невозможно определить новый счёт 99997*!');
 end;   
 end if;
 
 
 s.setoperdate(dtOper);
 idCurrFrom := AccountCurrency(idDebet);
 idCurrTo := AccountCurrency(idCredit);
 n99996Amount:= NULL;
 n99997Amount:= NULL;


      if idCurrFrom = pref.Currency then
         idSchema := null;
         nLink2SumTo := null;
         nRate := null;
         nBaseCurr := null;
         nQuoteCurr := null;
         nBaseMult := null;
     n99997Amount := nDebAmount;
                        --raise_application_error(-20000,nDebAmount);
      else
         select min(ConvVariant) into idSchema from DocTypeConversion
          where DocType = idDocType and SysFilial = c_access.GetFilial and IsDefault = 1;
         if idSchema is null then
            raise_application_error(-20000,'Не найдена схема конверсии для типа документа "'||DocTypeLabel(idDocType)||'"!');
         else

            nLink2SumTo := 0;
            if n99997Amount is null or nDebAmount is null then
               nIsSpecial := 0;

               exch_proc.CurrencyConvert(
                  idSchema, dtOper,
                  idCurrFrom, pref.Currency, nLink2SumTo,
                  nDebAmount, n99997Amount,
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult);
--          raise_application_error(-20000,n99997Amount);
               nRate := n99997Amount/nDebAmount;
            else
               nTrueRate  := null;
               nBaseCurr  := null;
               nQuoteCurr := null;
               nBaseMult  := null;
               nIsSpecial := 1;
               nRate      := n99997Amount/nDebAmount;
               exch_proc.Rate_To_TrueForm(
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult,
                  nRate, idCurrFrom, pref.Currency, idSchema);
            end if;
         end if;
      end if;
  --  raise_application_error(-20000,n99996Amount);
      idDoc := Createinternaltransfer(
            idDocType,        -- тип документа
            idIntention,   -- назначение генерации
            idParent,   -- родительский документ
            idSubSystem,      -- подсистема
            idRO,             -- Род операции
            sLabel,        -- Номер документа
            idDebet,    -- Счет дебета
            nDebAmount,         -- Сумма
            idCurrFrom,       -- Валюта платежа
            id99997,      -- Счет кредита
            n99997Amount,           -- Сумма после конверсии
            pref.Currency,         -- Валюта после конверсии
            idSchema,         -- Схема конверсии
            nRate,            -- курс обмена
            nBaseCurr,        -- базовая валюта
            nQuoteCurr,       -- валюта котировки
            nBaseMult,        -- множитель базовой валюты
            sDesc,            -- Назначение платежа
            dtOper, -- Дата
            0,     -- признак зак. оборотов
            dValidfromdate,      -- Дата валютирования.
            null,             -- Код назначения движения ден. средств
            null,             -- Код направления движения ден. средств
            null,             -- приоритет платежа
            false,            -- признак проверки прав
            null,     -- номер пачки
            dValidfromdate,             -- дата платежа
            null,             -- очередность платежа
            null,             -- RsFrom
            null,             -- RsTo
            nLink2SumTo,
            null,    -- idNotblObj
            null,    -- idDocObj
            null,    -- idDocInitObj
            null);

      -- идентификатор внешней системы
--      ObjAttrNoCheckRights.SaveOneType(idDoc, idDoc, null, nIDExtSystem, null, null, ObjAttr.TypeClass(-1));
      -- УНИК.ВНЕШ.ИДЕНТ
--      ObjAttrNoCheckRights.SaveOneDesc(idDoc, idDoc, ObjAttr.DescClass(-1), 0, sTicket);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000039;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000035;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);


      if pref.Currency = idCurrTo then
         idSchema := null;
         nLink2SumTo := null;
         nRate := null;
         nBaseCurr := null;
         nQuoteCurr := null;
         nBaseMult := null;
     n99996Amount := ncredAmount;
      else
         select min(ConvVariant) into idSchema from DocTypeConversion
          where DocType = idDocType and SysFilial = c_access.GetFilial and IsDefault = 1;
         if idSchema is null then
            raise_application_error(-20000,'Не найдена схема конверсии для типа документа "'||DocTypeLabel(idDocType)||'"!');
         else
            nLink2SumTo := 1;
            if nCredAmount is null or n99996Amount is null then
               nIsSpecial := 0;
               exch_proc.CurrencyConvert(
                  idSchema, dtOper,
                  pref.Currency, idCurrTo, nLink2SumTo,
                  n99996Amount, nCredAmount,
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult);
               nRate := nCredAmount/n99996Amount;
            else
               nTrueRate  := null;
               nBaseCurr  := null;
               nQuoteCurr := null;
               nBaseMult  := null;
               nIsSpecial := 1;
               nRate      := nCredAmount/n99996Amount;
               exch_proc.Rate_To_TrueForm(
                  nTrueRate, nBaseCurr, nQuoteCurr, nBaseMult,
                  nRate, pref.Currency, idCurrTo, idSchema);
            end if;
         end if;
      end if;
      idDoc := Createinternaltransfer(
            idDocType,        -- тип документа
            idIntention,   -- назначение генерации
            idParent,   -- родительский документ
            idSubSystem,      -- подсистема
            idRO,             -- Род операции
            sLabel,        -- Номер документа
            id99996,    -- Счет дебета
            n99996Amount,         -- Сумма
            pref.Currency,       -- Валюта платежа
            idCredit,      -- Счет кредита
            nCredAmount,           -- Сумма после конверсии
            idCurrTo,         -- Валюта после конверсии
            idSchema,         -- Схема конверсии
            nRate,            -- курс обмена
            nBaseCurr,        -- базовая валюта
            nQuoteCurr,       -- валюта котировки
            nBaseMult,        -- множитель базовой валюты
            sDesc,            -- Назначение платежа
            dtOper, -- Дата
            0,     -- признак зак. оборотов
            dValidfromdate,      -- Дата валютирования.
            null,             -- Код назначения движения ден. средств
            null,             -- Код направления движения ден. средств
            null,             -- приоритет платежа
            false,            -- признак проверки прав
            null,     -- номер пачки
            dValidfromdate,             -- дата платежа
            null,             -- очередность платежа
            null,             -- RsFrom
            null,             -- RsTo
            nLink2SumTo,
            null,    -- idNotblObj
            null,    -- idDocObj
            null,    -- idDocInitObj
            null);

      -- идентификатор внешней системы
--      ObjAttrNoCheckRights.SaveOneType(idDoc, idDoc, null, nIDExtSystem, null, null, ObjAttr.TypeClass(-1));
      -- УНИК.ВНЕШ.ИДЕНТ
--      ObjAttrNoCheckRights.SaveOneDesc(idDoc, idDoc, ObjAttr.DescClass(-1), 0, sTicket);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000039;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);
  sParam := Content.PackHierarchy('1',NULL);
  idaMessage(1) := 1000000035;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,idDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(idDoc);
  sParam := Content.PackHierarchy('1',NULL);
  teller_proc.Lock_Release(Context.CurrentDoc);
  idaMessage(1) := 1000000037;
  dtaDate(1) := dtOper;
  UserMessage.DTMOperMain(sOut,Context.CurrentDoc,idDocType,idaMessage,dtaDate,sParam,2);
  teller_proc.Lock_Release(Context.CurrentDoc);

end DPC_L_ChangeTimedAcc_TCB;


-- правил для Филимоновой BBR_TCB_BILLOWN_INSURANCE (добавил векселя "в залоге")                                                                                  ++
select substr('96999',2,1) from dual

 select
      c.label
      ,b.drawdate
      ,b.billsum
      ,currencyiso(b.billcurrency)
      ,br.rowprice
      ,case 
          when b.paydatevar=1 and b.date2 is not null then 'по предъявл, между '||to_char(b.date1,'dd.mm.yyyy')||' e '||to_char(b.date2,'dd.mm.yyyy')
          
          when b.paydatevar=1 and b.date1 is not null then 'по предъявл, но не раньше '||to_char(b.date1,'dd.mm.yyyy')
          when b.paydatevar=1 and b.date1 is null then 'по предъявлении'
          when b.paydatevar=4                         then to_char(b.date1,'dd.mm.yyyy')
          else ''
       end 
      ,case
                        when b.repaydate is not null                                  then b.repaydate
                        WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL                 then b.date2
                        WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL                 then b.date1
                        WHEN b.paydatevar = 4                                         then b.date1
                        when b.paydatevar = 3                                         then B.DRAWDATE + b.time
                        ELSE                                                          null
       end
      ,nvl(b.percent,0)
      ,currlabel(currencynumb(b.billcurrency))
from
      bill b
      ,billstatushistory bsh
      ,billrange br
      ,doctree dt
      ,client c
      ,billoper bo
      ,billgroup bg

   
            
where
      bsh.status in (2,38)
      and bsh.startdate<= to_date('01012014','ddmmyyyy')
      and bsh.enddate> to_date('01012014','ddmmyyyy')      
      and b.classified=bsh.bill
      and dt.classified=bsh.doc
      and br.bill=b.classified
      and br.doc=dt.classified
      and bo.doc=dt.classified
      and c.classified=bo.client
      and bg.classified=b.billgroup
      and objattrnocheckrights.getoneprop(c.classified, objattr.propclass(148))=1
      
      
select * from bill where num = '0021198'

select * from bill where num = '0055555'
select * from billsum where bill = 1346493982

-- для Ярославля делал update по billsum (списание всего дисконта (216947.76), при погашении векселя )                                                            ++
select rowid, b.* from billsum b where b.bill = 1241786408
-- делал 08/04/2014 еще один аналогичный update для Ярославля по billsum, только для векселя '0021196' (списание всего дисконта (216947.76), при погашении векселя )
select rowid, b.* from billsum b where b.bill = 1241786151 216947,76

od.FUNC_BILL_OWNREPDISC
od.FUNC_BILL_OWNDISCOFF

od.FUNC_BILL_OWNDISC_DISCOFF
od.FUNC_BILL_REINC302P

select od.GetBillOwnDiscSum(1346493982,td+365) from dual

select * from filial
select * from doccategory

----------------------------------------------------------------------------------
--21/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from currency

bbr.BBR_BILL_UNIONREPORT_TCB

select * from deal where doc in (248224366, 248195475)

-- поправить косяк Бакумцевой                                                                                                                                     ++
update deal set repaydate = to_date('2014-01-09','YYYY-MM-DD') where doc in (248224366, 248195475)

----------------------------------------------------------------------------------
--22/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from desclist

select * from objdesc

select * from objtype where description = 1139657409

select * from typetree

BBR_BILL_BOOK_TCB_NEW

----------------------------------------------------------------------------------
--23/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проапдейтить для Бахавчука статусы по некорректнозаведенным векселям ПМЗ в Москве (82 штуки) IPI 173020                                                       ++

select * from bill where payee = 70286037 and sysfilial = 1 and maker = 1

update bill set status = 4 where payee = 70286037 and sysfilial = 1 and maker = 1

select * from billstatushistory where bill in (
select classified from bill where payee = 70286037 and sysfilial = 1 and maker = 1
)

update billstatushistory set status = 4 where bill in (
select classified from bill where payee = 70286037 and sysfilial = 1 and maker = 1
) and status = 2

-- проапдейтить для Бахавчука статусы по некорректнозаведенным векселям "ФИЛИАЛ ОАО КБ МИХАЙЛОВСКИЙ ПЖ" в Москве (1 штука)                                       ++

select * from bill where num = '0021042'

update bill set status = 4 where classified = 1172096586

select * from billstatushistory where bill in (
select classified from bill where classified = 1172096586
)

update billstatushistory set status = 4 where bill in (
select classified from bill where classified = 1172096586
) and status = 2

-- удалял векселя в статусе "создан" по просьбе Бахавчука (5 штук)                                                                                               ++

update doctree set parent = null where classified = 143506906

select * from billoper where bill = 1184882200
select * from billrange where bill = 1184882200
select * from doctree where classified = 186522449
select * from doctype where classified = 1098095502

select * from bill where num = '0023707'



-- добавить в BBR_BILL_OWN_OUTSTAND_15 колонку "статус векселя" по просьбе Бахавчука

select * from bill where status in (2,34,38) and classified not in (
select bi.classified
  from account a, BillAccount ba, Balance b,
       Bill bi, /*Client c,*/ BillRange br, DocTree dtr,
       Currency cu, BillAccIntention bai
  where ba.account = a.CLASSIFIED
    and bai.CONSTINTENTION in (12, 23)
    and ba.ACCINTENTION = bai.CLASSIFIED
    and cu.CLASSIFIED = bi.BILLCURRENCY
    and ba.BILL = bi.CLASSIFIED
	and bi.maker = 1  --2089057 
    and b.ACCOUNT = a.CLASSIFIED
	and trim(b.BEGDATE) < td
	and trim(b.ENDDATE) >= td
	and b.TYPE = 5
	and abs(b.AMOUNT) > 0
        and b.endturn = 0
	/*and c.CLASSIFIED(+) = bi.PAYEE*/
	and br.BILL = bi.CLASSIFIED
	and br.DOC  = dtr.CLASSIFIED
	and dtr.CATEGORY = 702
        and dtr.DocState = 1000000035
    and dtr.OPERDATE = (
      select max(dtr1.OPERDATE) 
	    from doctree dtr1, billRange br1
		where   br1.BILL = bi.CLASSIFIED --1039537423
  		  and dtr1.CLASSIFIED = br1.doc
                  and dtr1.DocState = 1000000035
  		  and dtr1.CATEGORY  = 702)
    and Not Exists (
	  select br2.bill from DocTree dt1, BillRange br2
	    where br2.BILL = bi.CLASSIFIED
		  and dt1.CLASSIFIED = 	br2.DOC
                  --and trim(dt1.VALIDFROMDATE) <= TO_DATE ('20120401', 'yyyymmdd')        -- 05/04/2012 Панфилов М.С.
                  and dt1.DocState = 1000000035
		  and dt1.CATEGORY = 703) )
order by 2, 11, 5

----------------------------------------------------------------------------------
--27/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.CMP_TermDealConvAcc

 INSERT INTO ConvVariant( Classified, sysfilial, ConvType, Label, Code, Description, Category, ValidFrom, HideConvAcc, DealRate, NBRateType )
 VALUES( 1320119092, 1, 3 , 'КР Для валютного дилинга (FX long)', 'DealFXLong', NULL,
    2, TO_DATE( '2014-01-02-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' ), -1, 0, 0 )



select rowid, c.* from ConvVariant c

select * from NationEquivType


select * from account where code = '52601810450002401202'

-------------------------------------------------
-- сделал счета 52601/52602 обратно нереестровыми
-------------------------------------------------
select rowid, a.* from account a where classified in (
248294505,
248294506)

select * from accountwithreestr a where account in (
248294505,
248294506)

select * from reestrdoc where accountwithreestr in
(
1320502117,
1320502125
)
select * from reestr where accountwithreestr in
(
1320502117,
1320502125
)

delete from accountwithreestr a where account in (
248294505,
248294506)

delete from reestrdoc where accountwithreestr in
(
1320502117,
1320502125
)
delete from reestr where accountwithreestr in
(
1320502117,
1320502125
)
-------------------------------------------------
-------------------------------------------------


----------------------------------------------------------------------------------
--28/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

 select * from od.dealaccintention where
            classified in (1000105419,1000105419,1000105440,1000105441,1000105425,1000105425,1000105424,1000105424,1000105427,1000105426,1000105418)

-- для Бахавчука/Герасимовой делал update по billsum (по процентам, при досрочном погашении векселя)                                                              ++
select rowid, b.* from billsum b where b.bill = 1204599140
select rowid, b.* from billsum b where b.bill = 1204648600

select * from bill where num in ('0023937','0023938')

od.FUNC_BILL_ACCRUALRETURN_TL_TCB
select BillDPPercentSum_TCB(1204648600, TO_DATE( '2013-12-31', 'YYYY-MM-DD' ),8) from dual
select 1193150.68 - 954520.55 from dual
select 1189589.04 - 951671.23 from dual

od.DPC_BillSumCorrection_TCB
od.DPC_BillSumCorrectionDisc_TCB

select * from dual

----------------------------------------------------------------------------------
--29/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- менял для Епановой первого векселедержателя на "ПМЗ"                                                                                                           ++
select * from bill where num = '0030291'
update bill set payee = 70286037 where classified = 1256894724

-- привязывал счета 52601/52602 70613/70614 для Ледовской/Прозоровой
select * from deal where doc = 247539955 -- ++

select * from dealaccount where doc = 247539955

select rowid, da.* from dealaccount da where doc = 247539955

select rowid, da.* from dealaccount da where accintention in (1156809334, 1156809332)
select rowid, da.* from dealaccount da where accintention in (1156809338, 1156809336)

select * from dealaccintention where classified in  (1156809338, 1156809336, 1156809334, 1156809332)

select * from deal where doc = 248483987 -- ++

select * from deal where doc = 248678766 -- ++

248 678 766

select * from deal where doc = 246887728

select * from deal d where (d.valuedate - d.dealdate) > 2 and d.valuedate > to_date('01012014','ddmmyyyy') and not exists 
(
select * from dealaccount da where da.doc = d.doc and da.accintention in  (1156809338, 1156809336, 1156809334, 1156809332)
)


-- правил отчет BBR_TCB_BILLOWN_DATE_REP для Бахавчука, по IPI 173847 (менял сортировку)                                                                             ++
select * from currency

-- удалил привязку "Занесений на реестр" к родительскому документу (по просьбе Прозоровой)                                                                           ++
select rowid, d.* from doctree d where classified in (250892852,250892853)

----------------------------------------------------------------------------------
--30/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- зачищал рееестр
select * from accountwithreestr where classified = 1321995096
delete accountwithreestr where classified = 1321995096
delete from reestrdoc where accountwithreestr = 1321995096
delete from reestr where accountwithreestr = 1321995096

----------------------------------------------------------------------------------
--31/01/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

begin
  
  BBR_TCB_UNIV_RTF( ObjArrays.naObjects, 1104597150,NULL,40,255,0 );
end;

select 1500000*0.0001*((3)/365) from dual

select trunc(trunc(s.ysdate),'MM') - 1 from dual 

select * from bill where num = '0031103'
select * from billsum where bill = 1321833259
-- правил od.FUNC_BILL_ACCRUALADD_TM_TCB, Калашникова нашла ошибку                                                                                                   ++
od.FUNC_BILL_ACCRUALRETURN_TY_TCB

select * from proplist
130215

-- по задаче IPI 172605
-- проблема в BillDPPercentSum_TCB и BillDPPercentSum_TCB - поправил                                                                                                 
-- сделать новое условие для векселей "Вексель выдан по номиналу", сделать новую сумму "FUNC_Bill_AccrualAdd_TM2_TCB"                                                
-- завести проводку в схему проводок для "Досрочного погашения векселя" " Оформить" с этим условием и этой суммой                                                    
-- тестит Баховчук на athena3 => на боевую не ставим, так как задача ошибочная  
create or replace procedure DPC_BillSumCorrection_TCB
/******************************************************************************
 Изменение суммы %% по векселю (коррекция %% для досрочного выкупа по ставке досрочного погашения)
 Дата: 25/04/2013
 Автор: Панфилов М.С.
  -- 16/08/2013 Панфилов М.С. - встроил проверку, процентный вексель или нет
  -- 19/09/2013 Панфилов М.С. - поправил косяк, который нашла Епанова
******************************************************************************/
as
  psum           dt.Amount;
  pallsum        dt.Amount := 0;                -- вся сумма процентов по операции
  allsum         dt.Amount := 0;                -- вся сумма по операции
  sPerc          objdesc.desctext%type;         -- процентная ставка из доп.описания
  nPerc          billrange.percentsum%type;     -- процентная ставка из доп.описания
  nPercent       Bill.Percent%type;
  nominal        Bill.billsum%type;
begin
      -- проверяем доп.описание
      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

dbms_output.put_line('DPC_BillSumCorrection_TCB ->');

begin

  -- если доп.описание есть
  if nPerc is not null then
  for rec in (select br.*, b.billsum from BillRange br, bill b where br.Doc=CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      nPercent := 0;
      nominal := 0;
      select nvl(Percent,-1), nvl(billsum,0) into nPercent, nominal from Bill where Classified = rec.bill;
      if nPercent >= 0 or (bill_tcb.billsum(rec.bill,1) = rec.billsum) then -- 16/08/2013 Панфилов М.С. - встроил проверку, процентный вексель или нет
                                                                            -- 28/01/2014 Панфилов М.С. - добавил проверку, если вексель выдан за номинал
      -- вычислим сумму процентов по новой ставке nPerc
      dbms_output.put_line('DPC_BillSumCorrection_TCB0 <- ' || nPerc);
      psum := BillDPPercentSum_TCB(rec.bill,Context.OperDate,nPerc);
      dbms_output.put_line('DPC_BillSumCorrection_TCB00 <- ' || psum);
      update BillRange set percentsum = psum, rowprice = psum + rec.billsum where bill = rec.bill and Doc=CONTEXT.CurrentDoc; -- 19/09/2013 Панфилов М.С. - поправил косяк, который нашла Епанова
      pallsum := pallsum + psum;
      allsum := allsum + psum + rec.billsum;
      dbms_output.put_line('DPC_BillSumCorrection_TCB <- ' || psum);
      end if;
    end loop;

  update billpercent set percentsum = pallsum where doc = Context.CurrentDoc;

  update BillOper set OperSum=allsum, SumFrom=allsum, SumTo=allsum where Doc=CONTEXT.CurrentDoc;

  end if;

exception
  when others then null;
end;

end DPC_BillSumCorrection_TCB;

create or replace function BillDPPercentSum_TCB(
/******************************************************************************
 Сумма процентов по векселю на заданную дату по указанной ставке
 Дата: 25/04/2013
 Автор: Панфилов М.С.
******************************************************************************/
   nBill       DT.Reference,            -- вексель
   dtPayDate   date,                    -- дата платежа
   DPPerc      Bill.Percent%type        --  процентная ставка по векселю
) return DT.Relation as

   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;

-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
-- dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;

begin
   dbms_output.put_line('BillDPPercentSum_TCB <- ' || DPPerc);
   dt_PayDate := trunc(dtPayDate);
   select PayDateVar, BillSum, BillCurrency,
          DPPerc, decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2, DPPerc
     into nPayDateVar, nBillSum, nBillCurr,
          nPercent, dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2, nSecondRate
     from Bill
    where Classified = nBill;
    
    dbms_output.put_line('BillDPPercentSum_TCB <- dtPercentFrom = ' || dtPercentFrom || ' dtPercentTo = ' || dtPercentTo);

   --  для векселей "по предъявлению", у которых с даты составления или даты "не ранее" прошло более года
   if nPayDateVar = 1 and months_between(dtPercentTo, nvl(dtDate1, dtDrawDate)) >= 12 then
      dtPercentTo := add_months(nvl(dtDate1, dtDrawDate), 12);
   end if;


   if (nPayDateVar != 1 and nPayDateVar != 2) then
     if bill_tcb.billsum(nBill,1) != nBillSum then -- 03/02/2014 Панфилов М.С. - для векселей выданных за номинал проверку обходим
       -- у векселей не по предъявлению % не бывает 
       dbms_output.put_line('BillDPPercentSum_TCB ex <- ' || DPPerc);
       return null;
     else                                          -- 03/02/2014 Панфилов М.С. - для векселей выданных за номинал проверку обходим
       dtPercentFrom := dtDrawDate;       
     end if;
   elsif dtPercentTo <= dtPercentFrom then
      return 0;
   end if;
   
   if dtPercentFrom is null then
      return 0;
   end if;

   dtFirstRateTo := dtPercentTo;
   -- если есть вторая ставка
   if nvl(nSecondRate, 0) > 0 then
      if dtDate2 is not null and dt_PayDate > trunc(dtDate2) then
         dtFirstRateTo := dtDate2;
      end if;
      if dtDate2 is null and dtDate1 is not null and dt_PayDate > trunc(dtDate1) then
         dtFirstRateTo := dtDate1;
      end if;
   end if;
   -- Расчет суммы по первой ставке
   nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
   -- Расчет суммы по второй ставке
   if nvl(nSecondRate, 0) > 0 and dtFirstRateTo < dt_PayDate then
--      DateAddTime(dtPercentFrom, dtFirstRateTo, 1, 1);
      dtPercentFrom := dtFirstRateTo;
      nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
   end if;

   return nPercentSum;
end BillDPPercentSum_TCB;

create or replace function FUNC_Bill_AccrualAdd_TM2_TCB
/******************************************************************************
 Описание: Функция возвращает сумму процентов для доначисления по векселю ЗА ТЕКУЩИЙ МЕСЯЦ (с проверкой ставки досрочного погашения при досрочном выкупе) (на основе FUNC_Bill_AccrualAdd_TM_TCB):
           ИСПОЛЬЗОВАТЬ ТОЛЬКО ПРИ ДОСРОЧНОМ ВЫКУПЕ ВЕКСЕЛЕЙ ВЫДЕННЫХ ЗА НОМИНАЛ, КОГДА ЕСТЬ СТАВКА ДОСРОЧНОГО ПОГАШЕНИЯ
           >0 - надо доначислить проценты
 Автор: Панфилов М.С.
 Версия от: 03/02/2014
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
******************************************************************************/
return DT.Amount as
   nResSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания

   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;

-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
-- dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;

begin

   dtAccrDate := nvl(dtAccrDate, trunc(s.ysdate));

      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then

select PayDateVar, BillSum, BillCurrency,
          decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2
     into nPayDateVar, nBillSum, nBillCurr,
          dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2
     from Bill
    where Classified = bc.getbill;

    nResSum := GetAmountPercent(/*greatest(trunc(dtAccrDate,'MM')- 1,dtPercentFrom)*/dtDrawDate,dtAccrDate,nPerc);  -- 31/01/2014 Панфилов М.С. добавил сравнение с dtPercentFrom
                                                                                                                    -- 03/02/2014 Панфилов М.С. добавил сравнение с dtDrawDate
else
  nResSum := GetBillAccrualSum(bc.getbill,Context.OperDate);
end if;
dbms_output.put_line('nResSum = ' || nResSum || ' nResSum = ' || nResSum);
   -- запишем константную сумму (14) для вытаскивания в отчетах
      insert into BillSum(Bill, SumType, Doc, Amount)
         values(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nResSum);

   return nResSum;

end FUNC_Bill_AccrualAdd_TM2_TCB;







od.FUNC_BILL_ACCRUALADD_TM_TCB

select 500000*0.001*((31+3+20)/365) from dual

SPEC_setvaluedate_tcb

select * from bill where num = '0031462'
select* from billsum where bill  = 1300086342

select bill_tcb.billsum(1300086342,1) from dual

   select PayDateVar, BillSum, BillCurrency,
          13, decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, td), td), DrawDate, Date1, Date2, 13
     /*into nPayDateVar, nBillSum, nBillCurr,
          nPercent, dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2, nSecondRate*/
     from Bill where classified = 1300086342

----------------------------------------------------------------------------------
--03/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_FXDEAL_CONV 
od.FXDeal_Conv

select * from doctype where classified = 1065523598
select * from doctree where classified = 249084797


-- правил валютный учтенный вексель по просьбе Калашниковой                                                                                                       ++
select * from bill where num = '0001272'
--update bill set percentdate = to_date('03022014','ddmmyyyy') where classified = 1299656323

-- правил BBR_TCB_BILLOWN_INSURANCE для Бахавчука                                                                                                                 ++

----------------------------------------------------------------------------------
--04/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- сделать отчет для Бахавчука, по аналогии с "Гарантии/Единый отчет по распоряжениям..Гарантии.."  IPI 173600                                                    ++
-- BBR_RASPUNIONREPORTBILL_TCB => тестит Бахавчук                                                                                                                 ++
-- отразить в списке отчетов и инструкции                                                                                                                         ++
-- 07/02/2014 добавил перевод в другой банк                                                                                                                       ++ 

BBR_RASPUNIONREPORTGUAR_TCB
select * from doccategory

/*перевод в другой банк*/
select d.obj , d.classified ,  c.payaccount,  b.sumaccount,  accountcode(c.nostro),b.sumaccount, d.description , 
       d.category ,GetDocCategory(d.parent),d.Parent
from customertransfer c, doctree d, bankoper b 
where c.doc = d.classified
and b.doc=d.classified
and d.category=5
and d.sysfilial= c_access.getfilial
and c.paybank=pref.ourbank -- Успенский см IPI 26477
and d.operdate <= pEndDate
and d.operdate >= pBegdate
and d.authorid = nvl(sUserid,d.authorid)
and d.docstate not in (1000000036,1000000037)
and exists (
select 1 from docparent dp, doctree dtp
 where --dp.lev =0 and 
 dp.parent = dtp.classified
 and dtp.subsystem=7
 and dp.doc = d.classified
 and dtp.label like sLoan
)



select distinct a.classified, substr (a.code,6,3), a.code, a.label, doctreelabel(dtp.doc), 
doctreedescription(dtp.doc) , od.currencycb(a.CURRENCY), a.category , a.sortacc
from account a , docvisa dv, billaccount ba, doctree dt 

where a.category in (2,3) 
and a.doc = dv.doc
and dt.docstate = 1000000039 /*ДВР*/
and dt.operdate between pBegdate and pEnddate
and dv.userid = nvl(sUserid, dv.userid)
and dt.classified = ba.account
and a.doc=dt.classified
and dt.sysfilial= c_access.getfilial
--and a.code  not like '91414%'
--and (nLoan=0 or doctreelabel(dtp.doc) like sLoan) -- не задано или найдено





/*Резервирование*/
select d.obj , d.classified , od.accountcode(b.account), b.sumaccount, od.accountcode (p.account), p.amount, d.description , d.category,GetDocCategory(d.parent),d.Parent
from bankoper b, preparemoney p, doctree d
where
d.doctype in (select classified from doctype
                  where category=5)
and d.sysfilial= c_access.getfilial
--and d.sysfilial= 1
and d.operdate >= pBegdate
and d.operdate <= pEndDate
and p.doc=b.doc
and d.classified=b.doc
and d.authorid = nvl(sUserid,d.authorid)
and (sLoan is null or trim(sLoan)='%' or 
     (exists (select 1 from ReservElement re,ReservOperAccount roa
     where re.classified = roa.ReservElement
           and roa.account = p.account and roa.ConstIntention = 5
           and doctreelabel(parentdoc(doc)) like sLoan))
    )
--and (select doctreelabel(parentdoc(doc)) from ReservElement where classified = 
--    (select ReservElement from ReservOperAccount roa where roa.account = p.account and roa.ConstIntention = 5 and rownum < 2))
--    like sLoan
and d.docstate not in (1000000036,1000000037)
and exists (
select 1 from  doctree dtp,reservelement re
 where dtp.category =86 
  and dtp.obj = re.classified
  and re.code like '91315%'
  and dtp.classified=d.parent 
)
union 
/*перевод в другой банк*/
select d.obj , d.classified ,  c.payaccount,  b.sumaccount,  accountcode(c.nostro),b.sumaccount, d.description , 
       d.category ,GetDocCategory(d.parent),d.Parent
from customertransfer c, doctree d, bankoper b 
where c.doc = d.classified
and b.doc=d.classified
and d.category=5
and d.sysfilial= c_access.getfilial
and c.paybank=pref.ourbank -- Успенский см IPI 26477
and d.operdate <= pEndDate
and d.operdate >= pBegdate
and d.authorid = nvl(sUserid,d.authorid)
and d.docstate not in (1000000036,1000000037)
and exists (
select 1 from docparent dp, doctree dtp
 where --dp.lev =0 and 
 dp.parent = dtp.classified
 and dtp.subsystem=26
 and dp.doc = d.classified
 and dtp.label like sLoan
)

/*внебалансовый перевод*/
union 
select dt.obj , dt.classified , od.accountcode (b.account), b.sumaccount , od.accountcode(p.account), p.amount ,dt.description , 
       dt.category,GetDocCategory(dt.parent),dt.Parent
from doctree dt, bankoper b, preparemoney p
where dt.classified=b.doc
and b.doc =p.doc
and dt.sysfilial=c_access.getfilial
and dt.category =68
and dt.authorid = nvl(sUserid,dt.authorid)
and dt.operdate >= pBegdate
and dt.operdate <= pEndDate
and dt.docstate not in (1000000036,1000000037)
and exists (
select 1 from docparent dp, doctree dtp
 where dp.lev =0 and 
 dp.parent = dtp.classified
 and dtp.subsystem=26
 and dp.doc = dt.classified
 and dtp.category=2601
 and dtp.label like sLoan
)
union 
/*внебалансовый дебет*/
select dt.obj , dt.classified, od.accountcode (b.account) , b.sumaccount, od.accountcode(od.GetAccount99999( b.account, dt.OperDate)), 0, dt.description ,
       dt.category,GetDocCategory(dt.parent),dt.Parent  
from bankoper b, doctree dt
where b.doc = dt.classified 
and dt.category = 74 
and dt.authorid = nvl(sUserid,dt.authorid)
and dt.operdate >= pBegdate
and dt.operdate <= pEndDate
and exists (
select 1 from docparent dp, doctree dtp
 where --dp.lev =0 and 
 dp.parent = dtp.classified
 and dtp.subsystem in (26)
 and dtp.category in (2601,101,102)--(1034265222,1034265276)  -- ipi=73548
 and dp.doc = dt.classified
 and dtp.label like sLoan
)
and dt.sysfilial=c_access.getfilial
and dt.docstate not in (1000000036,1000000037)
union 
/*внебалансовый кредит*/
select dt.obj , dt.classified , od.accountcode(od.GetAccount99999 ( b.account, dt.OperDate )), 0, od.accountcode (b.account) , b.sumaccount, dt.description ,
       dt.category  ,GetDocCategory(dt.parent),dt.Parent
from bankoper b, doctree dt
where b.doc = dt.classified 
and dt.category = 75 
and dt.authorid = nvl(sUserid,dt.authorid)
and dt.operdate >= pBegdate
and dt.operdate <= pEndDate
and dt.docstate not in (1000000036,1000000037)
and DocTreeLabel(dt.parent) like sLoan
and dt.sysfilial=c_access.getfilial
and exists (
select 1 from docparent dp, doctree dtp
 where --dp.lev =0 and 
  dp.parent = dtp.classified
 and dtp.subsystem in (26)
 and dtp.category in (2601,101,102)--(1034265222,1034265276)  -- ipi=73548 
 and dp.doc = dt.classified
 )


-- отчет "Ежедневный отчет по сделкам валютный своп для отчета в репозитарий НРД" для Бакумецевой по задаче IPI 174538 => тестят                                   ++

DPGeneral.GetIntervalValue(dd.dealdate,dd.valuedate,1) > 2 

select * from client where classified = 23762560
select * from deal where doc = 246959719 
select * from doctree where classified = 246959719 
od.bus_obj
od.EditDealAccMethod
DPGeneral.GetIntervalValue(dtFxBeg, dtFXEnd, 2
select * from ClientRegionTree


SELECT DISTINCT substr(t.ticket,1,INSTR(t.ticket,'-')-1) tkt
              ,clientlabeltcb(t.counterparty) client
              ,bc.code as client_dop
              ,t.counterparty as counterparty
              ,t.dealdate
              ,t.amountb
              ,getcurrencyname(t.currencyb) currb
              ,t.valuedate
              ,t.amounts
              ,getcurrencyname(t.currencys) currs
              ,t.maturitydate
              ,t.ticket
              ,dt.label
              ,t.rate
              ,DPGeneral.GetIntervalValue(t.dealdate,t.valuedate,2,1000043360)
                   
          FROM deal t, doctree dt, bankcode bc
              
         WHERE dt.classified = t.doc
           AND t.counterparty = bc.client(+)
           AND bc.codesystem = 1000104502
           AND t.dealdate = to_date('24012014','ddmmyyyy')
           AND t.counterparty <> 23762560   
           AND getdocstate(t.doc) <> 1000000037
           AND t.dealtype in (select classified from dealtype where consttype = 2)
           AND exists (select doc from deal dd where substr(t.ticket,1,INSTR(t.ticket,'-')-1) = substr(dd.ticket,1,INSTR(dd.ticket,'-')-1)
                                           and t.dealdate = dd.dealdate      
                                           and DPGeneral.GetIntervalValue(dd.dealdate,dd.valuedate,2,1000043360/*1000131227*/) > 2 
                       )



----------------------------------------------------------------------------------
--05/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- добавил в отчет "Журнал сделок по векселям (ТКБ)" BBR_BILL_BOOK_TCB_NEW параметр "Контрагент - только физ.лицо" по задаче IPI 172830 => закрыть задачу         ++
bbr.BBR_BILL_BOOK_TCB_NEW
od.GetClientIsPhys
select * from client where classified = 65184883
   select CT.* from Client C, ClientType CT
   where C.Classified = nvl(65184883, 0) and CT.Classified = C.Type
select * from ClientType

select * from doctype where classified = 1000133080

-- изменял первого векселедержателя на "Велес-Капитал" по просьбе Герасимовой
select * from bill where num = '0023940' 
update bill set payee = 135107142 where classified = 1205821668   --141470547

select * from bill where classified = 1205821668


bbr.BBR_TCB_UNIV_RTF

create or replace procedure bbr.BBR_TCB_UNIV_RTF (
   naDoc in DT.ClassType,
   nRTF in NUMBER,
   idClient in NUMBER,
   PageSize in dt.ConstValue default 40,
   nStrata in dt.ConstValue default 255,
   SysMode in dt.ConstValue default 0
)
as
   sRTF VARCHAR2(4000);
   saDoc VARCHAR2(4000);
   sInn VARCHAR2(4000);
   sBankAddress VARCHAR2(4000);
   sBBR VARCHAR2(4000);
   i1 NUMBER;
   sBBR1 VARCHAR2(4000);
   nOurBank NUMBER;
   sDovNumber VARCHAR2(4000);
   sBBR2 VARCHAR2(4000);
   sClientINN VARCHAR2(4000);
   sDocNumber VARCHAR2(4000);
   dtDateDoc DATE;
   sOperCurr VARCHAR2(4000);
   nCurrency NUMBER;
   nDocSum NUMBER;
   sBik VARCHAR2(4000);
   sDolzhnost VARCHAR2(4000);
   dtDovDate DATE;
   sDocLabel VARCHAR2(4000);
   sBankNostroAcc VARCHAR2(4000);
   sKPP VARCHAR2(4000);
   sDolzhnostKr VARCHAR2(4000);
   sClientKPP VARCHAR2(4000);
   nAllBillPrice NUMBER;
   sAccCli VARCHAR2(4000);
   sKsCli VARCHAR2(4000);
   sBikCli VARCHAR2(4000);
   sBankCli VARCHAR2(4000);
   sUser VARCHAR2(4000);
   sFioLabel VARCHAR2(4000);
   sCliLico VARCHAR2(4000);
   sCliOsnov VARCHAR2(4000);
   sCliDolg VARCHAR2(4000);
   sCliFio VARCHAR2(4000);
   nAllBillSum NUMBER;
   sDateDoc VARCHAR2(4000);
   sBankLabel VARCHAR2(4000);
   sOrganization VARCHAR2(4000);
   nBlank NUMBER;
   sClientAddress VARCHAR2(4000);
   sFio VARCHAR2(4000);
   
   saDoc2 VARCHAR2(4000); -- 05/02/2014 Панфилов М.С. (добавил, чтобы не появлялась ORA-06502, когда много документов)
   saDoc3 VARCHAR2(4000); -- 05/02/2014 Панфилов М.С. (добавил, чтобы не появлялась ORA-06502, когда много документов)
begin
   report.enable_level( 'Универсальный отчёт для RTF-шаблона', 'BBR_TCB_UNIV_RTF', Chr(SysMode), ' ', PageSize, 80,'B1011 1 0  ', '0');
   report.SetRepParamText( substr('naDoc = '||'<Array>'||chr(13)||chr(10)||'nRTF = '||to_char(nRTF)||chr(13)||chr(10)||'idClient = '||to_char(idClient), 1, 2000));
   select FileName, BBRNames into sRTF, sBBR from TCB_Univ_Report where Classified = nRTF;
   i1:= naDoc.First;
   --saDoc := naDoc(i1);
   saDoc := 'na('||i1||'):='||naDoc(i1)||'; ';
   i1:= naDoc.Next(i1);
   while i1 <= naDoc.Last loop
   -- saDoc := saDoc||','||naDoc(i1);
   if length(saDoc) < 3950 then
    saDoc := saDoc||'na('||i1||'):='||naDoc(i1)||'; ';
   else
     if length(saDoc2) < 3950 then
       saDoc2 := saDoc2||'na('||i1||'):='||naDoc(i1)||'; '; 
     else
       saDoc3 := saDoc3||'na('||i1||'):='||naDoc(i1)||'; '; 
     end if;  
   end if;
    i1:= naDoc.Next(i1);
   end loop;
   sBBR2 := sBBR;
   while sBBR2 IS NOT NULL loop
    i1 := instr(sBBR2, ' ');
    if i1 < 1 then
     sBBR1 := sBBR2;
     sBBR2 := NULL;
    else
     sBBR1 := substr(sBBR2, 1, i1-1);
     sBBR2 := substr(sBBR2, i1+1);
    end if;
   --raise_application_error(-20000,'begin '||sBBR1||'(DT.ClassType('||saDoc||'),'||nvl(to_char(idClient),'NULL')||',999,255,0 ); end;');
   -- execute immediate 'begin '||sBBR1||'(DT.ClassType('||saDoc||'),'||nvl(to_char(idClient),'NULL')||',999,255,0 ); end;';
   --raise_application_error(-20000,'declare na DT.ClassType; begin '||saDoc||sBBR1||'(na,'||nvl(to_char(idClient),'NULL')||',999,255,0 ); end;');
    execute immediate 'declare na DT.ClassType; begin '||saDoc||sBBR1||'(na,'||nvl(to_char(idClient),'NULL')||',999,255,0 ); end;';
   end loop;
   
   i1 := instr(upper(sRTF), '.RTF');
   if i1 > 1 then sRTF := substr(sRTF, 1, i1-1); end if;
   
   report.SetSaveMode( 3 );
   report.SetFileName(sRTF||'.txt','Win без рамок');
   
   select Classified into nBlank from blanklist where filename='BBR_TCB_UNIV_RTF';
   --execute immediate 'begin TCB_SET_BLANK_UNIV_RTF('''||sRTF||''','||nBlank||'); end;';
   TCB_SET_BLANK_UNIV_RTF(sRTF,nBlank);
   --sKPP := 'begin update BlankCmd set CmdFile = ''convert1Tmp.bat '||sRTF||'.txt '||sRTF||'.rtf'' where Blank = '||nBlank||'; end;';
   SetRepBlank(nBlank);
   report.disable_level;
exception
   when others then
      report.disable_level(1);
      if sqlcode = -20000 then
         raise;
      else
         raise_application_error(-20000, 'Произошла нераспознаваемая ошибка (код '||sqlcode||') при получении отчета "Универсальный отчёт для RTF-шаблона" (процедура BBR_TCB_UNIV_RTF)' || Report.GetErrorActionDescr );
      end if;
end;

----------------------------------------------------------------------------------
--06/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.bc.getbillsum
-- давал права по просьбе Миши
GRANT EXECUTE ON "OD"."BC" TO "RESMAN"

select acccode(account), d.* from dealaccount d where accintention in (1000105440,1000105441) 
                              and doc in (select classified from doctree where d.doc = classified and category = 911)
                              and ((acccode(account) like '960%')or(acccode(account) like '930%'))
-- для Бакумцевой закрывал привязки счетов 930/960 к договорам в 31/12/2013 по задаче в IPI 175119 (513 штук)
update dealaccount d set enddate = to_date('31122013','ddmmyyyy') where accintention in (1000105440,1000105441) 
                              and doc in (select classified from doctree where d.doc = classified and category = 911)
                              and ((acccode(account) like '960%')or(acccode(account) like '930%'))

select * from dealaccintention where
select * from doctree where classified = 75590819
select * from doccategory where category = 911
select * from subsystem

----------------------------------------------------------------------------------
--10/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doccategory 

   begin
     select nvl(sum(bs.amount*(Rate(b.billcurrency,1000001275,1000131199,dt.OperDate))),0) --into nP2012
       from BillSum bs, doctree dt, od.bill b
      where bs.Bill=1299656323 and bs.doc=dt.classified -- and dt.OperDate <= to_date('01/02/2014','dd/mm/yyyy') /*to_date('01/01/2013','dd/mm/yyyy')/* and dt.OperDate >= dtBeg /*to_date('01/01/2012','dd/mm/yyyy')*/
        and bs.SumType in (select classified from billsumtype where consttype =29 and b.classified= bs.bill)
        ;
   exception when Others then nP2012:=0;
   end;
   begin
     select nvl(sum(bs.amount*(Rate(b.billcurrency,1000001275,pref.exchmatrix,dt.OperDate))),0) into nD2012
       from BillSum bs, doctree dt, od.bill b
      where bs.Bill=1299656323 and bs.doc=dt.classified and dt.OperDate <=to_date('01/02/2014','dd/mm/yyyy') /*to_date('01/01/2013','dd/mm/yyyy')*/ and dt.OperDate >= to_date('01/01/2014','dd/mm/yyyy')/*to_date('01/01/2012','dd/mm/yyyy')*/
        and bs.SumType in (select classified from billsumtype where consttype =30 and b.classified= bs.bill);
   exception when Others then nD2012:=0;
   end;
   
   select * from bill where num = '0001272'
   select rowid, b.* from billsum b where bill = 1299656323
   select * from preference
   select * from bill where num = '0001067'
   select * from billsum where bill = 1270696986
   
   select * from bill where num = '004949'
   select * from billsum where bill = 1202884107
   
   select * from billsumtype where classified in (1042775364,1042775365)
   select * from doctree where classified in (243526401,244660546,252013871)
   select * from doctype where classified in (243526401,244660546)
   select * from doccategory
   
   5753,420 24518,94
   
-- по питерскому векселю '0001272' заполнял в billsum суммы дисконтов и процентов 31/12/2013 и 30/01/2014                                                         ++

insert into BillSum(Bill, SumType, Doc, Amount)
         values(1299656323, 1042775364, 248137355, 188304.83);

insert into BillSum(Bill, SumType, Doc, Amount)
         values(1299656323, 1042775365, 248137355, 804547.23);
         
insert into BillSum(Bill, SumType, Doc, Amount)
         values(1299656323, 1042775364, 251535392, 284081.98);
         
insert into BillSum(Bill, SumType, Doc, Amount)
         values(1299656323, 1042775365, 251535392, 1213761.48);


od.FUNC_BILL_PERCACCR

-- правил BBR_TCB_BILL_OPER_MSK, чтобы корректно отображались операции по векселям, учтенным несколько раз => Бахавчук тестит на diling                           ++
bbr.BBR_TCB_BILL_OPER_MSK
----------------------------------------------------------------------------------
--12/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.MoveAllTimedSum2_TCB

select * from deal where 

select * from doccategory
select * from doctype where category = 70
select * from account where classified = 167692921
select * from accountwithreestr where account = /*248378838*/ 167692921
select * from reestr where accountwithreestr = /*1314723014*/ 1166912303
select * from doctree where classified in (248379387,248378903,249563560,249563557)
select * from doctype where classified in (1034077811,1000260667)
select nvl(GetDocType(249563557),1) from dual 

select dt.Classified, dt.ValidToDate
       from DocTree dt, Reestr r
      where dt.Classified = r.ReestrInit
        and r.EndDate = TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')       --  Документ не закрыт
        and r.Type = 1          --  Остаток-реальный
        and r.DocSum != 0               --  Остаток ненулевой
        and r.AccountWithReestr = 1314723014

        and dt.ValidToDate < dtValidMin;

od.GetTimedOpenByRsDoc

select rowid, t.* from TimedOperLog t where doc = 252931026

-- правил MoveAllTimedSum2_TCB по задаче IPI 175848                                                                                                                 ++
-- закрыть задачу



create or replace procedure MoveAllTimedSum2_TCB(
/**-----------------------------------------------------------------------------
   Описание: Процедура переноса сумм по цепочке срочных счетов (на основе MoveAllTimedSum2)
   Переносит сумму сделки по цепочке срочных счетов
   Автор: $Author: kve $
      (13.06.2006) исправление/доработка:
      + Восстановлена оригинальная версия, существовавшая ДО правок процедуры по доработке для BTM
   (15.06.2006) исправление/доработка:
      В курсоре curAllTimedAcc учтён филиал пользователя, который запустил процедуру.
   (19.09.2008) KVE Кругов В. Пункт №1 ИСПОЛНЕНИЯ замечания №21065:
      Добавлил в процедуру чтение ключа, значение которого показывает время операции
      в формате hh:mm:ss. Дата платежа вычисляется на основе этого значения.
   (06.03.2009) KVE Кругов В. Пункт №1 ИСПОЛНЕНИЯ замечания №25098:
      1. Дата для курсора вычислялась на 1 день больше,исправлено.
      2. Добавили обработку исключения при поиске реестра срочного счета.
   (13.03.2009) KVE Кругов В. Пункт №1 ИСПОЛНЕНИЯ замечания №25180:
      Параметр утилиты дата "до" должен включать весь день вплоть до 00:00:00 следующего дня.

   (30.06.2010) KVE Кругов В. Пункт №1 ИСПОЛНЕНИЯ замечания №30164:
      Минимальный срок для предпоследнего счета равен не 2, а 1. Исправляем инициализацию переменной nMinMoveTime.
   Версия от : 30.06.2010
   17/12/2012 Панфилов М.С. - перенос по срочным теперь делаем день в день несмотря на выходные
   12/02/2014 Панфилов М.С. (не берем переводы по срочным ц.б.)
-------------------------------------------------------------------------------*/
   dtiDateFrom       in date,                -- период переноса
   dtiDateTo         in date,                -- период переноса
   nCalcWorkDayOnly  dt.Status default 0     -- расчет срока переноса сумм вести только по рабочим дням
   )
as
   dtOperDate              date;             -- Дата в итерации цикла
   dtDateFrom              date;
   dtDateTo                date;
   idMoveDocType           dt.Reference;     -- Тип документа для общего папы
   nAccWR                  dt.Reference;     -- Счет с реестром
   nAccMinTime             dt.Counter;       -- Минимальный срок счета
   idParent                dt.Reference;     -- Общий папа для переносов
   dtAccValidMin           date;             -- Минимальный время счета для текущей даты
   nNeedCheck              dt.Status;        -- будем ли проверять даты переноса TAV
   nLastMove               dt.Status;        -- расчет срока переноса сумм вести только по рабочим дням
   dtExecDate              date;             -- обрезанная дата
   sRegKeyDate             DT.Description;   -- время операции зашитое в ключе.
   cursor curAllTimedAcc ( dtDate date, nSysFilial SysFilial.Code%type ) is
     select a.Classified
       from Account a
      where a.Type in ( select Classified
                          from AccountType
                         where Category = 66 -- Срочные счета
                           and IsNeedReestr = 1 )           -- Признак ведения реестра по счету
        and a.Opened <= dtDate
        and a.Closed  > dtDate
        and a.SysFilial = nSysFilial;

   cursor curAllSumOnAcc(nAccWR dt.Reference, dtValidMin date) is
     select dt.Classified, dt.ValidToDate
       from DocTree dt, Reestr r
      where dt.Classified = r.ReestrInit
        and r.EndDate = TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')       --  Документ не закрыт
        and r.Type = 1          --  Остаток-реальный
        and r.DocSum != 0               --  Остаток ненулевой
        and r.AccountWithReestr = nAccWR
        AND nvl(GetDocType(dt.parent),1) != 1034077811 -- 12/02/2014 Панфилов М.С. (не берем переводы по срочным ц.б.)
        and dt.ValidToDate < dtValidMin; /*в ValidToDate дата исполнения сделки*/

   nMinMoveTime dt.Quantity := 1;
   bNeedParent  boolean := true;
   idIntention  dt.Reference;
   nCount       dt.Quantity;
   sReturn      dt.LongText;     -- рeзультат выполнения операции  PostCreate
   idMessage    dt.Reference;    -- результат выполнения операции  PostCreate
begin
   -- обработка дат
   dtDateFrom := nvl(dtiDateFrom, s.ysdate);
   dtDateTo   := nvl(trunc(dtiDateTo) + 1, trunc(s.ysdate) + 1);

   -- проверка дат
   if dtDateFrom > dtDateTo then
      -- 'Дата окончания меньше даты начала!'
      tm_proc.RaiseError( 11652 );
   elsif dtDateTo > trunc(s.ysdate) + 1 then
      -- 'Дата окончания превышает дату опердня!'
      tm_proc.RaiseError( 11653 );
   end if;

   -- поиск типа по настройке порождения.
   idIntention := 38; -- Перенос документа на срочных счетах
   RKOProc.GetBirthByGenIntWithDefault( idMoveDocType, idIntention, 54, Constants.Pay_Other);

   sRegKeyDate := RKOProc.GetRegValue('\TimedOperation\TimedGeneral\TimedMoveTime','23:59:01');

   -- начинаем с даты dtDateFrom (если это выходной, то на след. рабочий день)
   -- 17/12/2012 Панфилов М.С. - перенос по срочным теперь делаем день в день несмотря на выходные
  /*if IsHoliday(dtDateFrom) = 1 then
      dtExecDate := trunc(AftWorkDay(dtDateFrom));   -- идем только по рабочим дням
   else*/
      dtExecDate := trunc(dtDateFrom);
   /*end if;*/

   -- устанавливаем дату со временем из ключа
   dtOperDate := to_date(to_char(dtExecDate,'ddmmyyyy')||sRegKeyDate,'ddmmyyyyhh24:mi:ss');

   -- читаем ключик
   begin
      nLastMove := nvl(Registry.GetValue('GeneralParam'||'\'||'BankOper'||'\'||'TimedLastMove'), 1);
   exception
      when NO_DATA_FOUND then nLastMove := 1;
   end;

   loop
      exit when dtOperDate > dtDateTo;
      bNeedParent := true;
      idParent := null;
      -- производим поиск всех срочных счетов, открытых не позднее даты dtOperDate (дата меняется в главном loop)
      for Acc in curAllTimedAcc( dtOperDate, C_Access.GetFilial ) loop
         -- Находим минимальный срок счета
         begin
            nAccMinTime := GetAccMinTime(Acc.Classified);
         exception
            when others then nAccMinTime := null;
         end;

         if nAccMinTime is not null then
            -- Находим реестр срочного счета
            begin
               select Classified into nAccWR from AccountWithReestr where Account = Acc.Classified;
            exception
               when no_data_found then
                  nAccWR := null;
            end;

            nNeedCheck := 0;
            -- сроки по рабочим дням из параметра процедуры
            if nCalcWorkDayOnly = 1 then
               dtAccValidMin := DpGeneral.AddInterval(dtOperDate, 2, nAccMinTime);
            else 
              -- 17/12/2012 Панфилов М.С. - перенос по срочным теперь делаем день в день несмотря на выходные
              -- смотрим. что впереди >=2 выходных и идет последний перенос
            /*   if nAccMinTime = nMinMoveTime and IsHoliday(dtOperDate + 1) = 1
                  and IsHoliday(dtOperDate + 2) = 1 and nLastMove = 1 then -- двигаем суммы предыдущим рабочим днем
                  dtAccValidMin := trunc(AftWorkDay(dtOperDate + 1))+ 1;
               else  -- двигаем суммы текущим OperDate или след. рабочим днем
            */      dtAccValidMin := dtOperDate + nAccMinTime;
            /*   end if; */
            end if;
            --
            -- находим все сделки, дата валютирования которых меньше, чем вычисленная дата.
            for rsDoc in curAllSumOnAcc(nAccWR, dtAccValidMin) loop
               if trunc(rsDoc.ValidToDate) != trunc(dtOperDate) or nLastMove = 1 then
                  if bNeedParent then
                     bNeedParent := false;
                     DocOpenEngine(idParent,1,idMoveDocType,null,null,null,null,null,null,null,null,dtOperDate,null,idIntention);
                     idMessage := Message.Send( sReturn, Constants.GetEntityMessage('PostCreate'), idParent, idMoveDocType, dtOperDate, null, 0);
                  end if;
                  MoveTimedSum(rsDoc.Classified, idParent, dtOperDate, nNeedCheck);
                  commit;
               end if;
            end loop;

         end if;
      end loop;

      -- исполняем родительский документ
      if idParent is not null then
         DocProcessTurbo(idParent,dtOperDate,1,null);
      end if;

      -- идем только по рабочим дням (присваиваем следующий рабочий день)
      dtExecDate := trunc(AftWorkDay(dtOperDate));

      -- добавляем время операции
      dtOperDate := to_date(to_char(dtExecDate,'ddmmyyyy')||sRegKeyDate,'ddmmyyyyhh24:mi:ss');

   end loop;
end MoveAllTimedSum2_TCB;


select * from billgroup where classified in (1066859336,1175923205)

-- проапдейтить для Бахавчука статусы по некорректнозаведенным векселям ПМЗ в Москве (68 штук)                                                                     ++
select * from bill where payee = 70286037 and sysfilial = 1 and billgroup = 1066859336 and maker = 23644

update bill set status = 4 where payee = 70286037 and sysfilial = 1 and billgroup = 1066859336 and maker = 23644

select * from billstatushistory where bill in (
select classified from bill where payee = 70286037 and sysfilial = 1 and billgroup = 1066859336 and maker = 23644
) and status = 2

update billstatushistory set status = 4 where bill in (
select classified from bill where payee = 70286037 and sysfilial = 1 and billgroup = 1066859336 and maker = 23644
) and status = 2

select * from bill where num = '0020355'

-- проапдейтить для Бахавчука статусы по некорректновыведеным из залога векселям Перми в Москве (34 штука)                                                          ++
select * from bill where sysfilial = 1 and billgroup = 1175923205 and status = 2

update bill set status = 0 where sysfilial = 1 and billgroup = 1175923205 and status = 2

select * from billstatushistory where bill in (
select classified from bill where sysfilial = 1 and billgroup = 1175923205
) and status = 2

update billstatushistory set status = 0 where bill in (
select classified from bill where sysfilial = 1 and billgroup = 1175923205
) and status = 2

-- проапдейтить для Бахавчука статусы по некорректновыведеным из залога векселям Краснодара в Москве (5 штук)                                                       ++
select * from bill where sysfilial = 1 and billgroup = 1179931977 and status = 2

update bill set status = 0 where sysfilial = 1 and billgroup = 1179931977 and status = 2

select * from billstatushistory where bill in (
select classified from bill where sysfilial = 1 and billgroup = 1179931977
) and status = 2

update billstatushistory set status = 0 where bill in (
select classified from bill where sysfilial = 1 and billgroup = 1179931977
) and status = 2

-- разрешить выбор в "выводе из залога собственных векселей" и в "выводе из залога векселей 3х лиц" ТОЛЬКО соответствующих векселей                                 ++
-- написать процедуры dpc_bill_checkown_tcb и dpc_bill_checknotown_tcb и навесить их на сохранение "вывода из залога собственных векселей" и 
-- "вывода из залога векселей 3х лиц" соответственно                                                                                                                ++
-- перенести на боевую                                                                                                                                              ++
 
od.DPC_BillSumCorrection_TCB
od.dpc_bill_checksum_tcb
select * from bill

select * from preference

CREATE OR REPLACE PROCEDURE dpc_bill_checkown_tcb
-- 12/02/2014 Панфилов М.С. - процедура для проверки наличия в операции только собственных векселей
IS
begin  

for rec in (select br.bill, br.rowprice, b.billsum, b.sysfilial, b.maker  from billrange br, bill b where br.doc = Context.CurrentDoc and b.classified = br.bill)
loop
if rec.maker != pref.OurBank then
raise_application_error(-20000,'Операция запрещена! В операции участвуют векселя 3-х лиц!');
end if;
end loop;

end dpc_bill_checkown_tcb;

CREATE OR REPLACE PROCEDURE dpc_bill_checknotown_tcb
-- 12/02/2014 Панфилов М.С. - процедура для проверки наличия в операции только векселей 3-х лиц
IS
begin  

for rec in (select br.bill, br.rowprice, b.billsum, b.sysfilial, b.maker  from billrange br, bill b where br.doc = Context.CurrentDoc and b.classified = br.bill)
loop
if rec.maker = pref.OurBank then
raise_application_error(-20000,'Операция запрещена! В операции участвуют собственные векселя!');
end if;
end loop;

end dpc_bill_checknotown_tcb;



BBR_TCB_BILLINFO

----------------------------------------------------------------------------------
--13/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

BBR_TCB_BILLDISC_MFSO_LIST
-- правил отчет МСФО. Учтенные векселя для Бахавчука bbr.BBR_TCB_BILLDISC_MFSO_LIST (добавлял параметр «Филиал (пусто – все)» )                                   ++

SELECT distinct accountcode(ba.account)
      ,b.series    
	,e.label  
	,b.num 
	,b.percent --,round(nvl(b.percent,(1-(br.rowprice/b.billsum))*366/(nvl(b.repaydate,b.date1)-bsh.startdate)*100),2)
	,bsh.startdate --,sysdate  
	,b.drawdate
	,nvl(b.repaydate,b.date1)
        ,nvl(b.repaydate,b.date1)
	,b.billsum
	,br.rowprice 
	,decode(b.maker,bo.client,'у эмитента', 'у третьей стороны')
	,0 --,nvl(r.riskgroup,0)
	,0 --,od.GetBillReserveSum(b.classified,dtDate) 
        ,br.rowprice
        ,b.billcurrency
			
  FROM bill              b
       JOIN billstatushistory bsh ON b.classified = bsh.bill 
			         AND (bsh.startdate) <= td - 30
				 AND (bsh.enddate) > td - 30
				 AND bsh.status = 6
       JOIN billrange br ON br.bill = bsh.bill
       JOIN billoper bo ON bo.doc = br.doc
		       AND bo.doc = bsh.doc
       JOIN client c ON bo.client = c.classified
       JOIN client e ON b.maker=e.classified											
       JOIN doctree dt ON bo.doc = dt.classified
       JOIN billrepayinterval bi ON bi.bill=b.classified												 
	                        AND bi.begdate<= td - 30
				AND bi.enddate > td - 30   
       LEFT JOIN billaccount ba ON (ba.bill = b.classified OR ba.billgroup = b.billgroup) 
			       AND bi.repayinterval=ba.repayinterval
			       AND ba.accintention = 1011996332		
       LEFT JOIN billriskgroup r ON (r.bill = b.classified OR r.billgroup = b.billgroup)
            and r.enddate = max_date 										 														
 -- WHERE (nFilial is null or b.sysfilial=nFilial) -- 13/02/2014 добавил Панфилов М.С. по просьбе Бахавчука
 ORDER BY 1
         ,3
         ,2
         ,4

-- изменить условие "Наличность купили" на "Нал купили, или нал продали раньше безнала?" для привязки счетов "Требования/Обязательства банка по прочим операциям"
-- 47423/47422 к банкнотным сделкам по задаче IPI 175549 => на базе diling тестит Бакумцева                                                                       ++
-- настраивал РО и обработку дочерних под событиями банкнотных сделок по задаче IPI 175549                                                                        ++
-- 26/02/2014 необходимо настроить автоматическое исполнение событий по банкнотным сделкам, при ииполнении(при квитовке) плановых поступлений по лоросчету        ++

declare
   nAmountTypeB  number (1);
   nAmountTypeS  number (1);
   dtMaturityDate  date;
   dtValueDate     date;
begin
select AmountTypeB, AmountTypeS, MaturityDate, ValueDate
into nAmountTypeB, nAmountTypeS, dtMaturityDate, dtValueDate
from deal 
where doc=Context.CurrentDoc;
--Если куплена наличность:
  if nAmountTypeB = 1 then 
    :nCondResult := 1;--надо брать по покупке
  else --если продана наличность:
    if  dtMaturityDate < dtValueDate then
      :nCondResult := 1;--надо брать по покупке
    else
      :nCondResult := 0;--надо брать по продаже
  end if;
end;

select * from deal


od.getbillaccount
od.getbillac
select * from billaccintention

----------------------------------------------------------------------------------
--14/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

bbr.Bbr_Tcb_Univ_Rtf


select * from balance where account = (select classified from account where code = '31409840400000000084')

od.FUNC_BILL_ACCRUALRETURN_TY_TCB
od.FUNC_BILL_ACCRUALRETURN_TL_TCB

select * from billsum where bill = (select classified from bill where num = '0023876')

select 3268500*0.0001*((57)/365) from dual

select 2630.14 + 6794.52 - 2623.56 + 7.67 - 6770.96 from dual

select * from billsum where bill = (select classified from bill where num = '0023891')
select * from bill where classified = (select classified from bill where num = '0023891')
select 1.92 - 1694.38 - 54.65 + 1698.63 + 54.79 from dual

select 500000*0.0001*((46)/365) from dual --6.3
select 500000*0.04*((46)/365) from dual   --

select 500000*0.0001*((33)/365) from dual -- 4.24
select 500000*0.04*((31)/365) from dual   -- 1698.63  1694.39
select 500000*0.0399*((31)/365) from dual   -- 1698.63  1694.39

select 500000*0.0001*((1)/365) from dual -- 0.14
select 500000*0.04*((1)/365) from dual   -- 54.79

select trunc(td,'MM') - 1 from dual
select * from billsum where bill = (select classified from bill where num = '0023876')
select * from bill where classified = (select classified from bill where num = '0023876')

select 3268500*0.0001*((58)/365) from dual -- 51.93
select 3268500*0.04*((58)/365) from dual   -- 20775.12

select 3268500*0.0001*((31+11)/365) from dual -- 27.76
select 3268500*0.04*((31)/365) from dual   -- 11103.95
select 3268500*0.0399*((31)/365) from dual -- 11076.19 

select 3268500*0.0001*((12)/365) from dual -- 10.75
select 3268500*0.04*((12)/365) from dual   -- 4298.3
select 3268500*0.0399*((12)/365) from dual -- 4287.56

-- 

-- правил функции BillDPPercentSum_TCB2 и FUNC_BILL_ACCRUALRETURN_TY_TCB из-за ошибки у Калашниковой по досрочному погашению векселей, выданных в прошлом году,
-- и у которых уже есть начисленные проценты в этом году                                                                                                          ++ 
-- протестить исправления процедур                                                                                                                                ++
-- поправить суммы в billsum по 18 векселям                                                                                                                       ++
-- 17/02/2014 добавил в FUNC_BILL_ACCRUALRETURN_TY_TCB (-1 день)                                                                                                  ++

od.FUNC_BILL_ACCRUALRETURN_TY_TCB
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023876')
0,000
4298,300
11103,950
-4287,550
12,540
-11076,190
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023877')
0,000
5036,710
13011,510
-5024,120
14,690
-12978,980
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023878')
0,000
2314,520
5979,180
-5964,230
-2308,730
6,750
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023879')
0,000
2442,740
6310,410
-2436,630
7,120
-6294,630
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023880')
0,000
1341,370
3465,210
-1338,020
3,910
-3456,550
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023881')
0,000
1933,150
4993,970
-1928,320
5,640
-4981,490
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023882')
0,000
3221,920
8323,290
-3213,870
9,400
-8302,480
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023883')
0,000
3945,210
10191,780
-10166,300
-3935,350
11,510
---+++
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023884')
0,000
3287,670
8493,150
-3279,450
9,590
-8471,920
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023885')
0,000
4602,740
11890,410
-4591,230
13,420
-11860,680
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023886')
0,000
2630,140
6794,520
-2623,560
7,670
-6777,530
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023888')
0,000
54,790
1698,630
-54,650
1,920
-1694,380
---+++
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023889')
0,000
5,750
-5083,150
-163,970
5095,890
164,380
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023890')
0,000
109,590
3397,260
-109,320
3,840
-3388,770
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023891')
0,000
54,790
1698,630
-54,650
1,920
-1694,380
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023892')
0,000
54,790
1698,630
-54,650
1,920
-1694,380
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023893')
0,000
219,180
6794,520
-218,630
7,670
-6777,530
select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023894')
0,000
109,590
3397,260
3,840
-3388,770
-109,320
---+++




create or replace function BillDPPercentSum_TCB2(
/******************************************************************************
 Сумма процентов по векселю на заданную дату по указанной ставке, с доп. параметром
 Дата: 25/04/2013
 Автор: Панфилов М.С.
 -- 14/02/2014 Панфилов М.С.
******************************************************************************/
   nBill       DT.Reference,            -- вексель
   dtPayDate   date,                    -- дата платежа
   DPPerc      Bill.Percent%type,       --  процентная ставка по векселю
   flag        DT.status default 0      --  0 - с даты выдачи векселя, 1 - с начала текущего года
) return DT.Relation as

   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;

-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
 --dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;

begin
   dt_PayDate := trunc(dtPayDate);
   select PayDateVar, BillSum, BillCurrency,
          DPPerc, decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2, DPPerc
     into nPayDateVar, nBillSum, nBillCurr,
          nPercent, dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2, nSecondRate
     from Bill
    where Classified = nBill;

   --  для векселей "по предъявлению", у которых с даты составления или даты "не ранее" прошло более года
   if nPayDateVar = 1 and months_between(dtPercentTo, nvl(dtDate1, dtDrawDate)) >= 12 then
      dtPercentTo := add_months(nvl(dtDate1, dtDrawDate), 12);
   end if;

   if nPayDateVar != 1 and nPayDateVar != 2 then
      -- у векселей не по предъявлению % не бывает
      return null;
   elsif dtPercentTo <= dtPercentFrom then
      return 0;
   end if;
   if dtPercentFrom is null then
      return 0;
   end if;

   dtFirstRateTo := dtPercentTo;
   -- если есть вторая ставка
   if nvl(nSecondRate, 0) > 0 then
      if dtDate2 is not null and dt_PayDate > trunc(dtDate2) then
         dtFirstRateTo := dtDate2;
      end if;
      if dtDate2 is null and dtDate1 is not null and dt_PayDate > trunc(dtDate1) then
         dtFirstRateTo := dtDate1;
      end if;
   end if;
   -- Расчет суммы по первой ставке
   dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtFirstRateTo,'dd.mm.yyyy'));
   dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - flag = ' || flag);
   if flag = 0 then
   nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
   else
     if dtPercentFrom < trunc(/*dtPercentFrom*/dtFirstRateTo,'YYYY') then -- 14/02/2014 Панфилов М.С.
       nPercentSum := GetAmountPercent(trunc(/*dtPercentFrom*/dtFirstRateTo,'YYYY'), dtFirstRateTo, nPercent); -- 14/02/2014 Панфилов М.С.
     else
       nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
     end if;
   end if;
   -- Расчет суммы по второй ставке
   if nvl(nSecondRate, 0) > 0 and dtFirstRateTo < dt_PayDate then
--      DateAddTime(dtPercentFrom, dtFirstRateTo, 1, 1);
      dtPercentFrom := dtFirstRateTo;
      if flag = 0 then
      nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
      else
        if dtPercentFrom < trunc(/*dtPercentFrom*/dtFirstRateTo,'YYYY') then -- 14/02/2014 Панфилов М.С.
          nPercentSum := nPercentSum + GetAmountPercent(trunc(/*dtPercentFrom*/dtFirstRateTo,'YYYY'), dt_PayDate, nSecondRate); -- 14/02/2014 Панфилов М.С.
        else
          nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
        end if;
      end if;
   end if;

   return nPercentSum;
end BillDPPercentSum_TCB2;


bbr.BBR_TCB_UNIV_RTF



-- запросы для Миши по задаче IPI 146810 с целью найти остаток на счете ОД сделки МБК (в обход реестра, по событиям)                                             

select * from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/235933617 and od.getdoccategory(/*iddeal*/235933617) = 908 and category = 905 and docstate = 1000000035)
select * from dealtraccount where doc in
(select doc from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/235933617 and od.getdoccategory(/*iddeal*/235933617) = 908 and category = 905 and docstate = 1000000035))

select * from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/236017713 and od.getdoccategory(/*iddeal*/236017713) = 908 and category = 905 and docstate = 1000000035)
select * from dealtraccount where doc in
(select doc from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/236017713 and od.getdoccategory(/*iddeal*/236017713) = 908 and category = 905 and docstate = 1000000035 and getdoctype(classified) = 1047170421))
union -- для событий замещения при пролонгациях
select * from dealtraccount where doc in
(select doc from dealtransaction where doc in (select dr.dealtransaction from doctree dt, dealrollover dr where dt.classified = dr.rollover and dr.doc = dt.parent
                                                                                and parent = /*iddeal*/236017713 and od.getdoccategory(/*iddeal*/236017713) = 908 and category = 905 and docstate = 1000000035 and getdoctype(dr.rollover) = 1047177856))
select * from dealaccintention

select * from doctype
select * from dealrollover where doc = 236017713

declare
ndoc  number;
ndeal  number;
nlevel  number;
begin
  dbms_output.put_line('1' || ' ' || '1');
for rec in (select deal from dealrollover)
  loop 
  begin   
    select doc, deal, level into ndoc, ndeal, nlevel from dealrollover connect by prior deal = doc
                                            start with doc = rec.deal;
                                            dbms_output.put_line(nlevel || ' ' || ndoc);
  exception
     when others then null;
  end;
end loop;
end;

select d1.doc, d2.doc from dealrollover d1, dealrollover d2, dealrollover d3 where d1.rollover = d2.dealtransaction and d2.rollover = d3.dealtransaction

select d1.dealtransaction, d2.rollover from dealrollover d1, dealrollover d2 where d1.dealtransaction = d2.rollover

select * from dealtraccount where doc in (235933976,236017775)
select * from dealtraccount where doc in (217619850)

select * from dealtrtype

select * from deal where doc = 236017713
select * from doctree where classified = 236017713
select * from doctree where classified = 123867551
select * from doccategory
253584211

select * from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/236017713 and category = 905 and docstate = 1000000035)
select * from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/253584211 and category = 905 and docstate = 1000000035)

select * from 


select od.parentdoc(doc), d.* from dealtransaction d where doc in (select classified from doctree dt where parent in /*iddeal*/
(253584211,
252998414,
253203178,
253688900,
253740477,
253810757,
249047439,
238518935,
238518936,
238385052,
237807200,
237232563,
236972575,
236788154,
236479519,
236288549,
236004807,
236017713)
 and category = 905 and docstate = 1000000035)
 
select * from dealtraccount where doc in
(select doc from dealtransaction where doc in (select classified from doctree where parent in
(253584211,
252998414,
253203178,
253688900,
253740477,
253810757,
249047439,
238518935,
238518936,
238385052,
237807200,
237232563,
236972575,
236788154,
236479519,
236288549,
236004807,
236017713)
 and category = 905 and docstate = 1000000035))
 
 
select sum(amount) from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/234406287 and od.getdoccategory(/*iddeal*/234406287) = 908 and category = 905 and docstate = 1000000035)
select sum(amount) from dealtraccount where doc in
(select doc from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/234406287 and od.getdoccategory(/*iddeal*/234406287) = 908 and category = 905 and docstate = 1000000035 and getdoctype(classified) = 1047170421))

select * from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/237250899 and od.getdoccategory(/*iddeal*/237250899) = 908 and category = 905 and docstate = 1000000035)
select * from dealtraccount where doc in
(select doc from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/237250899 and od.getdoccategory(/*iddeal*/237250899) = 908 and category = 905 and docstate = 1000000035 and getdoctype(classified) = 1047170421))
 
select * from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/224679515 and od.getdoccategory(/*iddeal*/224679515) = 908 and category = 905 and docstate = 1000000035)
select * from dealtraccount where doc in
(select doc from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/224679515 and od.getdoccategory(/*iddeal*/224679515) = 908 and category = 905 and docstate = 1000000035 and getdoctype(classified) = 1047170421))
  
select * from doctree where classified = 234406287
select * from doctree where classified = 237250899
select * from doctree where classified = 224679515
 
234406287                              -- EBRD - тут всё нормально, похоже было такое привлечение - из двух частей    
237250899                              -- PNC  - тут криво завели привлечение (попробую удалить первый платеж)                                                    
224679515                              -- IFCW - тут всё нормально, похоже было такое привлечение - из двух частей

select * from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/234406287 and od.getdoccategory(/*iddeal*/234406287) = 908 and category = 905 and docstate = 1000000035)
select * from dealtraccount where doc in
(select doc from dealtransaction where doc in (select classified from doctree where parent = /*iddeal*/234406287 and od.getdoccategory(/*iddeal*/234406287) = 908 and category = 905 and docstate = 1000000035))

select * from dealaccount

select y.*
  from od.dealaccount a
      ,od.deal        d
      ,od.doctype     y
where d.doc = a.doc
   and y.classified = d.dealtype


----------------------------------------------------------------------------------
--17/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------


select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023895')

select 1000000*0.0299*(8/365) from dual -- 657.53 655.34

select 1000000*0.0001*(17/365) from dual -- 2.19

od.FUNC_BILL_ACCRUALRETURN_TY_TCB
od.FUNC_BILL_ACCRUALRETURN_TL_TCB
od.DPC_BillSumCorrection_TCB

od.BillDPPercentSum_TCB


select 
ClientLabel(d.counterparty) cli,
getclientcode(d.counterparty,1000104502) code,  
acccode_tcb(da1.account) acc,
d.dealdate, 
round(d.amountb, nvl(MinorUnit(d.currencyb), 2)) summfirst,
currencyiso(d.currencyb) curr,
d.maturitydate - d.valuedate days,
dsi.ntlamount a,
(dsi.ntlamount*rate(d.currencyb,1000001275,1000131199,to_date('31/01/2014','dd/mm/yyyy')))/1000 b,
dsi.rate + nvl(dsi.spread,0) rate,
d.valuedate c,
d.maturitydate,
round(dsi.interestamount, nvl(MinorUnit(d.currencyb), 2)) d,
dspp.paydate e,
(select paydate from Dealswappayperiod where interestperiod in (select classified from DealSwapInterest where doc = d.doc and enddate = dsi.startdate)) f,
acccode_tcb(da2.account) acc2,
case
 when da2.rsaccount is null then accountbalance(da2.account,to_date('31/01/2014','dd/mm/yyyy')+1)
 when da2.rsaccount is not null then reestrrestout(da2.rsaccount,to_date('31/01/2014','dd/mm/yyyy')+1)
 else null
end as g
from dealdeposit dd, deal d, doctree dt, dealaccount da1, dealaccount da2, DealSwapInterest dsi, Dealswappayperiod dspp 
where dd.doc = dt.classified and d.doc = dt.classified and d.doc = dsi.doc and dsi.classified = dspp.interestperiod 
and da1.doc = d.doc and da2.doc = d.doc
and dd.istransh = 1 and dt.category = 908
and dt.docstate not in (1000000037) and ((d.repaydate is null) or (d.repaydate > to_date('31/01/2014','dd/mm/yyyy') ))
and da1.accintention in (1000105424)
and da2.accintention in (1000105427)
-- and ((to_date('31/01/2014','dd/mm/yyyy') > dsi.startdate)or(to_date('31/01/2014','dd/mm/yyyy') = dsi.startdate and to_date('31/01/2014','dd/mm/yyyy') = d.dealdate)) and to_date('31/01/2014','dd/mm/yyyy') <= dsi.enddate   -- 18/02/2014
and to_date('31/01/2014','dd/mm/yyyy') > dsi.startdate and to_date('31/01/2014','dd/mm/yyyy') <= dsi.enddate  -- 18/02/2014 
and d.valuedate <= to_date('31/01/2014','dd/mm/yyyy')





-- "Формирование первичных документов при проведении операций с собственными векселями." IPI 80663 и 81298                                                        
-- поправил od.getbillaccount - добавлен BillAccIntention_58 - "55.Начисленные %% по учтенному векселю (512-519)"                                                 ++
-- поправил назначение платежа в схеме проводок для "Переучета векселя" (проводки по операции оплатить) - делал ед.ч.                                             ++ 

bbr.BBR_TCB_UNIV_RTF
bbr.BBR_TCB_BILL_RASP_ALL
select * from TCB_Univ_Report
bbr.BBR_TCB_BILL_SOGL_BUY

select * from preference

select rowid, b.* from billsum b where bill = (select classified from bill where num = '0023900')

select 500000*0.0001*(17/365) from dual -- 2.19

select * from bill where num = '0020580'

----------------------------------------------------------------------------------
--18/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проблема с залогами векселей в Нижнем Новгороде IPI 176594                                                                                                    ++
-- преименовал группы векселей, завел и привязал депозитарные выпуски ц.б.

-- изменил привязку сертификатов к векселям
select * from bill where num = '0019437' and classified = 1293340956
select * from bill where num = '0019438' and classified = 1305665010
select * from bill where num = '0019439' and classified = 1328039379

update bill set syscertificate = null where classified = 1293562513
update bill set syscertificate = 1293562509 where classified = 1293340956

update bill set syscertificate = null where classified = 1306699610
update bill set syscertificate = 1306699609 where classified = 1305665010

update bill set syscertificate = null where classified = 1328196146
update bill set syscertificate = 1328196143 where classified = 1328039379
update bill set isinoper = 0 where classified = 1328039379

select * from billgroup where 1129356726

select * from billoper where bill = 1328039379
select* from doctree where classified = 253724368
select * from doctype where classified =1065524926

----------------------------------------------------------------------------------
--19/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

 SELECT Classified FROM BlankList
 WHERE Reporter = 2 AND Editable = 0 AND upper(Label) = upper('распоряжениe на списание валюты')
 
SELECT Classified, Label, FileName, DECODE( IsWork, 1, 'Да', 'Нет' )
 FROM BlankList 
 WHERE Editable = 0 AND Reporter = 2
    AND UPPER( Label ) LIKE '%РАСПОРЯЖЕНИЕ НА СПИСАНИЕ%' ESCAPE '\'  
    
    SELECT * -- Classified, Label, FileName, DECODE( IsWork, 1, 'Да', 'Нет' )
 FROM BlankList 
 WHERE Editable = 0 AND Reporter = 2 
  ORDER BY 2 ASC
  
      SELECT rowid, b.* -- Classified, Label, FileName, DECODE( IsWork, 1, 'Да', 'Нет' )
 FROM BlankList b 
 
-- сделать отчет BBR.BBR_RASP_DILING_TCB по задаче IPI 176455                                                                                                     ++ 
BBR.BBR_RASP_DILING_TCB
 
select * from account

select * from doctree where classified = 252889803
select * from doctree where classified = 252890645
select od.userpseudoname from dual
select * from bankoper where doc = 252890645

select * from doccategory

select INFOAGENTBANK from CUSTOMERISO where doc = 252890645
CUSTOMERISO.INFOAGENTBANK

BKTRUS33
select * from CUSTOMERISO where doc = 252890645
select * from client where classified = 53334

receivercode = BKTRUS33; receivercodetype = 1000004993;

select od.clientlabel(FindObjectByCode('BKTRUS33',1000004993)) from dual

od.


----------------------------------------------------------------------------------
--20/02/2014----------------------------------------------------------------------
---------------------------------------------------------------------------------- 
 
select * from doctree where classified in
(
195603649,          -- событие по сделке не исполнено, можно исполнить 30/11/2012                                                                                 ++
188542961,          -- событие по сделке не исполнено, можно исполнить 08/10/2012                                                                                 ++
166669241           -- а тут события объединяли, этот функционал используется редко. исполненное такое событие ТОЛЬКО ОДНО вот есть в апреле 2012.
                    -- если события объединяют, то нужно суммы смотреть в dealtraccount в соответствии со счетами.
)

select d.*, acccode(d.account) from dealtraccount d where doc in (
select doc from dealtransaction where doc in (select classified from doctree where parent in (
/*195603649,
188542961,
166669241,*/

226658403
)) 
)

select * from doctype where classified = 1047168347

select count(account) as c , doc from dealtraccount where doc in (select classified from doctree where doctype in (1047170421,1047177856) /*and docstate = 1000000035*/ )
 group by doc order by 1 desc, 2 desc

select parent from doctree where classified = 229290766
select * from dealtransaction where doc = 229290766
select * from doctree where classified = 229290766

select * from doctree where parent = 229290766

select d.*, acccode(d.account) from dealtraccount d  where doc = 226658403

select * from doccategory w

select * from doctype where category = 905

select * from doctype where classified = 1047170333

select * from 

-- исправлял косяки в событиях по траншам:
---- исполнил событие 225284832 по траншу МБК от 10/09/2010 с AKA на сумму 48115 EUR                                                                              ++
---- удалил задвоенные события в 29/07/2013 по сделке с COMMERZBANK AG от 11/01/2011 на сумму 127600 EUR                                                          ++
---- удалил задвоенное события в 21/11/2007 по сделке с PNC от 21/11/2007 на сумму 15000000 USD                                                                   ++
---- изменил сумму в событии в 21/11/2011 с 1363636,36 на 1363636,06 по сделке с PNC от 21/11/2007 на сумму 15000000 USD                                          ++

select 26274.1*((9+30+31+31+30+31+24)/360)*(0.00384+0.0165) from dual
select 26274.1*((9+30+31+31+30+31+24)/360)*(0.00399+0.0165) from dual

----------------------------------------------------------------------------------
--24/02/2014----------------------------------------------------------------------
---------------------------------------------------------------------------------- 

od.tcb_loan_pkg.loanProp
od.objAttrNoCheckRights

select * from dealtraccount where doc in (217619850)
update dealtraccount set account = 205867111 where doc in (217619850)

select * from 
select * from account where classified = 205867111
select * from accountwithreestr where account = 205867111

od.Spec_QuitPlanWith5Cat

od.get (FindObjectByCode

select * from codesystem 1000004993

select * from bankcode

----------------------------------------------------------------------------------
--27/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from customertransfer where doc = 255115221

select * from customertransfer where doc = 255471400
select * from customeriso where doc = 255471400

select 'SWIFT: ' || bc.code
from CUSTOMERTRANSFER c, bankcode bc where c.doc = 255471400 and c.BENEFICIARY = bc.client and bc.codesystem = 1000004993;

select b.*, length(b.code) from bankcode b where codesystem = 1000004993 and length(b.code) > 11

select * from deal where doc = 234342082

select * /*ntlamount*/ from DealSwapInterest where doc = 234342082 
and enddate = (select max(enddate) from DealSwapInterest where doc = 234342082 and startdate < to_date('01032014','ddmmyyyy'))

-- правил для Бакумцевой отчет  в RN "Отчеты - Афина - БэкОфис – Реестр сделок по привлечению МБК за период"                                                      ++
-- убрал транши, которые исполнились 

-- правил отчет BBR_BILL_OWN_OUTSTAND_15 для Бахавчука - сделал возможность его формирования по всему банку                                                       ++
select * from preference

select ourbank from preference where 2 = sysfilial

select * from preference where 2 = sysfilial

select * from sysfilial

select * from client where classified = 23644

select d.portfolio from deal d
select * from dealportfolio

bbr.BBR_TCB_BILLDISC_MFSO_LIST
bbr.BBR_BILL_OWN_OUTSTAND_15

----------------------------------------------------------------------------------
--28/02/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select 5000000*0.02*((21+31+28-2)/365) - 5753.42 - 8219.18 from dual
select 5000000*0.02*((28-3)/365) from dual --6849,31

od.FUNC_BILL_PERCACCR
od.FUNC_BILL_DISCACCR
od.FUNC_BILL_PERCUNDEF
od.FUNC_BILL_ACCRUALADD_TCB
od.FUNC_BILL_ACCRUALRETURN_TY_TCB
select * from doccategory

select * from bill where num = '0001272'

select * from billsum where bill = 1299656323
select * from billsumtype
select * from doctree where classified = 252013871

select * from dpc_billoper

-- некорректно начисляются проценты/дисконты по учтенным векселям, которые были учтены два раза.
-- пока написал свои типы сумм GetBillHoldingsPercSum_TCB и GetBillHoldingsDiscSum_TCB => написать в НА => 03/03/2014 зарегистрировали замечание 51093 =>
-- исполнять не хотят, хотят заявку на доработку => заявку писать не будем. нужно доработать механизм повторного учета векселей, чтобы не затирались старые суммы 
-- процентов и дисконтов => рещили всё-таки оставить всё как есть в стандартном Афиновском функционале (суммы по питерским векселям 0001272 и 0001067
-- до последних учетов удалил)                                                                                                                                    ++

-- нескольно раз учтенные векселя есть в Питере:
select * from bill where num = '0001272'       1299656323
select rowid, b.* from billsum b where bill = 1299656323 

select * from doctree where classified in (
259177207,
255928429,
255928429,
252013871,
251535392,
251535392,
248137355,
248137355
)

select * from bill where num = '0001067'       1270696986
select * from billsum where bill = 1270696986                                                                                                       

create or replace function GetBillHoldingsPercSum_TCB(
/*************************************************************************************
 Описание: Функция возвращает сумму процентов для доначисления по учтенному векселю (на основе GetBillHoldingsPercSum)
28/02/2014 Панфилов М.С.
**************************************************************************************/
   nBill     DT.Reference, -- вексель
   dtDate    DATE -- дата, по которую начисляем
) return DT.Amount as
   nSum      DT.Amount;
   nCount    DT.Quantity; -- количество учетов векселя
   startDate DATE;        -- дата, c которой будем смотреть суммы
   nAmount   DT.Amount := 0;    -- сумма по векселю с даты startDate
begin
   select count(doc) into nCount from billsum where sumtype = bill_p.SumTypeClassified(23) and Bill = nBill;
   if nCount > 1 or nBill = 1299656323 then
     select max(trim(operdate)) into startDate from doctree where classified in (select doc from billsum where sumtype = bill_p.SumTypeClassified(23) and Bill = nBill); 
     
     begin
        select sum(Amount) into nAmount from BillSum bs
        where Bill = nBill and sumtype = nvl( bill_p.SumTypeClassified(29),0) and doc in (select classified from doctree where bs.doc = classified and trim(operdate) >= startDate);
     exception when others then nAmount := 0;
     end;
     
     nSum := bill_p.PercentSum(nBill, dtDate) - nvl(nAmount,0);
   else
     nSum := bill_p.PercentSum(nBill, dtDate) - nvl(BC.GetBillSum(nBill, 29), 0);
   end if;
   return nSum;
end GetBillHoldingsPercSum_TCB;


create or replace function GetBillHoldingsDiscSum_TCB(
/*************************************************************************************
 Описание: Функция возвращает сумму дисконта для доначисления по учтенному векселю (на основе GetBillHoldingsDiscSum)
28/02/2014 Панфилов М.С.
**************************************************************************************/
   nBill    DT.Reference, -- вексель
   dtDate   DATE -- дата, по которую начисляем
) return DT.Amount as
   nSum     DT.Amount;
   nRedisc  DT.Status;
   nCount    DT.Quantity; -- количество учетов векселя
   startDate DATE;        -- дата, c которой будем смотреть суммы
   nAmount   DT.Amount := 0;    -- сумма по векселю с даты startDate
begin
select count(doc) into nCount from billsum where sumtype = bill_p.SumTypeClassified(23) and Bill = nBill;
if nCount > 1 or nBill = 1299656323 then
     select max(trim(operdate)) into startDate from doctree where classified in (select doc from billsum where sumtype = bill_p.SumTypeClassified(23) and Bill = nBill); 
     
     begin
        select sum(Amount) into nAmount from BillSum bs
        where Bill = nBill and sumtype = nvl( bill_p.SumTypeClassified(30),0) and doc in (select classified from doctree where bs.doc = classified and trim(operdate) >= startDate);
     exception when others then nAmount := 0;
     end;
     
     nSum := bill_p.DiscSum(nBill, dtDate, nRedisc) - nvl(nAmount,0);
else
--dbms_output.put_line('GetBillHoldingsDiscSum');
   if BC.recDoc.nCategory in (712, 714) then
      nRedisc := 1;
   end if;
   nSum := bill_p.DiscSum(nBill, dtDate, nRedisc) - nvl(BC.GetBillSum(nBill, 30), 0);
end if;

   return nSum;
end GetBillHoldingsDiscSum_TCB;


create or replace function FUNC_Bill_PercAccr_TCB
/******************************************************************************
 Описание:
   Функция возвращает сумму процентов для доначисления по учтенному векселю
   при отсутствии неопределенности в получении дохода. При этом рассчитанное
   значение записывается в BillSum с типом суммы "начисленные проценты по
   учтенному векселю", а если есть неопределенность, то также с типом суммы
   "начисленные проценты при наличии неопределенности" (на основе FUNC_Bill_PercAccr)
28/02/2014 Панфилов М.С.
******************************************************************************/
return DT.Amount as
   nSum          DT.Amount;
   dtAccrDate    date;
   dtDate        date;
   nRiskGroup    Bill.RiskGroup%type;
   nConstRG      RiskGroup.ConstRG%type;
   nRGIncUndef   DT.Status;    --  группа риска, с которой начинается неопределенность
   nIsPositive   DT.Status;
   nBill         DT.Reference;
   nDoc          DT.Reference;
   nCount        DT.Counter;
begin
   nDoc := BC.GetDoc;
   nBill := BC.GetBill;
   if BC.recDoc.nCategory = 704 then
      dtAccrDate := BC.recDoc.dtValidFromDate;
   end if;
   dtAccrDate := nvl(dtAccrDate, s.ysdate);
   nSum := nvl(GetBillHoldingsPercSum_TCB(nBill, dtAccrDate), 0);
   select IsPositive into nIsPositive from BillOperCorr where Classified = BC.nCl_BOC;
   if nSum > 0 or (nSum < 0 and nIsPositive = 0) then
      if BC.recDoc.nCategory not in (712, 714) then
         -- создание элемента резервирования при первом начислении
         select count(*) into nCount
           from BillSum
          where Bill = nBill
            and SumType in (bill_p.SumTypeClassified(29), bill_p.SumTypeClassified(30));
         if nCount = 0 then
            Dpc_Reservelementcreate(1, 0, nBill);
         end if;
      end if;

      -- сохранение общей суммы начисленных процентов
      BC.SaveBillSum(nBill, bill_p.SumTypeClassified(29), nDoc, nSum);

      --  группа риска, с которой начинается неопределенность
      nRGIncUndef := i.f(Registry.GetValue('\BILL\RiscGr3IncUndef') = 1, 3, 4);
      begin
         --  если начисления порождаются при улучшении или ухудшении категории качества, определятс
         --  предшествующая группа риска
         select EndDate into dtDate
           from DocTree DT, BillRiskGroup BRG
          where DT.Classified = nDoc and BRG.Bill = nBill and BRG.Doc = DT.Parent;
         for rec in (select RiskGroup from BillRiskGroup where Bill = nBill and EndDate < dtDate order by EndDate desc) loop
             nRiskGroup := rec.RiskGroup;
            exit;
         end loop;
      exception when no_data_found then
         --  группа риска на дату операции (при периодических начислениях и переучете)
         nRiskGroup := GetBillRiskGroup(nBill);
      end;
      if nRiskGroup is not null then
         select ConstRg into nConstRg from RiskGroup where Classified = nRiskGroup;
         nConstRG := i.f(nConstRg > 20, nConstRg - 20, nConstRg);
         -- сохранение суммы начисленных процентов при наличии неопределенности в получении дохода
         if nConstRG >= nRGIncUndef then
            BC.SaveBillSum(nBill, bill_p.SumTypeClassified(31), nDoc, nSum);
            return 0;
         end if;
      end if;
   end if;
   return nSum;
end FUNC_Bill_PercAccr_TCB;


create or replace function FUNC_Bill_DiscAccr_TCB
/******************************************************************************
 Описание:
   Функция возвращает сумму дисконта для доначисления по учтенному векселю
   при отсутствии неопределенности в получении дохода. При этом рассчитанное
   значение записывается в BillSum с типом суммы "начисленный дисконт по
   учтенному векселю", а если есть неопределенность, то также с типом суммы
   "начисленный дисконт при наличии неопределенности" (на основе FUNC_Bill_DiscAccr)
28/02/2014 Панфилов М.С.
******************************************************************************/
return DT.Amount as
   nSum        DT.Amount;
   dtAccrDate  date;
   dtDate      date;
   nRiskGroup    Bill.RiskGroup%type;
   nConstRG      RiskGroup.ConstRG%type;
   nRGIncUndef   DT.Status;    --  группа риска, с которой начинается неопределенность
   nIsPositive   DT.Status;
   nBill         DT.Reference;
   nDoc          DT.Reference;
   nCount        DT.Counter;
begin
   nDoc := BC.GetDoc;
   nBill := BC.GetBill;
   if BC.recDoc.nCategory = 704 then
      dtAccrDate := BC.recDoc.dtValidFromDate;
   end if;
   dtAccrDate := nvl(dtAccrDate, s.ysdate);
   nSum := nvl(GetBillHoldingsDiscSum_TCB(nBill, dtAccrDate), 0);
   select IsPositive into nIsPositive from BillOperCorr where Classified = BC.nCl_BOC;
   if nSum > 0 or (nSum < 0 and nIsPositive = 0) then
      if BC.recDoc.nCategory not in (712, 714) then
         -- создание элемента резервирования при первом начислении
         select count(*) into nCount
           from BillSum
          where Bill = nBill
            and SumType in (bill_p.SumTypeClassified(29), bill_p.SumTypeClassified(30));
         if nCount = 0 then
            Dpc_Reservelementcreate(1, 0, nBill);
         end if;
      end if;

      -- сохранение общей суммы начисленного дисконта
      BC.SaveBillSum(nBill, bill_p.SumTypeClassified(30), nDoc, nSum);
      --  группа риска, с которой начинается неопределенность
      nRGIncUndef := i.f(Registry.GetValue('\BILL\RiscGr3IncUndef') = 1, 3, 4);
      begin
         --  если начисления порождаются при улучшении или ухудшении категории качества, определятс
         --  предшествующая группа риска
         select EndDate into dtDate
           from DocTree DT, BillRiskGroup BRG
          where DT.Classified = nDoc and BRG.Bill = nBill and BRG.Doc = DT.Parent;
         for rec in (select RiskGroup from BillRiskGroup where Bill = nBill and EndDate < dtDate order by EndDate desc) loop
            nRiskGroup := rec.RiskGroup;
            exit;
         end loop;
      exception when no_data_found then
         --  группа риска на дату операции (при периодических начислениях и переучете)
         nRiskGroup := GetBillRiskGroup(nBill);
      end;
      if nRiskGroup is not null then
         select ConstRg into nConstRg from RiskGroup where Classified = nRiskGroup;
         nConstRG := i.f(nConstRg > 20, nConstRg - 20, nConstRg);
         -- сохранение суммы начисленного дисконта при наличии неопределенности в получении дохода
         if nConstRG >= nRGIncUndef then
            BC.SaveBillSum(nBill, bill_p.SumTypeClassified(32), nDoc, nSum);
            return 0;
         end if;
      end if;
   end if;
   return nSum;
end FUNC_Bill_DiscAccr_TCB;

----------------------------------------------------------------------------------
--03/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- сделать отчет по задаче IPI 177780 "Картотека закрытых разделов счета депо"  ??? BBR_DEPO_PARTITIONS_CL_TCB на основе BBR_DEPO_PARTITION_CARD 
-- возможно устроит древний BBR_DEPO_PARTITION_CARDINDEX => 14/03/2014 сделал на основе BBR_DEPO_PARTITION_CARDINDEX BBR_DEPO_PART_CARDINDEX_TCB                  ++
select * from depoaccount 

od.UT_DealCalcTSS_TCB --> перенести на боевую !!!!!!!!!!!!                                                                                                        ++
od.UT_DealCFVRevaluation
od.ClsPairFolding_52601_70613_TCB
od.FoldPairTotal_52601_70613_TCB --> перенести на боевую !!!!!!!!!!!!!!!!!!!!!                                                                                    ++
od.ClsPairFolding

select * from doctype where 

select a.Classified aAccount,
          nvl(AccRest(a.Classified,td,1,0),0) Sa,
          GetObjProp(a.Classified, PropClass(49), td ) Wa,
          a.PairAccount pAccount,
          nvl(AccRest(a.PairAccount,td,1,0),0) Sp,
          GetObjProp(a.PairAccount, PropClass(49), td ) Wp
     from Account a
    where a.SysFilial = 1
      and a.PairAccount is not null
      and a.Opened <= td
      and a.Closed = TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')
      and a.IsActiveInReport =1
	  and ((substr(a.CODE,1,5) = '52601') or (substr(a.CODE,1,5) = '70613'))
      and ( 0 = 0 or 0 = 1 and a.Category != 66 or
            0 = 2 and a.Category = 66)

select * from docstate
select * from doccategory

select * from proplist
GetObjProp(a.Classified, nProp, dtDate )

----------------------------------------------------------------------------------
--04/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from client

od.GetBillHoldingsPercSum 

select * from balance where account = (select classified from account where code = '52601810250000001299')

od.dpc_billoper
select * from doccategory


select * from balance where account = (select classified from account where code = '52602810550000001299')

----------------------------------------------------------------------------------
--06/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billsumtype
select * from billsum where bill in (select classified from bill where num = '0001272')

od.GetBillHoldingsPercSum

select * from od.bill where accrualmethod is not null

BBR_DOC_SWIFT
BBR.BBR_NEWSWIFT_FORM
BBR.BBR_NEWSWIFT_FORM_MT202

od.dpc_tcb_dealswift_mt399
od.DPC_DealNetting_Swift_MT399 

select ClientAnyAddress(25571,'AddressFact', td) from dual

----------------------------------------------------------------------------------
--07/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

SELECT  Classified, Value, Label 
 FROM  EnumTypeValue  
  WHERE Type = 1000062148 AND ValidFromDate<=TO_DATE( '2014-03-07-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
AND ValidToDate>=TO_DATE( '2014-03-07-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' ) 
  

select * from doctree where classified = 256882633

select * from doctype where classified = 1000161029

od.DECRNALOGNEREZ_TCB
od.DealGetCommis
od.CMP_DEALPERCENTSUMM

select 4000000*0.0125*(1/365) from dual 

select * from account where code = '47427840550000000007'
select * from accountwithreestr where account = 221025345

select * from reestr where accountwithreestr = 221025345
select * from reestrdoc where accountwithreestr = 221025345

select * from nvl(ObjAttr.GetOneProp(, ObjAttr.PropClass(6)), 1)

select * from proplist
select * from od.billstatushistory

-- отчет для Бахавчука в TCB_REPORT по задаче 178930                                                                                                                ++
-- 18/04/2014 переименовал  колонки "Амортизир. диск. в валюте" и "Амортизир. диск. руб. эквив." в "Накопленный..." и поправил их расчет => перенести в REPORTER
-- (сделать в REPORTER новый набор данных и новый отчет) => тестит Бахавчук                                                                                         ++
-- 24/04/2014 второй отчет для Бахавчука (Портфель учтенных векселей на дату) в TCB_REPORT по задаче 186068 => доделать счета дисконта => тестит Бахавчук           ++ 
-- Игорь Макеев обещал дать доступ в TCB_REPORTER                                                                                                                   ++ 
bbr.BBR_TCB_BILLOWN_MFSO_REP_NEW

--v0.1
SELECT flabel as "Филиал",
       LABEL as "Наименование первого держателя",
       kkk as "Юр. форма (атрибут клиента)",
       isres as "Резидент",
       'вексель' as "Тип ЦБ",
       series as "Серия",
       num as "Номер",
       status_label as "Статус векселя",
       sfirstoper as "Номер операции выдачи",
       drawdate as "Дата выпуска",
       case
         when planrepaydate <= td or planrepaydate is null then
          LAST_DAY(::td) + 1
         else
          planrepaydate
       end as "Возможная дата погашения",
       paydate as "Дата погашения по договору",
       nBillDay as "Срок векселя (дн.)",
       case
         when (planrepaydate <= :td or planrepaydate is null) and
              drawdate is not null /*and substr(accountcode(acc),0,5) = '52406'*/
          then
          trunc(LAST_DAY(:td) + 1) - trunc(drawdate)
         when (planrepaydate > :td and planrepaydate is not null) and
              drawdate is not null /*and substr(accountcode(acc),0,5) = '52406'*/
          then
          trunc(planrepaydate) - trunc(drawdate)
         else
          null
       end as "Дней до погашения",
       curr as "Код валюты",
       ncurr as "Курс валюты на дату отчета",
       od.accrestout(acc, :td + 1, 1, 0) as "Остаток на счете в валюте",
       (od.accrestout(acc, :td + 1, 1, 0) * ncurr) as "Остаток на счете руб. эквив.",
       accountcode(acc) as "Номер лицевого счета",
       a1 as "Сумма номинала в валюте",
       a as "Сумма номинала руб. эквив.",
       PERCENT as "Процентная ставка",
       accountcode(accperc) as "Лицевой счет учета процентов",
       od.accrestout(accperc, :td + 1, 1, 0) as "Остаток по сч. %% в валюте",
       (od.accrestout(accperc, :td + 1, 1, 0) * ncurr) as "Остаток по сч. %% руб. эквив.",
       b as "Цена продажи в валюте",
       c as "Цена продажи руб. эквив.",
       f as "Дисконт в валюте",
       f1 as "Дисконт руб. эквив.",
       accountcode(accdisk) as "Лицевой счет учета дисконта",
       abs(od.accrestout(accdisk, :td + 1, 1, 0)) as "Ост. по сч. диск. в валюте",
       abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr) as "Ост. по сч. диск. руб. эквив.",
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          e
         else
          null
       end as "Амортизир. диск. в валюте",
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2) * ncurr
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          e * ncurr
         else
          null
       end as "Амортизир. диск. руб. эквив.",
       sRepayInterval as "Интервал погашения",
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0) +
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          a1 + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
         else
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
       end as "Стоимост по МСФО в валюте"

  FROM (SELECT CASE
                 WHEN t1.paydatevar = 4 AND t1.date1 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is null AND
                      add_months(t1.date1, 12) <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is not null AND
                      t1.date2 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 3 AND
                      t1.bdrawdate + t1.btime <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 4 AND t1.status in (14, 30) THEN
                  t2.account
                 ELSE
                  t1.account
               END AS acc,
               t1.*
          FROM (SELECT ba.account ACCOUNT,
                       c.label LABEL,
                       b.series,
                       b.paydatevar,
                       b.num,
                       nvl(b.percent, 0) PERCENT,
                       b.drawdate,
                       b.date1,
                       ba.bill AS nbill,
                       b.billgroup AS nbillgroup,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL THEN
                          'по предъявл,между ' ||
                          to_char(b.date1, 'dd.mm.yyyy') || ' и ' ||
                          to_char(b.date2, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL THEN
                          'по предъявл, но не ранее ' ||
                          to_char(b.date1, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 4 THEN
                          to_char(b.date1, 'dd.mm.yyyy')
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          'По предъявлении'
                         when b.paydatevar = 3 then
                          to_char(B.DRAWDATE + b.time, 'dd.mm.yyyy')
                         ELSE
                          ''
                       END AS paydate,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL then
                          b.date2
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL then
                          b.date1
                         WHEN b.paydatevar = 4 then
                          b.date1
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          null
                         when b.paydatevar = 3 then
                          B.DRAWDATE + b.time
                         ELSE
                          null
                       END AS planrepaydate,
                       b.billsum,
                       currencynumb(b.billcurrency) curr,
                       od.nationbankrate1(b.billcurrency, :td) ncurr,
                       b.billsum a1,
                       b.billsum * od.nationbankrate1(b.billcurrency, :td) a,
                       nvl(od.tcb_bill_firstprice(b.classified), 0) b,
                       nvl(od.tcb_bill_firstprice(b.classified) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) c,
                       nvl(od.bc.getbillsum(b.classified, 11), 0) d,
                       nvl(od.bc.getbillsum(b.classified, 11) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) e,
                       nvl(od.bill_p.discsum(b.classified, :td), 0) f,
                       nvl(od.bill_p.discsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) f1,
                       nvl(od.bill_p.percentsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td) / 1000,
                           0) g,
                       bsh.status status,
                       bsh.doc bshdoc,
                       b.repayinterval,
                       (select label from clienttype where classified = c.type) cltype,
                       b.drawdate as bdrawdate,
                       b.time as btime,
                       b.date2,
                       f.label as flabel,
                       case
                         when nvl(ObjAttr.GetOneProp(c.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres,
                       case
                         when bsh.status = 2 then
                          'в обращении'
                         when bsh.status = 34 then
                          'на хранении'
                         when bsh.status = 38 then
                          'получен в залог'
                         when bsh.status = 14 then
                          'оплачен'
                         when bsh.status = 30 then
                          'предъявлен к оплате'
                         else
                          'другой статус'
                       end as status_label,
                       tcb_tools.clientprop(c.classified, 'KKK_LABEL') as kkk,
                       (select d2.label
                          from billstatushistory bsh2, doctree d2
                         where d2.classified = bsh2.doc
                           and bsh2.bill = b.classified
                           and bsh2.status = 2
                           and d2.category = 702) as sfirstoper,
                       case
                         when b.drawdate is not null and b.date1 is not null then
                          trunc(b.date1) - trunc(b.drawdate)
                         else
                          null
                       end as nBillDay,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 21)) as accperc,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 5)) as accdisk,
                       (select label
                          from RepayInterval
                         where Classified = bri.repayinterval) as sRepayInterval
                
                  FROM od.bill           b,
                       billstatushistory bsh,
                       billrange         br,
                       client            c,
                       billaccount       ba,
                       billrepayinterval bri,
                       sysfilial         f
                
                 WHERE bsh.bill = b.classified
                   AND bsh.status in (2, 34, 38, 14, 30)
                   AND bsh.star:tdate <= :td
                   AND bsh.enddate > :td
                   AND NOT EXISTS
                 (SELECT *
                          FROM billstatushistory t
                         WHERE bsh.bill = t.bill
                           AND bsh.startdate < t.star:tdate
                           AND t.startdate <= :td)
                   AND bsh.doc = br.doc
                   AND bsh.bill = br.bill
                      
                   AND trim(bri.begdate) <= :td
                   AND trim(bri.enddate) > :td
                      
                   AND ba.accintention IN (1011996343, 1011996470)
                   AND f.code = b.sysfilial
                   AND b.payee = c.classified
                   AND ba.bill = b.classified
                   AND ba.repayinterval = bri.repayinterval
                   AND bri.bill = b.classified) t1
          LEFT JOIN (SELECT *
                      FROM billaccount ba1
                     WHERE ba1.repayinterval IS NULL
                       AND ba1.accintention IN (1011996343, 1011996470)) t2
            ON t1.nbill = t2.bill)
--v0.2 03/04/2014
SELECT flabel as "Филиал",
       LABEL as "Наименование первого держателя",
       kkk as "Юр. форма (атрибут клиента)",
       isres as "Резидент",
       'вексель' as "Тип ЦБ",
       series as "Серия",
       num as "Номер",
       status_label as "Статус векселя",
       sfirstoper as "Номер операции выдачи",
       drawdate as "Дата выпуска",
       case
         when planrepaydate <= td or planrepaydate is null then
          LAST_DAY(:td) + 1
         else
          planrepaydate
       end as "Возможная дата погашения",
       paydate as "Дата погашения по договору",
       nBillDay as "Срок векселя (дн.)",
       case
         when (planrepaydate <= :td or planrepaydate is null) 
          then
          0
         when (planrepaydate > :td and planrepaydate is not null) 
          then
          trunc(planrepaydate) - :td
         else
          null
       end as "Дней до погашения",
       curr as "Код валюты",
       ncurr as "Курс валюты на дату отчета",
       od.accrestout(acc, :td + 1, 1, 0) as "Остаток на счете в валюте",
       round((od.accrestout(acc, :td + 1, 1, 0) * ncurr),2) as "Остаток на счете руб. эквив.",
       accountcode(acc) as "Номер лицевого счета",
       a1 as "Сумма номинала в валюте",
       round(a,2) as "Сумма номинала руб. эквив.",
       PERCENT as "Процентная ставка",
       accountcode(accperc) as "Лицевой счет учета процентов",
       od.accrestout(accperc, :td + 1, 1, 0) as Rest_pers_val, -- "Остаток по сч. %% в валюте"
       round((od.accrestout(accperc, :td + 1, 1, 0) * ncurr),2) as Rest_pers_eq, -- "Остаток по сч. %% руб. эквив."
       b as cenp_val, -- "Цена продажи в валюте"
       round(c,2) as cenp_eq, -- "Цена продажи руб. эквив."
       f as disc_val, -- "Дисконт в валюте"
       round(f1,2) as disc_eq, -- "Дисконт руб. эквив."
       accountcode(accdisk) as acc_disc, -- "Лицевой счет учета дисконта"
       abs(od.accrestout(accdisk, :td + 1, 1, 0)) as rest_disc_val, -- "Ост. по сч. диск. в валюте"
       round(abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr),2) as rest_disc_eq, -- "Ост. по сч. диск. руб. эквив."
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          e
         else
          null
       end as amort_disc_val, -- "Амортизир. диск. в валюте"
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2) * ncurr
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          e * ncurr
         else
          null
       end as amort_disc_eq, -- "Амортизир. диск. руб. эквив."
       sRepayInterval, -- "Интервал погашения"
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0) +
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          a1 + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
         else
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
       end as MSFO_val -- "Стоимость по МСФО в валюте"

  FROM (SELECT CASE
                 WHEN t1.paydatevar = 4 AND t1.date1 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is null AND
                      add_months(t1.date1, 12) <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is not null AND
                      t1.date2 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 3 AND
                      t1.bdrawdate + t1.btime <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 4 AND t1.status in (14, 30) THEN
                  t2.account
                 ELSE
                  t1.account
               END AS acc,
               t1.*
          FROM (SELECT ba.account ACCOUNT,
                       c.label LABEL,
                       b.series,
                       b.paydatevar,
                       b.num,
                       nvl(b.percent, 0) PERCENT,
                       b.drawdate,
                       b.date1,
                       ba.bill AS nbill,
                       b.billgroup AS nbillgroup,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL THEN
                          'по предъявл,между ' ||
                          to_char(b.date1, 'dd.mm.yyyy') || ' и ' ||
                          to_char(b.date2, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL THEN
                          'по предъявл, но не ранее ' ||
                          to_char(b.date1, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 4 THEN
                          to_char(b.date1, 'dd.mm.yyyy')
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          'По предъявлении'
                         when b.paydatevar = 3 then
                          to_char(B.DRAWDATE + b.time, 'dd.mm.yyyy')
                         ELSE
                          ''
                       END AS paydate,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL then
                          b.date2
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL then
                          b.date1
                         WHEN b.paydatevar = 4 then
                          b.date1
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          null
                         when b.paydatevar = 3 then
                          B.DRAWDATE + b.time
                         ELSE
                          null
                       END AS planrepaydate,
                       b.billsum,
                       currencynumb(b.billcurrency) curr,
                       od.nationbankrate1(b.billcurrency, :td) ncurr,
                       b.billsum a1,
                       b.billsum * od.nationbankrate1(b.billcurrency, :td) a,
                       nvl(od.tcb_bill_firstprice(b.classified), 0) b,
                       nvl(od.tcb_bill_firstprice(b.classified) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) c,
                       nvl(od.bc.getbillsum(b.classified, 11), 0) d,
                       nvl(od.bc.getbillsum(b.classified, 11) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) e,
                       nvl(od.bill_p.discsum(b.classified, :td), 0) f,
                       nvl(od.bill_p.discsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) f1,
                       nvl(od.bill_p.percentsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td) / 1000,
                           0) g,
                       bsh.status status,
                       bsh.doc bshdoc,
                       b.repayinterval,
                       (select label from clienttype where classified = c.type) cltype,
                       b.drawdate as bdrawdate,
                       b.time as btime,
                       b.date2,
                       f.label as flabel,
                       case
                         when nvl(ObjAttr.GetOneProp(c.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres,
                       case
                         when bsh.status = 2 then
                          'в обращении'
                         when bsh.status = 34 then
                          'на хранении'
                         when bsh.status = 38 then
                          'получен в залог'
                         when bsh.status = 14 then
                          'оплачен'
                         when bsh.status = 30 then
                          'предъявлен к оплате'
                         else
                          'другой статус'
                       end as status_label,
                       tcb_tools.clientprop(c.classified, 'KKK_LABEL') as kkk,
                       (select d2.label
                          from billstatushistory bsh2, doctree d2
                         where d2.classified = bsh2.doc
                           and bsh2.bill = b.classified
                           and bsh2.status = 2
                           and d2.category = 702) as sfirstoper,
                       case
                         when b.drawdate is not null and b.date1 is not null then
                          trunc(b.date1) - trunc(b.drawdate)
                         else
                          null
                       end as nBillDay,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 21)) as accperc,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 5)) as accdisk,
                       (select label
                          from RepayInterval
                         where Classified = bri.repayinterval) as sRepayInterval
                
                  FROM od.bill           b,
                       billstatushistory bsh,
                       billrange         br,
                       client            c,
                       billaccount       ba,
                       billrepayinterval bri,
                       sysfilial         f
                
                 WHERE 
                   f.code = :FILIAL_ATHENA 
                   AND bsh.status = :BILL_STATUS -- 2:'в обращении', 34:'на хранении', 38:'получен в залог', 14:'оплачен', 30:'предъявлен к оплате', иначе:'другой статус'
                   AND bsh.bill = b.classified
                   AND bsh.status in (2, 34, 38, 14, 30)
                   AND bsh.startdate <= :td
                   AND bsh.enddate > :td
                   AND NOT EXISTS
                 (SELECT *
                          FROM billstatushistory t
                         WHERE bsh.bill = t.bill
                           AND bsh.startdate < t.startdate
                           AND t.startdate <= :td)
                   AND bsh.doc = br.doc
                   AND bsh.bill = br.bill
                      
                   AND trim(bri.begdate) <= :td
                   AND trim(bri.enddate) > :td
                      
                   AND ba.accintention IN (1011996343, 1011996470)
                   AND f.code = b.sysfilial
                   AND b.payee = c.classified
                   AND ba.bill = b.classified
                   AND ba.repayinterval = bri.repayinterval
                   AND bri.bill = b.classified) t1
          LEFT JOIN (SELECT *
                      FROM billaccount ba1
                     WHERE ba1.repayinterval IS NULL
                       AND ba1.accintention IN (1011996343, 1011996470)) t2
            ON t1.nbill = t2.bill) 
--v0.3 03/04/2014
SELECT flabel, -- "Филиал"
       LABEL, -- "Наименование первого держателя"
       kkk, -- "Юр. форма (атрибут клиента)"
       isres, -- "Резидент"
       'вексель' as type_CB, -- "Тип ЦБ"
       series, -- "Серия"
       num, -- "Номер"
       status_label, -- "Статус векселя"
       sfirstoper, -- "Номер операции выдачи"
       drawdate, -- "Дата выпуска"
       case
         when planrepaydate <= td or planrepaydate is null then
          LAST_DAY(:td) + 1
         else
          planrepaydate
       end as date_pog, -- "Возможная дата погашения"
       paydate, -- "Дата погашения по договору"
       nBillDay, -- "Срок векселя (дн.)"
       case
         when (planrepaydate <= :td or planrepaydate is null) 
          then
          0
         when (planrepaydate > :td and planrepaydate is not null) 
          then
          trunc(planrepaydate) - :td
         else
          null
       end as days_to_pog, -- "Дней до погашения"
       curr, -- "Код валюты"
       ncurr, -- "Курс валюты на дату отчета"
       od.accrestout(acc, :td + 1, 1, 0) as Rest_main_val, -- "Остаток на счете в валюте"
       round((od.accrestout(acc, :td + 1, 1, 0) * ncurr),2) as Rest_main_eq, -- "Остаток на счете руб. эквив."
       accountcode(acc) as acc_number, -- "Номер лицевого счета"
       a1 as nom_val, -- "Сумма номинала в валюте"
       round(a,2) as nom_eq, -- "Сумма номинала руб. эквив."
       PERCENT, -- "Процентная ставка"
       accountcode(accperc) as acc_perc, -- "Лицевой счет учета процентов"
       od.accrestout(accperc, :td + 1, 1, 0) as Rest_pers_val, -- "Остаток по сч. %% в валюте"
       round((od.accrestout(accperc, :td + 1, 1, 0) * ncurr),2) as Rest_pers_eq, -- "Остаток по сч. %% руб. эквив."
       b as cenp_val, -- "Цена продажи в валюте"
       round(c,2) as cenp_eq, -- "Цена продажи руб. эквив."
       f as disc_val, -- "Дисконт в валюте"
       round(f1,2) as disc_eq, -- "Дисконт руб. эквив."
       accountcode(accdisk) as acc_disc, -- "Лицевой счет учета дисконта"
       abs(od.accrestout(accdisk, :td + 1, 1, 0)) as rest_disc_val, -- "Ост. по сч. диск. в валюте"
       round(abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr),2) as rest_disc_eq, -- "Ост. по сч. диск. руб. эквив."
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          e
         else
          null
       end as amort_disc_val, -- "Амортизир. диск. в валюте"
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2) * ncurr
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          e * ncurr
         else
          null
       end as amort_disc_eq, -- "Амортизир. диск. руб. эквив."
       sRepayInterval, -- "Интервал погашения"
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0) +
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          a1 + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
         else
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
       end as MSFO_val -- "Стоимость по МСФО в валюте"

  FROM (SELECT CASE
                 WHEN t1.paydatevar = 4 AND t1.date1 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is null AND
                      add_months(t1.date1, 12) <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is not null AND
                      t1.date2 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 3 AND
                      t1.bdrawdate + t1.btime <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 4 AND t1.status in (14, 30) THEN
                  t2.account
                 ELSE
                  t1.account
               END AS acc,
               t1.*
          FROM (SELECT ba.account ACCOUNT,
                       c.label LABEL,
                       b.series,
                       b.paydatevar,
                       b.num,
                       nvl(b.percent, 0) PERCENT,
                       b.drawdate,
                       b.date1,
                       ba.bill AS nbill,
                       b.billgroup AS nbillgroup,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL THEN
                          'по предъявл,между ' ||
                          to_char(b.date1, 'dd.mm.yyyy') || ' и ' ||
                          to_char(b.date2, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL THEN
                          'по предъявл, но не ранее ' ||
                          to_char(b.date1, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 4 THEN
                          to_char(b.date1, 'dd.mm.yyyy')
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          'По предъявлении'
                         when b.paydatevar = 3 then
                          to_char(B.DRAWDATE + b.time, 'dd.mm.yyyy')
                         ELSE
                          ''
                       END AS paydate,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL then
                          b.date2
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL then
                          b.date1
                         WHEN b.paydatevar = 4 then
                          b.date1
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          null
                         when b.paydatevar = 3 then
                          B.DRAWDATE + b.time
                         ELSE
                          null
                       END AS planrepaydate,
                       b.billsum,
                       currencynumb(b.billcurrency) curr,
                       od.nationbankrate1(b.billcurrency, :td) ncurr,
                       b.billsum a1,
                       b.billsum * od.nationbankrate1(b.billcurrency, :td) a,
                       nvl(od.tcb_bill_firstprice(b.classified), 0) b,
                       nvl(od.tcb_bill_firstprice(b.classified) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) c,
                       nvl(od.bc.getbillsum(b.classified, 11), 0) d,
                       nvl(od.bc.getbillsum(b.classified, 11) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) e,
                       nvl(od.bill_p.discsum(b.classified, :td), 0) f,
                       nvl(od.bill_p.discsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) f1,
                       nvl(od.bill_p.percentsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td) / 1000,
                           0) g,
                       bsh.status status,
                       bsh.doc bshdoc,
                       b.repayinterval,
                       (select label from clienttype where classified = c.type) cltype,
                       b.drawdate as bdrawdate,
                       b.time as btime,
                       b.date2,
                       f.label as flabel,
                       case
                         when nvl(ObjAttr.GetOneProp(c.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres,
                       case
                         when bsh.status = 2 then
                          'в обращении'
                         when bsh.status = 34 then
                          'на хранении'
                         when bsh.status = 38 then
                          'получен в залог'
                         when bsh.status = 14 then
                          'оплачен'
                         when bsh.status = 30 then
                          'предъявлен к оплате'
                         else
                          'другой статус'
                       end as status_label,
                       tcb_tools.clientprop(c.classified, 'KKK_LABEL') as kkk,
                       (select d2.label
                          from billstatushistory bsh2, doctree d2
                         where d2.classified = bsh2.doc
                           and bsh2.bill = b.classified
                           and bsh2.status = 2
                           and d2.category = 702) as sfirstoper,
                       case
                         when b.drawdate is not null and b.date1 is not null then
                          trunc(b.date1) - trunc(b.drawdate)
                         else
                          null
                       end as nBillDay,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 21)) as accperc,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 5)) as accdisk,
                       (select label
                          from RepayInterval
                         where Classified = bri.repayinterval) as sRepayInterval
                
                  FROM od.bill           b,
                       billstatushistory bsh,
                       billrange         br,
                       client            c,
                       billaccount       ba,
                       billrepayinterval bri,
                       sysfilial         f
                
                 WHERE 
                   f.code = :FILIAL_ATHENA 
                   AND bsh.status = :BILL_STATUS -- 2:'в обращении', 34:'на хранении', 38:'получен в залог', 14:'оплачен', 30:'предъявлен к оплате', иначе:'другой статус'
                   AND bsh.bill = b.classified
                   AND bsh.status in (2, 34, 38, 14, 30)
                   AND bsh.startdate <= :td
                   AND bsh.enddate > :td
                   AND NOT EXISTS
                 (SELECT *
                          FROM billstatushistory t
                         WHERE bsh.bill = t.bill
                           AND bsh.startdate < t.startdate
                           AND t.startdate <= :td)
                   AND bsh.doc = br.doc
                   AND bsh.bill = br.bill
                      
                   AND trim(bri.begdate) <= :td
                   AND trim(bri.enddate) > :td
                      
                   AND ba.accintention IN (1011996343, 1011996470)
                   AND f.code = b.sysfilial
                   AND b.payee = c.classified
                   AND ba.bill = b.classified
                   AND ba.repayinterval = bri.repayinterval
                   AND bri.bill = b.classified) t1
          LEFT JOIN (SELECT *
                      FROM billaccount ba1
                     WHERE ba1.repayinterval IS NULL
                       AND ba1.accintention IN (1011996343, 1011996470)) t2
            ON t1.nbill = t2.bill) 
--v0.4 03/04/2014
SELECT flabel, -- "Филиал"
       LABEL, -- "Наименование первого держателя"
       kkk, -- "Юр. форма (атрибут клиента)"
       isres, -- "Резидент"
       'вексель' as type_CB, -- "Тип ЦБ"
       series, -- "Серия"
       num, -- "Номер"
       status_label, -- "Статус векселя"
       sfirstoper, -- "Номер операции выдачи"
       drawdate, -- "Дата выпуска"
       case
         when planrepaydate <= td or planrepaydate is null then
          LAST_DAY(:td) + 1
         else
          planrepaydate
       end as date_pog, -- "Возможная дата погашения"
       paydate, -- "Дата погашения по договору"
       nBillDay, -- "Срок векселя (дн.)"
       case
         when (planrepaydate <= :td or planrepaydate is null) 
          then
          0
         when (planrepaydate > :td and planrepaydate is not null) 
          then
          trunc(planrepaydate) - :td
         else
          null
       end as days_to_pog, -- "Дней до погашения"
       curr, -- "Код валюты"
       ncurr, -- "Курс валюты на дату отчета"
       od.accrestout(acc, :td + 1, 1, 0) as Rest_main_val, -- "Остаток на счете в валюте"
       round((od.accrestout(acc, :td + 1, 1, 0) * ncurr),2) as Rest_main_eq, -- "Остаток на счете руб. эквив."
       accountcode(acc) as acc_number, -- "Номер лицевого счета"
       a1 as nom_val, -- "Сумма номинала в валюте"
       round(a,2) as nom_eq, -- "Сумма номинала руб. эквив."
       PERCENT, -- "Процентная ставка"
       accountcode(accperc) as acc_perc, -- "Лицевой счет учета процентов"
       od.accrestout(accperc, :td + 1, 1, 0) as Rest_pers_val, -- "Остаток по сч. %% в валюте"
       round((od.accrestout(accperc, :td + 1, 1, 0) * ncurr),2) as Rest_pers_eq, -- "Остаток по сч. %% руб. эквив."
       b as cenp_val, -- "Цена продажи в валюте"
       round(c,2) as cenp_eq, -- "Цена продажи руб. эквив."
       a1 - b as disc_val, -- "Дисконт в валюте"
       round(a,2) - round(c,2) as disc_eq, -- "Дисконт руб. эквив."
       accountcode(accdisk) as acc_disc, -- "Лицевой счет учета дисконта"
       abs(od.accrestout(accdisk, :td + 1, 1, 0)) as rest_disc_val, -- "Ост. по сч. диск. в валюте"
       round(abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr),2) as rest_disc_eq, -- "Ост. по сч. диск. руб. эквив."
       f as amort_disc_val, -- "Амортизир. диск. в валюте"
       round(f1,2) as amort_disc_eq, -- "Амортизир. диск. руб. эквив."
       sRepayInterval, -- "Интервал погашения"
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0) +
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          a1 + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
         else
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
       end as MSFO_val -- "Стоимость по МСФО в валюте"

  FROM (SELECT CASE
                 WHEN t1.paydatevar = 4 AND t1.date1 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is null AND
                      add_months(t1.date1, 12) <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is not null AND
                      t1.date2 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 3 AND
                      t1.bdrawdate + t1.btime <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 4 AND t1.status in (14, 30) THEN
                  t2.account
                 ELSE
                  t1.account
               END AS acc,
               t1.*
          FROM (SELECT ba.account ACCOUNT,
                       c.label LABEL,
                       b.series,
                       b.paydatevar,
                       b.num,
                       nvl(b.percent, 0) PERCENT,
                       b.drawdate,
                       b.date1,
                       ba.bill AS nbill,
                       b.billgroup AS nbillgroup,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL THEN
                          'по предъявл,между ' ||
                          to_char(b.date1, 'dd.mm.yyyy') || ' и ' ||
                          to_char(b.date2, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL THEN
                          'по предъявл, но не ранее ' ||
                          to_char(b.date1, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 4 THEN
                          to_char(b.date1, 'dd.mm.yyyy')
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          'По предъявлении'
                         when b.paydatevar = 3 then
                          to_char(B.DRAWDATE + b.time, 'dd.mm.yyyy')
                         ELSE
                          ''
                       END AS paydate,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL then
                          b.date2
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL then
                          b.date1
                         WHEN b.paydatevar = 4 then
                          b.date1
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          null
                         when b.paydatevar = 3 then
                          B.DRAWDATE + b.time
                         ELSE
                          null
                       END AS planrepaydate,
                       b.billsum,
                       currencynumb(b.billcurrency) curr,
                       od.nationbankrate1(b.billcurrency, :td) ncurr,
                       b.billsum a1,
                       b.billsum * od.nationbankrate1(b.billcurrency, :td) a,
                       nvl(od.tcb_bill_firstprice(b.classified), 0) b,
                       nvl(od.tcb_bill_firstprice(b.classified) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) c,
                       nvl(od.bc.getbillsum(b.classified, 11), 0) d,
                       nvl(od.bc.getbillsum(b.classified, 11) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) e,
                       nvl(od.bill_p.discsum(b.classified, :td), 0) f,
                       nvl(od.bill_p.discsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) f1,
                       nvl(od.bill_p.percentsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td) / 1000,
                           0) g,
                       bsh.status status,
                       bsh.doc bshdoc,
                       b.repayinterval,
                       (select label from clienttype where classified = c.type) cltype,
                       b.drawdate as bdrawdate,
                       b.time as btime,
                       b.date2,
                       f.label as flabel,
                       case
                         when nvl(ObjAttr.GetOneProp(c.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres,
                       case
                         when bsh.status = 2 then
                          'в обращении'
                         when bsh.status = 34 then
                          'на хранении'
                         when bsh.status = 38 then
                          'получен в залог'
                         when bsh.status = 14 then
                          'оплачен'
                         when bsh.status = 4 then
                          'погашен'
                         else
                          'другой статус'
                       end as status_label,
                       tcb_tools.clientprop(c.classified, 'KKK_LABEL') as kkk,
                       (select d2.label
                          from billstatushistory bsh2, doctree d2
                         where d2.classified = bsh2.doc
                           and bsh2.bill = b.classified
                           and bsh2.status = 2
                           and d2.category = 702) as sfirstoper,
                       case
                         when b.drawdate is not null and b.date1 is not null then
                          trunc(b.date1) - trunc(b.drawdate)
                         else
                          null
                       end as nBillDay,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 21)) as accperc,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 5)) as accdisk,
                       (select label
                          from RepayInterval
                         where Classified = bri.repayinterval) as sRepayInterval
                
                  FROM od.bill           b,
                       billstatushistory bsh,
                       billrange         br,
                       client            c,
                       billaccount       ba,
                       billrepayinterval bri,
                       sysfilial         f
                
                 WHERE 
                   f.code = :FILIAL_ATHENA 
                   AND bsh.status = :BILL_STATUS -- 2:'в обращении', 34:'на хранении', 38:'получен в залог', 14:'оплачен', 4:'погашен', иначе:'другой статус'
                   AND bsh.bill = b.classified
                   AND bsh.status in (2, 34, 38, 14, 4)
                   AND bsh.startdate <= :td
                   AND bsh.enddate > :td
                   AND NOT EXISTS
                 (SELECT *
                          FROM billstatushistory t
                         WHERE bsh.bill = t.bill
                           AND bsh.startdate < t.startdate
                           AND t.startdate <= :td)
                   AND bsh.doc = br.doc
                   AND bsh.bill = br.bill
                      
                   AND trim(bri.begdate) <= :td
                   AND trim(bri.enddate) > :td
                      
                   AND ba.accintention IN (1011996343, 1011996470)
                   AND f.code = b.sysfilial
                   AND b.payee = c.classified
                   AND ba.bill = b.classified
                   AND ba.repayinterval = bri.repayinterval
                   AND bri.bill = b.classified) t1
          LEFT JOIN (SELECT *
                      FROM billaccount ba1
                     WHERE ba1.repayinterval IS NULL
                       AND ba1.accintention IN (1011996343, 1011996470)) t2
            ON t1.nbill = t2.bill) 
--v0.5 07/04/2014
SELECT flabel, -- "Филиал"
       LABEL, -- "Наименование первого держателя"
       kkk, -- "Юр. форма (атрибут клиента)"
       isres, -- "Резидент"
       'вексель' as type_CB, -- "Тип ЦБ"
       series, -- "Серия"
       num, -- "Номер"
       status_label, -- "Статус векселя"
       sfirstoper, -- "Номер операции выдачи"
       drawdate, -- "Дата выпуска"
       case
         when planrepaydate <= td or planrepaydate is null then
          LAST_DAY(:td) + 1
         else
          planrepaydate
       end as date_pog, -- "Возможная дата погашения"
       paydate, -- "Дата погашения по договору"
       nBillDay, -- "Срок векселя (дн.)"
       case
         when (planrepaydate <= :td or planrepaydate is null) 
          then
          0
         when (planrepaydate > :td and planrepaydate is not null) 
          then
          trunc(planrepaydate) - :td
         else
          null
       end as days_to_pog, -- "Дней до погашения"
       
       oper_pog, -- "Номер операции погашения"
       fact_date_pog, -- "Фактическая дата погашения"
              
       curr, -- "Код валюты"
       ncurr, -- "Курс валюты на дату отчета"
       od.accrestout(acc, :td + 1, 1, 0) as Rest_main_val, -- "Остаток на счете в валюте"
       round((od.accrestout(acc, :td + 1, 1, 0) * ncurr),2) as Rest_main_eq, -- "Остаток на счете руб. эквив."
       accountcode(acc) as acc_number, -- "Номер лицевого счета"
       a1 as nom_val, -- "Сумма номинала в валюте"
       round(a,2) as nom_eq, -- "Сумма номинала руб. эквив."
       PERCENT, -- "Процентная ставка"
       accountcode(accperc) as acc_perc, -- "Лицевой счет учета процентов"
       od.accrestout(accperc, :td + 1, 1, 0) as Rest_pers_val, -- "Остаток по сч. %% в валюте"
       round((od.accrestout(accperc, :td + 1, 1, 0) * ncurr),2) as Rest_pers_eq, -- "Остаток по сч. %% руб. эквив."
       b as cenp_val, -- "Цена продажи в валюте"
       round(c,2) as cenp_eq, -- "Цена продажи руб. эквив."
       a1 - b as disc_val, -- "Дисконт в валюте"
       round(a,2) - round(c,2) as disc_eq, -- "Дисконт руб. эквив."
       accountcode(accdisk) as acc_disc, -- "Лицевой счет учета дисконта"
       abs(od.accrestout(accdisk, :td + 1, 1, 0)) as rest_disc_val, -- "Ост. по сч. диск. в валюте"
       round(abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr),2) as rest_disc_eq, -- "Ост. по сч. диск. руб. эквив."
       f as amort_disc_val, -- "Амортизир. диск. в валюте"
       round(f1,2) as amort_disc_eq, -- "Амортизир. диск. руб. эквив."
       sRepayInterval, -- "Интервал погашения"
       case
         when d > 0 and substr(accountcode(acc), 0, 5) != '52406' then
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0) +
          round((c * 1000 *
                (power(1 +
                        (((power(a1 / (a1 - d),
                                 1 / ((planrepaydate - drawdate) / 365)) - 1) * 100) / 100),
                        (:td - drawdate) / 365) - 1)) / 1000,
                2)
         when d > 0 and substr(accountcode(acc), 0, 5) = '52406' then
          a1 + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
         else
          a1 - e + nvl(od.accrestout(accperc, :td + 1, 1, 0), 0)
       end as MSFO_val -- "Стоимость по МСФО в валюте"

  FROM (SELECT CASE
                 WHEN t1.paydatevar = 4 AND t1.date1 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is null AND
                      add_months(t1.date1, 12) <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 1 and t1.date2 is not null AND
                      t1.date2 <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 3 AND
                      t1.bdrawdate + t1.btime <= aftworkday(:td) THEN
                  t2.account
                 WHEN t1.paydatevar = 4 AND t1.status in (14, 30) THEN
                  t2.account
                 ELSE
                  t1.account
               END AS acc,
               t1.*
          FROM (SELECT ba.account ACCOUNT,
                       c.label LABEL,
                       b.series,
                       b.paydatevar,
                       b.num,
                       nvl(b.percent, 0) PERCENT,
                       b.drawdate,
                       b.date1,
                       ba.bill AS nbill,
                       b.billgroup AS nbillgroup,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL THEN
                          'по предъявл,между ' ||
                          to_char(b.date1, 'dd.mm.yyyy') || ' и ' ||
                          to_char(b.date2, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL THEN
                          'по предъявл, но не ранее ' ||
                          to_char(b.date1, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 4 THEN
                          to_char(b.date1, 'dd.mm.yyyy')
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          'По предъявлении'
                         when b.paydatevar = 3 then
                          to_char(B.DRAWDATE + b.time, 'dd.mm.yyyy')
                         ELSE
                          ''
                       END AS paydate,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL then
                          b.date2
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL then
                          b.date1
                         WHEN b.paydatevar = 4 then
                          b.date1
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          null
                         when b.paydatevar = 3 then
                          B.DRAWDATE + b.time
                         ELSE
                          null
                       END AS planrepaydate,
                       b.billsum,
                       currencynumb(b.billcurrency) curr,
                       od.nationbankrate1(b.billcurrency, :td) ncurr,
                       b.billsum a1,
                       b.billsum * od.nationbankrate1(b.billcurrency, :td) a,
                       nvl(od.tcb_bill_firstprice(b.classified), 0) b,
                       nvl(od.tcb_bill_firstprice(b.classified) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) c,
                       nvl(od.bc.getbillsum(b.classified, 11), 0) d,
                       nvl(od.bc.getbillsum(b.classified, 11) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) e,
                       nvl(od.bill_p.discsum(b.classified, :td), 0) f,
                       nvl(od.bill_p.discsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) f1,
                       nvl(od.bill_p.percentsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td) / 1000,
                           0) g,
                       bsh.status status,
                       bsh.doc bshdoc,
                       b.repayinterval,
                       (select label from clienttype where classified = c.type) cltype,
                       b.drawdate as bdrawdate,
                       b.time as btime,
                       b.date2,
                       f.label as flabel,
                       case
                         when nvl(ObjAttr.GetOneProp(c.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres,
                       case
                         when bsh.status = 2 then
                          'в обращении'
                         when bsh.status = 34 then
                          'на хранении'
                         when bsh.status = 38 then
                          'получен в залог'
                         when bsh.status = 14 then
                          'оплачен'
                         when bsh.status = 4 then
                          'погашен'
                         when bsh.status = 41 then 
                          'списан в доход'
                         else
                          'другой статус'
                       end as status_label,
                       tcb_tools.clientprop(c.classified, 'KKK_LABEL') as kkk,
                       (select d2.label
                          from billstatushistory bsh2, doctree d2
                         where d2.classified = bsh2.doc
                           and bsh2.bill = b.classified
                           and bsh2.status = 2
                           and d2.category = 702) as sfirstoper,
                       case
                         when b.drawdate is not null and b.date1 is not null then
                          trunc(b.date1) - trunc(b.drawdate)
                         else
                          null
                       end as nBillDay,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 21)) as accperc,
                       (select Account
                          from BillAccount
                         where bill = b.classified
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 5)) as accdisk,
                       (select label
                          from RepayInterval
                         where Classified = bri.repayinterval) as sRepayInterval,
                       case
                         when bsh.status = 4 then
                           od.doclabel(bsh.doc)
                         else
                           null
                       end as oper_pog,
                       case
                         when bsh.status = 4 then
                           (select operdate from doctree where classified = bsh.doc)
                         else
                           null
                       end as fact_date_pog
                         
                
                  FROM od.bill           b,
                       billstatushistory bsh,
                       billrange         br,
                       client            c,
                       billaccount       ba,
                       billrepayinterval bri,
                       sysfilial         f
                
                 WHERE 
                   f.code = :FILIAL_ATHENA 
                   AND bsh.status = :BILL_STATUS -- 2:'в обращении', 34:'на хранении', 38:'получен в залог', 14:'оплачен', 4:'погашен', 41:'списан в доход', иначе:'другой статус'
                   AND bsh.bill = b.classified
                   AND bsh.status in (2, 34, 38, 14, 4, 41)
                   AND bsh.startdate <= :td
                   AND bsh.enddate > :td
                   AND NOT EXISTS
                 (SELECT *
                          FROM billstatushistory t
                         WHERE bsh.bill = t.bill
                           AND bsh.startdate < t.startdate
                           AND t.startdate <= :td)
                   AND bsh.doc = br.doc
                   AND bsh.bill = br.bill
                      
                   AND trim(bri.begdate) <= :td
                   AND trim(bri.enddate) > :td
                      
                   AND ba.accintention IN (1011996343, 1011996470)
                   AND f.code = b.sysfilial
                   AND b.payee = c.classified
                   AND ba.bill = b.classified
                   AND ba.repayinterval = bri.repayinterval
                   AND bri.bill = b.classified) t1
          LEFT JOIN (SELECT *
                      FROM billaccount ba1
                     WHERE ba1.repayinterval IS NULL
                       AND ba1.accintention IN (1011996343, 1011996470)) t2
            ON t1.nbill = t2.bill) 
--v0.51 18/04/2014
       a1 - b - abs(od.accrestout(accdisk, :td + 1, 1, 0)) as amort_disc_val,                                  -- "Накопленный диск. в валюте"
       round(a,2) - round(c,2) - round(abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr),2) as amort_disc_eq, -- "Накопленный диск. руб. эквив."

--v0.1 25/04/2014
SELECT flabel, -- "Филиал"
       od.billgrouplabel(billgroup), -- "Группа векселя"
       LABEL2, -- "Наименование эмитента"
       kkk2, -- "Юридическая форма эмитента (атрибут клиента)"
       isres2, -- "Резидент"
       series, -- "Серия"
       num, -- "Номер"
       status_label, -- "Статус векселя"
       drawdate, -- "Дата выпуска по векселю"
       paydate, -- "Дата погашения по векселю"
       nBillDay, -- "Срок векселя (дн.)"
       case
         when (planrepaydate <= :td or planrepaydate is null) then
          0
         when (planrepaydate > :td and planrepaydate is not null) then
          trunc(planrepaydate) - :td
         else
          null
       end as days_to_pog, -- "Дней до погашения"
       LABEL, -- "Наименование продавца"
       kkk, -- "Юридическая форма продавца (атрибут клиента)"
       isres, -- "Резидент"
       curr, -- "Код валюты"
       ncurr, -- "Курс валюты на дату отчета"
       a1 as nom_val, -- "Сумма номинала в валюте"
       round(a, 2) as nom_eq, -- "Сумма номинала руб. эквив."
       sfirstoper, -- "Номер операции покупки"
       dfirstoper, -- "Дата операции покупки"
       accountcode(acc) as acc_number, -- "Номер лицевого счета"
       abs(od.accrestout(acc, :td + 1, 1, 0)) as Rest_main_val, -- "Остаток на счете в валюте"
       abs(round((od.accrestout(acc, :td + 1, 1, 0) * ncurr), 2)) as Rest_main_eq, -- "Остаток на счете руб. эквив."
       t1_rowprice as cenpr_val, -- "Цена приобретения в валюте"
       round((t1_rowprice*ncurr), 2) as cenpr_eq, -- "Цена приобретения руб. эквив."
       PERCENT, -- "Процентная ставка"
       accountcode(accperc) as acc_perc, -- "Лицевой счет учета процентов"
       abs(od.accrestout(accperc, :td + 1, 1, 0)) as Rest_pers_val, -- "Остаток по сч. %% в валюте"
       round((od.accrestout(accperc, :td + 1, 1, 0)) * ncurr, 2) as Rest_pers_eq, -- "Остаток по сч. %% руб. эквив."
       PercentSum, -- "Накопленные проценты с даты приобретения в валюте"
       round(PercentSum*ncurr, 2) as PercentSum_eq, -- "Накопленные проценты с даты приобретения руб. эквив."      
       accountcode(accdisk) as acc_disc, -- "Лицевой счет учета дисконта"
       abs(od.accrestout(accdisk, :td + 1, 1, 0)) as rest_disc_val, -- "Ост. по сч. диск. в валюте"
       round(abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr), 2) as rest_disc_eq, -- "Ост. по сч. диск. руб. эквив."
       DiscSum, -- "Накопленный дисконт с даты приобретения в валюте"
       round(DiscSum*ncurr, 2) as PercentSum_eq_1, -- "Накопленный дисконт с даты приобретения руб. эквив."    
       slastoper, -- "Номер операции продажи векселя"
       dlastoper, -- "Фактическая дата продажи векселя"
       t2_rowprice as cenp_val, -- "Цена продажи векселя в валюте"
       round((t2_rowprice*ncurr), 2) as cenp_eq, -- "Цена продажи векселя руб. эквив."
       riskgroup, -- "Категория качества" 
       accres, -- "Лицевой счет учета резерва"
       riskperc, -- "Ставка резерва"
       risksum -- "Сумма резерва"


  FROM (SELECT ba.account AS acc,
                       c.label  LABEL,
                       b.billgroup,
                       c2.label LABEL2,
                       tcb_tools.clientprop(c2.classified, 'KKK_LABEL') as kkk2,
                       case
                         when nvl(ObjAttr.GetOneProp(c2.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres2,
                       b.series,
                       b.paydatevar,
                       b.num,
                       nvl(b.percent, 0) PERCENT,
                       b.drawdate,
                       b.date1,
                       ba.bill AS nbill,
                       b.billgroup AS nbillgroup,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL THEN
                          'по предъявл,между ' ||
                          to_char(b.date1, 'dd.mm.yyyy') || ' и ' ||
                          to_char(b.date2, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL THEN
                          'по предъявл, но не ранее ' ||
                          to_char(b.date1, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 4 THEN
                          to_char(b.date1, 'dd.mm.yyyy')
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          'По предъявлении'
                         when b.paydatevar = 3 then
                          to_char(B.DRAWDATE + b.time, 'dd.mm.yyyy')
                         ELSE
                          ''
                       END AS paydate,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL then
                          b.date2
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL then
                          b.date1
                         WHEN b.paydatevar = 4 then
                          b.date1
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          null
                         when b.paydatevar = 3 then
                          B.DRAWDATE + b.time
                         ELSE
                          null
                       END AS planrepaydate,
                       currencynumb(b.billcurrency) curr,
                       od.nationbankrate1(b.billcurrency, :td) ncurr,
                       b.billsum a1,
                       b.billsum * od.nationbankrate1(b.billcurrency, :td) a,
                       nvl(od.tcb_bill_firstprice(b.classified), 0) b,
                       nvl(od.tcb_bill_firstprice(b.classified) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) c,
                       nvl(od.bc.getbillsum(b.classified, 11), 0) d,
                       nvl(od.bc.getbillsum(b.classified, 11) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) e,
                       nvl(od.bill_p.discsum(b.classified, :td), 0) f,
                       nvl(od.bill_p.discsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) f1,
                       nvl(od.bill_p.percentsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td) / 1000,
                           0) g,
                       bsh.status status,
                       bsh.doc bshdoc,
                       b.repayinterval,
                       b.drawdate as bdrawdate,
                       b.time as btime,
                       b.date2,
                       f.label as flabel,
                       case
                         when nvl(ObjAttr.GetOneProp(c.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres,
                       case
                         when bsh.status = 6 then
                          'учтен'
                         when bsh.status = 8 then
                          'переучтен'
                         when bsh.status = 34 then
                          'на хранении'
                         when bsh.status = 38 then
                          'получен в залог'
                         when bsh.status = 46 then
                          'оплачен эмитентом'
                         when bsh.status = 42 then
                          'списан в убыток'
                         else
                          'другой статус'
                       end as status_label,
                       tcb_tools.clientprop(c.classified, 'KKK_LABEL') as kkk,
                       case
                         when b.drawdate is not null and b.date1 is not null then
                          trunc(b.date1) - trunc(b.drawdate)
                         else
                          null
                       end as nBillDay,
                       (select Account
                          from BillAccount
                         where (bill = b.classified)
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 58)) as accperc,
                       (select Account
                          from BillAccount
                         where (bill = b.classified)
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 59)) as accdisk,
                       t1.label as sfirstoper,
                       t1.operdate as dfirstoper,
                       t1.rowprice as t1_rowprice,
                       od.bill_p.PercentSum(b.classified,:td) as PercentSum,
                       od.bill_p.DiscSum(b.classified,:td) as DiscSum,
                       t2.label as slastoper,
                       t2.operdate as dlastoper,
                       t2.rowprice as t2_rowprice,
                       (select label from riskgroup where classified = b.riskgroup) as riskgroup,
                       (select Account
                          from BillAccount
                         where (bill = b.classified)
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 18)) as accres,
                       b.riskperc,
                       b.billsum*od.nationbankrate1(b.billcurrency, :td)*b.riskperc/100 as risksum
                  FROM od.bill           b,
                       billstatushistory bsh,
                       billrange         br,
                       client            c2,
                       billaccount       ba,
                       billrepayinterval bri,
                       sysfilial         f,
                       client            c,
                       (select d3.classified, d3.label, bsh3.bill, max(d3.operdate) as operdate, bo3.client, br3.rowprice
                               from doctree d3, billoper bo3, billstatushistory bsh3, billrange br3
                           where d3.classified = bsh3.doc
                           and d3.classified = bo3.doc
                           and bsh3.startdate <= :td
                           and bsh3.status = 6
                           and d3.category = 711
                           and d3.classified = br3.doc
                           and bsh3.bill = br3.bill
                           group by d3.classified, d3.label, bsh3.bill, bo3.client, br3.rowprice) t1,
                       (select d3.classified, d3.label, bsh3.bill, max(d3.operdate) as operdate, bo3.client, br3.rowprice
                               from doctree d3, billoper bo3, billstatushistory bsh3, billrange br3
                           where d3.classified = bsh3.doc
                           and d3.classified = bo3.doc
                           and bsh3.startdate <= :td
                           and bsh3.status = 8
                           and d3.category = 712
                           and d3.classified = br3.doc
                           and bsh3.bill = br3.bill
                           group by d3.classified, d3.label, bsh3.bill, bo3.client, br3.rowprice) t2
                
                 WHERE f.code = :FILIAL_ATHENA
                   AND bsh.status = :BILL_STATUS -- 6:'учтен', 8:'переучтен', 34:'на хранении', 38:'получен в залог', 46:'оплачен эмитентом', 42:'списан в убыток', иначе:'другой статус'
                   AND bsh.bill = b.classified
                   AND bsh.status in (6, 8, 34, 38, 46, 42)
                   AND bsh.startdate <= :td
                   AND bsh.enddate > :td
                   AND NOT EXISTS
                 (SELECT *
                          FROM billstatushistory t
                         WHERE bsh.bill = t.bill
                           AND bsh.startdate < t.startdate
                           AND t.startdate <= :td)
                   AND bsh.doc = br.doc
                   AND bsh.bill = br.bill
                      
                   AND trim(bri.begdate) <= :td
                   AND trim(bri.enddate) > :td
                      
                   AND ba.accintention = 1011996332
                   AND f.code = b.sysfilial
                   AND b.maker = c2.classified
                   AND ba.bill = b.classified
                   AND ba.repayinterval = bri.repayinterval
                   AND bri.bill = b.classified
                   AND t1.client = c.classified
                   AND b.classified = t1.bill
                   AND b.classified = t2.bill(+))

--v0.2 15/05/2014
-- IPI 186068

SELECT flabel, -- "Филиал"
       od.billgrouplabel(billgroup), -- "Группа векселя"
       LABEL2, -- "Наименование эмитента"
       kkk2, -- "Юридическая форма эмитента (атрибут клиента)"
       isres2, -- "Резидент"
       series, -- "Серия"
       num, -- "Номер"
       status_label, -- "Статус векселя"
       drawdate, -- "Дата выпуска по векселю"
       paydate, -- "Дата погашения по векселю"
       nBillDay, -- "Срок векселя (дн.)"
       case
         when (planrepaydate <= :td or planrepaydate is null) then
          0
         when (planrepaydate > :td and planrepaydate is not null) then
          trunc(planrepaydate) - :td
         else
          null
       end as days_to_pog, -- "Дней до погашения"
       LABEL, -- "Наименование продавца"
       kkk, -- "Юридическая форма продавца (атрибут клиента)"
       isres, -- "Резидент"
       curr, -- "Код валюты"
       ncurr, -- "Курс валюты на дату отчета"
       a1 as nom_val, -- "Сумма номинала в валюте"
       round(a, 2) as nom_eq, -- "Сумма номинала руб. эквив."
       sfirstoper, -- "Номер операции покупки"
       dfirstoper, -- "Дата операции покупки"
       accountcode(acc) as acc_number, -- "Номер лицевого счета"
       abs(od.accrestout(acc, :td + 1, 1, 0)) as Rest_main_val, -- "Остаток на счете в валюте"
       abs(round((od.accrestout(acc, :td + 1, 1, 0) * ncurr), 2)) as Rest_main_eq, -- "Остаток на счете руб. эквив."
       t1_rowprice as cenpr_val, -- "Цена приобретения в валюте"
       round((t1_rowprice*ncurr), 2) as cenpr_eq, -- "Цена приобретения руб. эквив."
       PERCENT, -- "Процентная ставка"
       accountcode(accperc) as acc_perc, -- "Лицевой счет учета процентов"
       abs(od.accrestout(accperc, :td + 1, 1, 0)) as Rest_pers_val, -- "Остаток по сч. %% в валюте"
       round((od.accrestout(accperc, :td + 1, 1, 0)) * ncurr, 2) as Rest_pers_eq, -- "Остаток по сч. %% руб. эквив."
       PercentSum, -- "Накопленные проценты с даты приобретения в валюте"
       round(PercentSum*ncurr, 2) as PercentSum_eq, -- "Накопленные проценты с даты приобретения руб. эквив."      
       accountcode(accdisk) as acc_disc, -- "Лицевой счет учета дисконта"
       abs(od.accrestout(accdisk, :td + 1, 1, 0)) as rest_disc_val, -- "Ост. по сч. диск. в валюте"
       round(abs(od.accrestout(accdisk, :td + 1, 1, 0) * ncurr), 2) as rest_disc_eq, -- "Ост. по сч. диск. руб. эквив."
       DiscSum, -- "Накопленный дисконт с даты приобретения в валюте"
       round(DiscSum*ncurr, 2) as DiscSum_eq, -- "Накопленный дисконт с даты приобретения руб. эквив."    
       slastoper, -- "Номер операции продажи векселя"
       dlastoper, -- "Фактическая дата продажи векселя"
       t2_rowprice as cenp_val, -- "Цена продажи векселя в валюте"
       round((t2_rowprice*ncurr), 2) as cenp_eq, -- "Цена продажи векселя руб. эквив."
       riskgroup, -- "Категория качества" 
       accres, -- "Лицевой счет учета резерва"
       riskperc, -- "Ставка резерва"
       risksum -- "Сумма резерва"

  FROM (SELECT ba.account AS acc,
                       c.label  LABEL,
                       b.billgroup,
                       c2.label LABEL2,
                       tcb_tools.clientprop(c2.classified, 'KKK_LABEL') as kkk2,
                       case
                         when nvl(ObjAttr.GetOneProp(c2.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres2,
                       b.series,
                       b.paydatevar,
                       b.num,
                       nvl(b.percent, 0) PERCENT,
                       b.drawdate,
                       b.date1,
                       ba.bill AS nbill,
                       b.billgroup AS nbillgroup,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL THEN
                          'по предъявл,между ' ||
                          to_char(b.date1, 'dd.mm.yyyy') || ' и ' ||
                          to_char(b.date2, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL THEN
                          'по предъявл, но не ранее ' ||
                          to_char(b.date1, 'dd.mm.yyyy')
                         WHEN b.paydatevar = 4 THEN
                          to_char(b.date1, 'dd.mm.yyyy')
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          'По предъявлении'
                         when b.paydatevar = 3 then
                          to_char(B.DRAWDATE + b.time, 'dd.mm.yyyy')
                         ELSE
                          ''
                       END AS paydate,
                       CASE
                         WHEN b.paydatevar = 1 AND b.date2 IS NOT NULL then
                          b.date2
                         WHEN b.paydatevar = 1 AND b.date1 IS NOT NULL then
                          b.date1
                         WHEN b.paydatevar = 4 then
                          b.date1
                         when b.paydatevar = 1 and b.date1 is null and
                              b.date2 is null then
                          null
                         when b.paydatevar = 3 then
                          B.DRAWDATE + b.time
                         ELSE
                          null
                       END AS planrepaydate,
                       currencynumb(b.billcurrency) curr,
                       od.nationbankrate1(b.billcurrency, :td) ncurr,
                       b.billsum a1,
                       b.billsum * od.nationbankrate1(b.billcurrency, :td) a,
                       nvl(od.tcb_bill_firstprice(b.classified), 0) b,
                       nvl(od.tcb_bill_firstprice(b.classified) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) c,
                       nvl(od.bc.getbillsum(b.classified, 11), 0) d,
                       nvl(od.bc.getbillsum(b.classified, 11) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) e,
                       nvl(od.bill_p.discsum(b.classified, :td), 0) f,
                       nvl(od.bill_p.discsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td),
                           0) f1,
                       nvl(od.bill_p.percentsum(b.classified, :td) *
                           od.nationbankrate1(b.billcurrency, :td) / 1000,
                           0) g,
                       bsh.status status,
                       bsh.doc bshdoc,
                       b.repayinterval,
                       b.drawdate as bdrawdate,
                       b.time as btime,
                       b.date2,
                       f.label as flabel,
                       case
                         when nvl(ObjAttr.GetOneProp(c.classified,
                                                     ObjAttr.PropClass(6)),
                                  1) = 1 then
                          'Да'
                         else
                          'Нет'
                       end as isres,
                       case
                         when bsh.status = 6 then
                          'учтен'
                         when bsh.status = 8 then
                          'переучтен'
                         when bsh.status = 34 then
                          'на хранении'
                         when bsh.status = 38 then
                          'получен в залог'
                         when bsh.status = 46 then
                          'оплачен эмитентом'
                         when bsh.status = 42 then
                          'списан в убыток'
                         else
                          'другой статус'
                       end as status_label,
                       tcb_tools.clientprop(c.classified, 'KKK_LABEL') as kkk,
                       case
                         when b.drawdate is not null and b.date1 is not null then
                          trunc(b.date1) - trunc(b.drawdate)
                         else
                          null
                       end as nBillDay,
                       (select Account
                          from BillAccount
                         where /*(bill = b.classified) or */(billgroup = b.billgroup)
                           and repayinterval = bri.repayinterval
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 58)) as accperc,
                       (select Account
                          from BillAccount
                         where /*(bill = b.classified) or */(billgroup = b.billgroup)
                           and repayinterval = bri.repayinterval
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 59)) as accdisk,
                       t1.label as sfirstoper,
                       t1.operdate as dfirstoper,
                       t1.rowprice as t1_rowprice,
                       od.bill_p.PercentSum(b.classified,:td) as PercentSum,
                       od.bill_p.DiscSum(b.classified,:td) as DiscSum,
                       t2.label as slastoper,
                       t2.operdate as dlastoper,
                       t2.rowprice as t2_rowprice,
                       (select label from riskgroup where classified = b.riskgroup) as riskgroup,
                       (select Account
                          from BillAccount
                         where (bill = b.classified)
                           and AccIntention in
                               (select classified
                                  from billaccintention
                                 where constintention = 18)) as accres,
                       b.riskperc,
                       b.billsum*od.nationbankrate1(b.billcurrency, :td)*b.riskperc/100 as risksum

                  FROM od.bill           b,
                       billstatushistory bsh,
                       billrange         br,
                       client            c2,
                       billaccount       ba,
                       billrepayinterval bri,
                       sysfilial         f,
                       client            c,
                       (select d3.classified, d3.label, bsh3.bill, max(d3.operdate) as operdate, bo3.client, br3.rowprice
                               from doctree d3, billoper bo3, billstatushistory bsh3, billrange br3
                           where d3.classified = bsh3.doc
                           and d3.classified = bo3.doc
                           and bsh3.startdate <= :td
                           and bsh3.status = 6
                           and d3.category = 711
                           and d3.classified = br3.doc
                           and bsh3.bill = br3.bill
                           group by d3.classified, d3.label, bsh3.bill, bo3.client, br3.rowprice) t1,
                       (select d3.classified, d3.label, bsh3.bill, max(d3.operdate) as operdate, bo3.client, br3.rowprice
                               from doctree d3, billoper bo3, billstatushistory bsh3, billrange br3
                           where d3.classified = bsh3.doc
                           and d3.classified = bo3.doc
                           and bsh3.startdate <= :td
                           and bsh3.status = 8
                           and d3.category = 712
                           and d3.classified = br3.doc
                           and bsh3.bill = br3.bill
                           group by d3.classified, d3.label, bsh3.bill, bo3.client, br3.rowprice) t2
                
                   WHERE instr(:FILIALS_ATHENA, '<'||f.code||'>') > 0
                   -- 6:'учтен', 8:'переучтен', 34:'на хранении', 38:'получен в залог', 46:'оплачен эмитентом', 42:'списан в убыток', иначе:'другой статус'
                   AND instr(:BILL_STATUS, '<'||bsh.status||'>') > 0 
                   AND bsh.bill = b.classified
                   AND bsh.status in (6, 8, 34, 38, 46, 42)
                   AND bsh.startdate <= :td
                   AND bsh.enddate > :td
                   AND NOT EXISTS
                 (SELECT *
                          FROM billstatushistory t
                         WHERE bsh.bill = t.bill
                           AND bsh.startdate < t.startdate
                           AND t.startdate <= :td)
                   AND bsh.doc = br.doc
                   AND bsh.bill = br.bill
                      
                   AND trim(bri.begdate) <= :td
                   AND trim(bri.enddate) > :td
                      
                   AND ba.accintention = 1011996332
                   AND f.code = b.sysfilial
                   AND b.maker = c2.classified
                   AND ba.bill = b.classified
                   AND ba.repayinterval = bri.repayinterval
                   AND bri.bill = b.classified
                   AND t1.client = c.classified
                   AND b.classified = t1.bill
                   AND b.classified = t2.bill(+))
-- для старых учтенных в Перми (14 штук) векселей Фортуны-Д пришлось проапдейтить repayinterval по основоному счету с 1011996324 на 1011996329                      ++
select * from billaccount where bill in (select classified from bill where billgroup = 1102766001) and accintention = 1011996332
update billaccount set repayinterval = 1011996329 where bill in (select classified from bill where billgroup = 1102766001) and accintention = 1011996332
--v0.3 16/05/2014

select * from 

select * from CurrExchange 

select * from bill where num = '070506'
select * from billaccount where billgroup = 1102766001
select * from billaccount where bill = 1102766003 -- 1011996324
select * from billrepayinterval where bill = 1102766003 -- 1011996329

select * from repayinterval
select * from account where classified = 128693964 

select * from billaccintention where classified IN (1011996343, 1011996470)

select * from billaccount where bill in (select classified from bill where num = '0031849')
select * from sysfilial
select * from od.bill
select * from doccategory

nDoxod := nvl(od.bill_p.Yieldcalc(to_date(dtOperDate,'dd.mm.yyyy'),to_date(dtPayDate,'dd.mm.yyyy'),nBillNominal,nPrice,null,MinorUnit(ncur)),0);
od.bill_p

select * from riskgroup 

select * from billaccount where bill in (select classified from bill where num = '0001272')

----------------------------------------------------------------------------------
--11/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from od.bill
select * from billaccintention
od.billgrouplabel

od.SQLCond_IsIssuer_StateBank


-- написал условие Client_MBK_is_BKRZ для всех "Документов" в manager (чтобы не ругалось на неправильную привязку балансовых счетов ОД по депозитам МБК с ОПЕРУ)  ++
declare
nCode varchar(50);

BEGIN
SELECT bc.code
  INTO ncode
  FROM bankcode bc
      ,deal     d
 WHERE d.doc = CONTEXT.curren:tdoc
   AND d.counterparty = bc.client
   AND bc.codesystem = 1000104502
  AND nvl(bc.validtodate,max_date) > CONTEXT.OperDate
  AND ROWNUM = 1;

IF ncode = 'BKRZ' THEN
  :ncondresult := 1;
ELSE
  :ncondresult := 0;
END IF;
 exception when Others then :ncondresult := 1;
END;

select 55000*0.1*((30+31+30+31+31)/365)from dual

----------------------------------------------------------------------------------
--12/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_DealDeposit_ReservRecalc

od.DPC_DealDeposit_Reserv_Event
od.DPC_BC_DEALRESERV

-- по сделке МБК размещения забыли поменять категорию качества и "Резервирование" не было создано. Пришлось вручную привязать три счета к сделке  
-- и воспользоваться процедурой od.DPC_DealDeposit_Reserv_Event "Создать резерв по сделке" под событием сделки                                                    ++

select rowid,  da.* from dealaccount da where doc = 257142452

37050170  1000105437
37050218  1000105436
257331301 1000105435

select * from account where classified = 257374615

select rowid,  da.* from doctree da where classified = 257331301

select rowid,  da.* from dealaccount da where doc = 256863973

37050218 1000105436

select * from dealaccintention where classified = 1000105435

      select count(*) from DealDeposit DD
         where DD.Doc = 257142452
            and DD.IsReceive = 0
            and exists (select null from DealAccount
                        where Doc = 257142452
                          and AccIntention in (select Classified from DealAccIntention
                                                where ConstIntention = 25))
                                                
                                                GetDealOverResAcc
                                                
select od.DealAcc.GetDealOverResAcc( 257142452 ) from dual

od.DPC_ReservElementCreate 

od.DPC_BC_DealReserv

select * from bill where num = '0027516'
select * from billsum where bill in (1106059565, 1106059568)

select * from billsumtype 1011996372 1011996477

select --SUM(bs2.amount/*Rate(bo.OperCurrency,1000001275,pref.exchmatrix,dt.validfromdate)*/), 
GetFilialLabel(dt.sysfilial), 
bo.doc, bs.Bill, br.Bill, (bs.amount/*Rate(bo.OperCurrency,1000001275,pref.exchmatrix,dt.validfromdate)*/) as "сумма НДФЛ",  
dt.validfromdate as "Дата операции", 
dt.classified, 
c.description as "Клиент", 
SUBSTR(od.tcb_tools.clientProp(bo.client,'INN', s.ysdate),1,10) as "ИНН",
c.address as "Адрес прописки",
od.get_tcb_tools_contact(bo.client,'Phone') as "Телефон",
nvl2(od.get_tcb_tools_JurBookCode(c.classified,'Passport','Number'),od.get_tcb_tools_JurBookCode(c.classified,'Passport','Series') || ' ' || od.get_tcb_tools_JurBookCode(c.classified,'Passport','Number') || ', выдан ' ||
to_date(RTRIM(od.get_tcb_tools_JurBookCode(c.classified,'Passport','GiveDate'),'000000'),'dd/mm/yyyy') || ' ' || od.get_tcb_tools_JurBookCode(c.classified,'Passport','GiveBy') || ', код подразделения ' || 
od.get_tcb_tools_JurBookCode(c.classified,'Passport','DepartCode'),null) as "Паспорт РФ"
from /*od.bill bl,*/ billoper bo, doctree dt, BillRange br, doctype dty, BillSum bs, /*BillSum bs2,*/ client c      
where dt.classified=bo.doc
and dt.doctype=dty.classified
and   bo.doc = br.doc
--and   br.bill=  bl.classified
and (dty.category = 703)
and   dt.docstate = 1000000035 -- Constants.State_Close 
and   dt.sysfilial = 1--(nFilial is null or dt.sysfilial=nFilial)
and   td-30 < trunc(dt.validfromdate)
and   td > trunc(dt.validfromdate) and bs.bill = br.bill
and bs.Bill in (select bill from billrange where doc = br.doc)
and bs.SumType in (select classified from billsumtype where consttype =13)
--and bs2.SumType in (select classified from billsumtype where consttype =14)
--and bs2.Bill in (select bill from billrange where doc = br.doc)
and bs.amount != 0
and bo.client = c.classified
group by dt.sysfilial, bo.OperCurrency, dt.validfromdate, dt.classified, c.description, bo.client, c.address, c.classified
order by 2, 4


select br.doc, SUM(bs2.amount/**Rate(bo.OperCurrency,1000001275,pref.exchmatrix,dt.validfromdate)*/), 
GetFilialLabel(dt.sysfilial), 
(select sum(bs3.amount/**Rate(bo.OperCurrency,1000001275,pref.exchmatrix,dt.validfromdate)*/ from BillSum bs3 where bs3.SumType in (select classified from billsumtype where consttype =13) ) as "сумма НДФЛ",  
dt.validfromdate as "Дата операции", 
dt.classified, 
c.description as "Клиент", 
SUBSTR(od.tcb_tools.clientProp(bo.client,'INN', s.ysdate),1,10) as "ИНН",
c.address as "Адрес прописки",
od.get_tcb_tools_contact(bo.client,'Phone') as "Телефон",
nvl2(od.get_tcb_tools_JurBookCode(c.classified,'Passport','Number'),od.get_tcb_tools_JurBookCode(c.classified,'Passport','Series') || ' ' || od.get_tcb_tools_JurBookCode(c.classified,'Passport','Number') || ', выдан ' ||
to_date(RTRIM(od.get_tcb_tools_JurBookCode(c.classified,'Passport','GiveDate'),'000000'),'dd/mm/yyyy') || ' ' || od.get_tcb_tools_JurBookCode(c.classified,'Passport','GiveBy') || ', код подразделения ' || 
od.get_tcb_tools_JurBookCode(c.classified,'Passport','DepartCode'),null) as "Паспорт РФ"
from /*od.bill bl,*/ billoper bo, doctree dt, BillRange br, doctype dty, BillSum bs, BillSum bs2, client c      
where dt.classified=bo.doc
and dt.doctype=dty.classified
and   bo.doc = br.doc
--and   br.bill=  bl.classified
and (dty.category = 703)
and   dt.docstate = 1000000035 -- Constants.State_Close 
and   dt.sysfilial = 1         --(nFilial is null or dt.sysfilial=nFilial)
and  td-30 /*dtBeg*/ < trunc(dt.validfromdate)
and  td /*dtEnd*/ > trunc(dt.validfromdate)
and bs.Bill in (select bill from billrange where doc = br.doc)
and bs.SumType in (select classified from billsumtype where consttype =13)
and bs2.SumType in (select classified from billsumtype where consttype =14)
and bs2.Bill in (select bill from billrange where doc = br.doc)
--and bs.amount != 0
and bo.client = c.classified
and bs.bill = br.bill  -- 13/03/2014 Панфилов М.С.
and bs2.bill = br.bill -- 13/03/2014 Панфилов М.С.
group by br.doc, dt.sysfilial, bo.OperCurrency, dt.validfromdate, dt.classified, c.description, bo.client, c.address, c.classified 
order by 2, 4

-- правил BBR_TCB_BILL_OPER_MSK - вернул назад периоды расчета колонок 44/45, чтобы суммы показывались только за период                                           ++
bbr.BBR_TCB_BILL_OPER_MSK

----------------------------------------------------------------------------------
--13/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- поправил отчет BBR_TCB_BILL_NDFL (чтобы корректно отображались суммы по операциям с несколькими векселями) для Бахавчука => НДФЛ теперь вычисляется отдельно   ++

select * from bill where num = '0023937'
select * from bill where num = '0023938'

select * from bill where num = '0023876'

-- правил суммы процентов в billsum по векселям '0023937' и '0023938' в 27/01/2014 для Бахавчука                                                                  ++
select rowid, bs.* from billsum bs where bill in (1204599140,1204648600)

select * from doctree where classified = 250965514

select *from billsumtype

select * from billsum where bill in (1308033552)

od.FUNC_BILL_ACCRUALRETURN_TL_TCB

select * from depoaccount
select * from depo

----------------------------------------------------------------------------------
--14/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- добавить в отчет BBR_TCB_BILL_OPER_MSK две колонки (просил Бахавчук) и поправить вычисление колонки 45                                                         ++
-- начал править 26/03/2014 на athena3 (сохранял в файл)
-- проверить (что-то по процентам ничего не совпадает, а по дисконтам всё ОК) => заменить AccRest на проводки из bbook => тестит Бахавчук => поправить проценты =>
-- тестит Бахавчук => добавить привычислении колонки 47 обратные проводки по процентам на 7060* => тестит Бахавчук => теперь проблема по дваждыучетнным Питерским
-- векселям => 15/04/2014 поправил

select * from billsum where bill in (select classified from bill where num = '070506') -- 1299656323
select * from doctree where classified = 105625365

select * from billsum where bill in (select classified from bill where num = '0001272') -- 1299656323
select * from preparemoney where account in (select classified from account where code = '52501810100300023895')
select * from bankoper

select 479726.15 - 284081.98 from dual
select 4379339.14 - 2333016.85 - 832560.81 from dual

select 6849.32*36.0501 + 7671.23*35.581 from dual
select * from doctree where classified in (255928429,260173968)

-- 248137359	1000001171
select classified, currency /*into acc, cur*/ from account where classified in (select account from billaccount where bill = 1299656323 and accintention in (select classified from billaccintention where constintention in (21,58)));
select amount*od.nationbankrate1(1000001171,(select operdate from doctree where classified = p.doc)) /*into res*/ 
from preparemoney p where account = 248137359 and doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01012014','ddmmyyyy') and operdate < td + 1);
 
select sumaccount*od.nationbankrate1(1000001171,(select operdate from doctree where classified = p.doc)) /*into res*/ 
from bankoper p where account = 248137359 and doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01012014','ddmmyyyy') and operdate < td + 1);
      
select * from doccategory
select * from billaccintention


select * from billsum where bill in (select classified from bill where num = '0023895') -- 1319997294
select * from preparemoney where account in (select classified from account where code = '52501810100300023895')

select amount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = p.doc)) -- into res 
from preparemoney p where account = 251740717 and doc in (select classified from doctree where docstate = 1000000035 and operdate >= td-200  and operdate < td);
select b.sumaccount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = b.doc))
from bankoper b, preparemoney p where p.doc = b.doc and b.account = 251740717 and acccode(p.account) like '70606%' and b.doc in (select classified from doctree where docstate = 1000000035 and operdate >= td-200 and operdate < td);
      

select * from billsum where bill in (select classified from bill where num = '0030921') -- 1232308638
select * from preparemoney where account in (select classified from account where code = '52501810000000030921')
and doc in (select classified from doctree where docstate = 1000000035 and operdate >= td-200  and operdate < td);
select * from bankoper where account in (select classified from account where code = '52501810000000030921')
and doc in (select classified from doctree where docstate = 1000000035 and operdate >= td-200  and operdate < td);

select amount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = p.doc)) -- into res 
from preparemoney p where account = 218038556 and doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01012014','ddmmyyyy') and operdate < td);
select b.sumaccount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = b.doc))
from bankoper b, preparemoney p where p.doc = b.doc and b.account = 218038556 and (acccode(p.account) like '7060%') and b.doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01012014','ddmmyyyy') and operdate < td);
      

select * from billsum where bill in (select classified from bill where num = '0031593') -- 1334941336
select * from preparemoney where account in (select classified from account where code = '52501810000000031593')

select amount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = p.doc)) -- into res 
from preparemoney p where account = 260310098 and doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01012014','ddmmyyyy') and operdate < td);
select b.sumaccount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = b.doc))
from bankoper b, preparemoney p where p.doc = b.doc and b.account = 260310098 and (acccode(p.account) like '7060%') and b.doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01012014','ddmmyyyy') and operdate < td);
    


bbr.BBR_TCB_BILL_OPER_MSK
select * from doccategory
select * from doctype where classified = 1155771305
select * from bbook
select * from preparemoney where account in (select classified from account where code = '52501810500000031527')
select * from doctree where classified in (248665059,249933392)
select * from doctree where classified in (248665063,249933610)
 
  select classified, currency /*into acc, cur*/ 
  from account where classified in (select account from billaccount where bill = (select classified from bill where num = '0021196') and accintention in (select classified from billaccintention where constintention in (5,59)));
  select * --sum(amount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = p.doc))) /*into res*/
  from preparemoney p where account = 219886898 and doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01/01/2014','dd/mm/yyyy') and operdate < to_date('31/03/2014','dd/mm/yyyy') + 1);
 
select * from billsum where bill in (select classified from bill where num in ('0021196','0021198'))

  select classified, currency /*into acc, cur*/ 
  from account where classified in (select account from billaccount where bill = (select classified from bill where num = '0021198') and accintention in (select classified from billaccintention where constintention in (5,59)));
  select * --sum(amount*od.nationbankrate1(1000001275,(select operdate from doctree where classified = p.doc))) /*into res*/
  from preparemoney p where account = 219887446 and doc in (select classified from doctree where docstate = 1000000035 and operdate >= to_date('01/01/2014','dd/mm/yyyy') and operdate < to_date('31/03/2014','dd/mm/yyyy') + 1);
 

select (select operdate from doctree where classified = bs.doc), bs.* from billsum bs where bill in (select classified from bill where num = '0025992') 


select (select operdate from doctree where classified = bs.doc), bs.* from billsum bs where bill in (select classified from bill where num = '0021196') 
0021196
select sum(amount) from billsum bs where bill in (select classified from bill where num = '0021196') and sumtype = 1042775368

select * from billsum where bill in (select classified from bill where num in ('0055555'))
----------------------------------------------------------------------------------
--17/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- настроить назначение платежа для комиссий МБК (просила Ледовская) =>  правил процедуры od.DPC_TCB_DESC_FOR_DILING, od.DEAL_GetPaymentPurpose,
-- сделал новую процедуру DealTrNameAssocCom_TCB + INSERT INTO DEALPAYMENTPURPOSE                                                                                 ++
--od.dpc_tcb_set_deal_purpose
od.DPC_TCB_DESC_FOR_DILING
od.DEAL_GetPaymentPurpose

od.DealDep_proc.DealDepCommissEvents

select (select Label from COMMISIONNAIM where classified = ca.naim), ca.* from CommisionAdd ca where doc = 224679515
select * from dealtransaction where doc = 224679515

INSERT INTO DEALPAYMENTPURPOSE (classified,parent,code,label,description,fullname,updatedrole,value,isvalue)
VALUES (Classified.nextval, 1131587467, '35', 'Шаблон35', null, '\MBC\35', null, '<COMISSNAME>', 1);

create or replace function DealTrNameAssocCom_TCB 
/******************************************************************************
-- Описание: Функция для определения наименования соответствующей комиссии по событию транша.
-- ищем в журнале комиссий (CommisionAdd)
-- Автор: Панфилов М.С.
-- Версия: 17/03/2014
******************************************************************************/
(   
   nDealTr   in        dt.reference  -- идентификатор события сделки
) 
return COMMISIONNAIM.LABEL%type 
as
   nres          COMMISIONNAIM.LABEL%type;
begin
-- ищем комиссию в журнале комиссий по сумме, валюте и дате
begin
select (select Label from COMMISIONNAIM where classified = ca.naim) into nres from CommisionAdd ca, Dealtransaction dt 
       where dt.doc = nDealTr  
       and parentdoc(dt.doc) = ca.doc
       and dt.amount = ca.amount
       and dt.currency = ca.currency
       and dt.valuedate = ca.operdate;
exception when others then null;
end;
   return nvl(nres,'комиссия по траншу МБК');
end DealTrNameAssocCom_TCB;

CREATE OR REPLACE PROCEDURE DPC_TCB_DESC_FOR_DILING AS
-----------------------------------------------------------------------------------
-- Заполнение назначения платежа в событиях сделок.
-- 16/05/2011 Панфилов М.С. - добавлено назначение для налога на доходы нерезидентов
-- 27/08/2012 Панфилов М.С. - добавлены назначения для траншей МБК
-- 13/12/2012 Панфилов М.С. - теперь назначения по начислению процентов за один день и за несколько - разные
-- 13/06/2013 Панфилов М.С. - новые назначения для траншей МБК привлечения (после запуска функционала "Транши МБК")
-- 02/07/2013 Панфилов М.С. - новые назначения для Внебалансовых кредитов под КЛ МБК
-- 18/02/2014 Степаненко Р.Б - Согласно Инстркурции ЦБ 138-И ,изменены коды по возврату основного долга и %% по привлеченным МБК в пользу нерезидентов. ( {VO42015}, {VO42035}).
-- 17/03/2014 Панфилов М.С.  - новые назначения для траншей МБК привлечения для комиссий
-----------------------------------------------------------------------------------

  ndoc             dt.reference;
  sdesc            dt.description;
  sacccode         VARCHAR2(10);
  nclient          dt.reference;
  nvo              NUMBER;
  nvotext          VARCHAR2(15);
  scred            dt.description;
  recdoctreeparent doctree%ROWTYPE;
  recdeal          deal%ROWTYPE;
  recdealtr        dealtransaction%ROWTYPE;
  sdealtype        dealtype.label%TYPE;
  nisreceive       dealdeposit.isreceive%TYPE;
  nint             dealaccintention.constintention%TYPE;
  dtdate           DATE;
  vclientname      dt.label;

  recDocTree       doctree%ROWTYPE;
  sRowID           RowID;
  sTicket          VARCHAR2(50);
  sclient          dt.description;
  startdealdate    DATE;
  enddealdate      DATE;
  nIntReceive      DT.ConstValue := 15;
  nIntPlace        DT.ConstValue := 16;
  rAccMain         DealAcc.tAcc;
  dtpercbegdate    DATE;                               -- начало %% интервала
  dtpercenddate    DATE;                               -- конец  %% интервала

  boacc            DT.Label;
  cl               dt.reference;

BEGIN
  IF CONTEXT.SubSystem <> 9 THEN
    RETURN;
    END IF;

   sRowID := Context.DocRowID;
   select * into recDocTree from DocTree where RowID = sRowID for update;
   if recDocTree.Parent is null then
      return;
   end if;

  SELECT d.category
    INTO ndoc
    FROM doctree d
   WHERE d.classified = CONTEXT.currentdoc;
  SELECT dt.*
    INTO recdoctreeparent
    FROM doctree dt
   WHERE dt.classified = parentdoc(CONTEXT.currentdoc);
dbms_output.put_line('sdesc000  ='||sdesc);
--ELSIF ndoc = 5 AND recdoctreeparent.category = 913 AND recdoctreeparent.doctype = 1033718051
dbms_output.put_line('ndoc  ='||ndoc);
dbms_output.put_line('recdoctreeparent.category  ='||recdoctreeparent.category);
dbms_output.put_line('recdoctreeparent.doctype  ='||recdoctreeparent.doctype);
  IF ndoc = 70 AND recdoctreeparent.category IN (901, 902) THEN
dbms_output.put_line('sdesc0001  ='||sdesc);
    -- Срочные сделки

    SELECT substr(acccode_tcb(bo.account), 1, 3)
      INTO sacccode
      FROM bankoper bo
     WHERE bo.doc = CONTEXT.currentdoc;
    IF sacccode IN (930, 933) THEN
      -- Для открытия
            sdesc := DEAL_GetPaymentPurpose('\FOREX\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    ELSE
      -- Для закрытия
            sdesc := DEAL_GetPaymentPurpose('\FOREX\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    END IF;

  ELSIF ndoc = 905 THEN
    -- Для событий

    SELECT *
      INTO recdealtr
      FROM dealtransaction
     WHERE doc = CONTEXT.currentdoc;

    -- Если событие включено в неттинг или пролонгировано, то не обрабатываем
    IF recdealtr.isnetting != 0 THEN
      RETURN;
    END IF;
	   IF recdoctreeparent.category <> 903 THEN
		SELECT t.counterparty, t.creditline                                 -- перенес из секции ниже (901,903) т.к. признак резидентности
        INTO nclient, cl                                                -- клиента нужен еще в друших местах 13/06/2013 добавил КЛ
        FROM deal t
       WHERE t.doc = recdoctreeparent.classified;
      nvo := isclresident(nclient);
		 END IF;
dbms_output.put_line('sdesc01  ='||sdesc);
    IF recdoctreeparent.category IN (901, 913) THEN
dbms_output.put_line('sdesc02  ='||sdesc);
      IF recdoctreeparent.category IN (901, 913) AND recdealtr.currency = 1000001275 THEN
      IF nvo = 0 THEN
        sdesc := DEAL_GetPaymentPurpose('\FOREX\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      ELSE
        sdesc := DEAL_GetPaymentPurpose('\FOREX\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
      ELSIF recdoctreeparent.category IN (901, 913) AND recdealtr.currency != 1000001275 THEN
        sdesc := DEAL_GetPaymentPurpose('\FOREX\5', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
    END IF;
dbms_output.put_line('sdesc02  ='||sdesc);
   -- Депозит

   if recDocTreeParent.Category = 908 then
      -- вид сделки (депозит/кредит) определить по наименованию
      select lower(DealTypeLabel(D.DealType)), DD.IsReceive
         into sDealType, nIsReceive
         from Deal D, DealDeposit DD
         where D.Doc = recDocTree.Parent and DD.Doc = D.Doc;

      -- определить по счету, это осн. сумма или %
      select min(AI.ConstIntention) into nInt
         from DealAccount DA, DealAccIntention AI
         where DA.Doc = recDocTree.Parent and DA.AccIntention =  AI.Classified
            and DA.Account in (select Account from DealTrAccount where Doc = recDocTree.Classified and Amount != 0);

   IF recdoctreeparent.doctype in (1047168347,1047168245) THEN   -- собственно депозитная сделка
      if instr(sDealType, 'кредит') > 0 or instr(sDealType, 'овердр') > 0 THEN
dbms_output.put_line('sdesc0  ='||sdesc);
      if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO40030}'||sdesc ;
                      END IF;
                 elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
dbms_output.put_line('sdesc1  ='||sdesc);
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary  in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO42015}'||sdesc ;
                      END IF;
         elsif nInt in (18, 58) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR  nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO42035}'||sdesc ;
                      END IF;
                 end if;
dbms_output.put_line('sdesc2  ='||sdesc);
      end if;
      else
      if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\5', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\7', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\8', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (18, 58) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\7', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      end if;
      end if;
   ELSIF recdoctreeparent.doctype in (1179850206,1179850377) THEN   -- транши МБК

   dbms_output.put_line('nIsReceive  ='||nIsReceive||'; nInt ='||nInt);

   if nIsReceive = 0 then
         -- размещенный кредит/депозит
         if recDealTr.Amount < 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\21', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            IF (recdealtr.beneficiary in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO40030}'||sdesc ;
                      END IF;
                 elsif recDealTr.Amount >= 0 and nInt in (16, 56) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\22', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         elsif nInt in (17, 57, 35) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\23', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
      else
         -- привлеченный кредит/депозит
         if recDealTr.Amount >= 0 and nInt in (15, 55) then
            sdesc := DEAL_GetPaymentPurpose('\MBC\24', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            dbms_output.put_line('sdesc21  ='||sdesc);
         elsif recDealTr.Amount < 0 and nInt in (15, 55) then
            --sdesc := DEAL_GetPaymentPurpose('\MBC\22', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            if cl is not null then                                  -- 13/06/2013 Панфилов М.С.
              sdesc := DEAL_GetPaymentPurpose('\MBC\32', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            else
              sdesc := DEAL_GetPaymentPurpose('\MBC\33', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            end if;
            IF (recdealtr.beneficiary  in (24763,63979263) OR nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO42015}'||sdesc ;
            END IF;
            dbms_output.put_line('sdesc22  ='||sdesc);
         elsif nInt in (18, 58) then
            -- sdesc := DEAL_GetPaymentPurpose('\MBC\23', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            if cl is not null then                                  -- 13/06/2013 Панфилов М.С.
              sdesc := DEAL_GetPaymentPurpose('\MBC\30', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            else
              sdesc := DEAL_GetPaymentPurpose('\MBC\31', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
            end if;

            IF (recdealtr.beneficiary in (24763,63979263) OR  nvo=0) AND recdealtr.currency = 1000001275 THEN
                        sdesc := '{VO42035}'||sdesc ;
            END IF;
            dbms_output.put_line('sdesc23  ='||sdesc);
         elsif nInt in (79) then                                                            -- 17/03/2014 Панфилов М.С. для комиссий по траншам МБК
            sdesc := DEAL_GetPaymentPurpose('\MBC\35', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
         end if;
dbms_output.put_line('sdesc2  ='||sdesc);
      end if;

   END IF;
   end if;
    -- Неттинг

    IF recdoctreeparent.category = 903 THEN
      SELECT t.counterparty
        INTO nclient
        FROM dealnetting t
       WHERE t.doc = recdoctreeparent.classified;

      IF recdealtr.currency = 1000001275 THEN
        nvo := isclresident(nclient);
        IF nvo = 0 THEN
            sdesc := DEAL_GetPaymentPurpose('\NETTING\1', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        ELSE
            sdesc := DEAL_GetPaymentPurpose('\NETTING\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        END IF;

        IF getobjectcode(nclient, 5) = 'NCCB' THEN
          sdesc := DEAL_GetPaymentPurpose('\NETTING\3', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
        END IF;
      ELSE
        sdesc := DEAL_GetPaymentPurpose('\NETTING\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      END IF;
    END IF;

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 901 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\FOREX\7', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 903 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\NETTING\7', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 908 THEN
    -- Для плановых поступлений

    if getdoctype(recdoctreeparent.PARENT) in (1047168347,1047168245) then
    sdesc := DEAL_GetPaymentPurpose('\MBC\12', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
    elsif getdoctype(recdoctreeparent.PARENT) in (1179850206,1179850377) then                           -- 27/08/2012 Панфилов М.С.
    sdesc := DEAL_GetPaymentPurpose('\MBC\26', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
    end if;

  ELSIF ndoc = 71 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 913 THEN
    -- Для плановых поступлений

    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\1', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND
        getdoccategory(recdoctreeparent.PARENT) = 903 THEN
    -- Для внутренних платежей

    sdesc := DEAL_GetPaymentPurpose('\NETTING\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 901 THEN

    sdesc := DEAL_GetPaymentPurpose('\FOREX\6', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 913 THEN

    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\4', recdoctreeparent.classified,  CONTEXT.currentdoc, null);

  ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND getdoccategory(recdoctreeparent.PARENT) = 908 AND recdoctreeparent.doctype = 1047177856 THEN

    sdesc := DEAL_GetPaymentPurpose('\MBC\9', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);

  /*ELSIF ndoc = 5 AND recdoctreeparent.category = 905 AND getdoccategory(recdoctreeparent.PARENT) = 908 AND recdoctreeparent.doctype != 1047177856 THEN

        select acccode(ACCOUNT) into boacc from bankoper where doc = recDocTree.Classified;                     -- 16/05/2011 Панфилов М.С.

    IF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1047168347) or (recdoctreeparent.doctype = 1047168245) THEN
        sdesc := DEAL_GetPaymentPurpose('\MBC\10', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
    ELSE
        sdesc := DEAL_GetPaymentPurpose('\MBC\11', recdoctreeparent.classified,  CONTEXT.currentdoc, null);     -- 16/05/2011 Панфилов М.С.
    END IF;
  */

  ELSIF ndoc = 5 AND recdoctreeparent.category = 913 AND recDocTree.doctype = 1033718051 THEN      -- 30/06/2011 Панфилов М.С.
dbms_output.put_line('sdesc3  ='||sdesc);
    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\2', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
dbms_output.put_line('sdesc4  ='||sdesc);
  ELSIF (ndoc = 11 or ndoc = 12) AND recdoctreeparent.category = 905  THEN      -- 12/08/2011 Панфилов М.С.
dbms_output.put_line('sdesc5  ='||sdesc);
    sdesc := DEAL_GetPaymentPurpose('\BANKNOTE\3', recdoctreeparent.PARENT,  CONTEXT.currentdoc, null);
dbms_output.put_line('sdesc6  ='||sdesc);
  ELSIF ndoc = 5 AND recdoctreeparent.category = 908 AND recdoctreeparent.doctype != 1047177856 THEN            -- 27/05/2011 Панфилов М.С.
        select acccode(ACCOUNT) into boacc from bankoper where doc = recDocTree.Classified;                     -- 16/05/2011 Панфилов М.С.
    IF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1047168347) or (recdoctreeparent.doctype = 1047168245) THEN
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\10', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\27', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    ELSIF (substr(boacc,1,3) = '474' and recdoctreeparent.doctype = 1179850377) or (recdoctreeparent.doctype = 1179850206) THEN -- 27/08/2012 Панфилов М.С.
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\25', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\28', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    ELSE
      if trim(DealBegProcDate(recdoctreeparent.classified)+1) != trim(Message.dtDate) then
        sdesc := DEAL_GetPaymentPurpose('\MBC\11', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
      else
        sdesc := DEAL_GetPaymentPurpose('\MBC\29', recdoctreeparent.classified,  CONTEXT.currentdoc, null);    -- 13/12/2012 Панфилов М.С.
      end if;
    END IF;

  ELSIF ndoc = 75 AND recdoctreeparent.category = 928 THEN -- внебалансовые кредиты под КЛ МБК -- Панфилов М.С. 02/07/2013
        sdesc := DEAL_GetPaymentPurpose('\MBC\34', recdoctreeparent.classified,  CONTEXT.currentdoc, null);
  ELSE
    sdesc := '';
  END IF;

  UPDATE doctree t
     SET t.description = sdesc
   WHERE t.classified = CONTEXT.currentdoc;


   UPDATE doctree
   SET description = sdesc
   WHERE classified IN (SELECT classified
                              FROM doctree
                             WHERE PARENT = CONTEXT.currentdoc);

END dpc_tcb_desc_for_diling;

create or replace function DEAL_GetPaymentPurpose
/******************************************************************************
 Автор: Цветков В.
 Описание: Получение шаблона строки назначения платежа из PAYMENTPURPOSE по ключу и раскрытие макросов
 24.06.2010 по заданию 2161-У.
 Версия:
 13.11.2010 Доработка 31804: function DEAL_GetPaymentPurpose -
                Исправлено раскрытие макроса <DocOperDate> и <DealDate>(формат)
 19.04.2011 Новые тэги
 16.05.2011 Тэг <TICKET> (тикет сделки)
 27.05.2011 вместо nDoc должен быть nDeal в вызове BEGPROCDATE и в процедуре
            LoadDealNettingRec.
 12.12.2012 добавлен тэг BEGACCRDATE - дата начала начисления процентов (Зам. № 44161, AGN)
 08.02.2013 добавлена возможность прямой распаковки шаблона строки без использования справочника (Дор. № 12438, AGN)
 03.04.2013 Добавлены тэги <PACTLABEL>,<PACTSIGNEDATE>,<NETTDEALS> (Дор. № 12523, AGN)
 19.06.2013 тэг <DealLabel> распаковывается номером сделки, а не номером документа (Зам. № 47090, AGN)

 13.06.2013 Панфилов М.С. добавлены тэги <CLLabel>, <CLVALUEDATE>, <BEGPROCDATE2>
 01.11.2013 Панфилов М.С. добавлен тэг <BEGPROCDATE3>

 14.11.2013 перечисление № сделок неттинга ограничивается 254 символами (Зам. № 49530, AGN)
 
 17.03.2014 Панфилов М.С. добавлен тэг <COMISSNAME>
******************************************************************************/
(  sTemplateCode  DT.Text,            -- Код строки-шаблона
   nDeal          DT.Reference,       -- Сделка
   nDoc           DT.Reference,       -- Документ
   sExtraText     DT.Text,            -- Дополнительный текст
   nDirectExpand  DT.Status default 0 -- прямая распаковка шаблонов строки без справочника
)
return DT.Description
as
   sPurpose       DT.Text;
   recDeal        Deal%rowtype;
   recDocTree     DocTree%rowtype;
   recDealReserv  DealReserv%rowtype;
   recDealROLL    Deal%rowtype;
   recDealDeposit DealDeposit%rowtype;
   recDealNetting DealNetting%rowtype;
   recDealTrans   DealTransaction%rowtype;

   recDocTreeCL   DocTree%rowtype;
   recDealCL      Deal%rowtype;

   recPact        DocTree%rowtype;   -- данные договора с контрагентом
   --
   sCurrTag       Dt.Text;
   sDTFMT         constant Dt.Label := 'DD/MM/YYYY';
   sDTFMT1        constant Dt.Label := 'DD.MM.YY';
   dtDateTemp     Date;
   nDealCategory  DT.Reference;
   --
   procedure LoadDealRec as
      cursor c is select * from Deal where Doc = nDeal;
   begin
      if recDeal.Doc is null then
         open c;
         fetch c into recDeal;
         close c;
      end if ;
   end LoadDealRec;
   --
   procedure LoadDocRec as
      cursor c is select * from DocTree where Classified = nDoc;
   begin
      if recDoctree.Classified is null then
         open c;
         fetch c into recDocTree;
         close c;
      end if ;
   end LoadDocRec;
   --
   procedure LoadDealReservRec as
      cursor c is select * from DealReserv where Doc = nDoc;
   begin
      if recDealReserv.Doc is null then
         open c;
         fetch c into recDealReserv;
         close c;
      end if ;
   end LoadDealReservRec;
   --
   procedure LoadDealRollRec as
      cursor c is select * from Deal where Doc =
         (select Deal from DealRollover where Doc = nDeal);
   begin
      if recDealRoll.Doc is null then
         open c;
         fetch c into recDealRoll;
         close c;
      end if ;
   end LoadDealRollRec;
   --
   procedure LoadDealDepositRec as
      cursor c is select * from DealDeposit where Doc = nDeal;
   begin
      if recDealDeposit.Doc is null then
         open c;
         fetch c into recDealDeposit;
         close c;
      end if ;
   end LoadDealDepositRec;
   --
   procedure LoadDealNettingRec as
      cursor c is select * from DealNetting where Doc = nDeal;--nDoc;
   begin
      if recDealNetting.Doc is null then
         open c;
         fetch c into recDealNetting;
         close c;
      end if ;
   end LoadDealNettingRec;
   --
   procedure LoadDealTransRec as
      cursor c is select * from DealTransaction where Doc = nDoc;
   begin
      if recDealTrans.Doc is null then
         open c;
         fetch c into recDealTrans;
         close c;
      end if ;
   end LoadDealTransRec;
   --

   procedure LoadDocCLRec as
      cursor c is select * from DocTree where Classified = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDocTreeCL.Classified is null then
         open c;
         fetch c into recDocTreeCL;
         close c;
      end if ;
   end LoadDocCLRec;
   --
   procedure LoadDealCLRec as
      cursor c is select * from Deal where Doc = (select CREDITLINE from Deal where Doc = nDeal);
   begin
      if recDealCL.Doc is null then
         open c;
         fetch c into recDealCL;
         close c;
      end if ;
   end LoadDealCLRec;

   --
   procedure LoadPact as
      cursor c1 is select * from Doctree where Classified in (select Pact from DealNetting where Doc = nDeal);
      cursor c2 is select * from Doctree where Classified in (select Pact from Deal where Doc = nDeal);
   begin
      if recPact.Classified is null then
         if nDealCategory = 903 then
            open c1;
            fetch c1 into recPact;
            close c1;
         else  -- считаем что некая сделка.
            open c2;
            fetch c2 into recPact;
            close c2;
         end if;
      end if;
   end LoadPact;
   --
   function loc_GetNettDeals
   return DT.Description is
      sDeals    DT.Description;
   begin
      for rec in (select unique D.Label     -- сделки события неттинга
                    from DealTransaction T, Doctree DCT, Doctree D
                   where T.Payment = nDoc
                     and T.Doc = DCT.Classified
                     and DCT.Classified not in (Constants.State_Cancel, Constants.State_RollBack)
                     and DCT.Parent = D.Classified
                  )
      loop
         begin
            sDeals := sDeals||rec.Label||',';
         exception when others then
            exit;
         end;
      end loop;
      if sDeals is not null then
         -- уберем лишний символ
         sDeals := substr(sDeals, 1, length(sDeals)-1);
      end if;
      return sDeals;
   end loc_GetNettDeals;
begin
   nDealCategory := GetDocCategory(nDeal);
   if nDirectExpand = 1 then
      sPurpose := sTemplateCode;
   else
      begin
         select value into sPurpose from dealpaymentpurpose where fullname = sTemplateCode;
      exception when NO_DATA_FOUND then
         --raise_application_error(-20000, 'Шаблон не найден. Код ' || sTemplateCode) ;
         tm_proc.RaiseError(42212, sTemplateCode);
      end;
   end if;
   if sPurpose is null then
      return null;
   end if;
   -- dbms_output.put_line('1 ' || spurpose);
   sCurrTag := '<DealLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      -- LoadDocRec;
      LoadDealRec;
      sPurpose := replace(sPurpose, sCurrTag, DoctreeLabel(recDeal.Doc));
   end if ;
   -- dbms_output.put_line('2 ' || spurpose);

   sCurrTag := '<DealDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      -- sPurpose := replace(sPurpose, sCurrTag, recDeal.DealDate); --to_char(recDeal.DealDate,'DD.MM.YYYY'));
      sPurpose := replace(sPurpose, sCurrTag, to_char(recDeal.DealDate,sDTFMT));
   end if ;
   -- dbms_output.put_line('3 ' || spurpose);

   sCurrTag := '<ExtraText>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      sPurpose := replace(sPurpose, sCurrTag, sExtraText);
   end if ;

   -- dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDocRec;
      sPurpose := replace(sPurpose, sCurrTag, recDocTree.Label);
   end if ;
   -- dbms_output.put_line('4 ' || spurpose);

   sCurrTag := '<DocDescription>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDocRec;
      sPurpose := replace(sPurpose, sCurrTag, recDocTree.Description);
   end if ;
--   dbms_output.put_line('5 ' || spurpose);

   sCurrTag := '<DocOperDate>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--        LoadDocRec;
--        sPurpose := replace(sPurpose, sCurrTag, recDocTree.OperDate);
      sPurpose := replace(sPurpose, sCurrTag, to_char(Message.dtDate,sDTFMT));
   end if ;

--   dbms_output.put_line('6 ' || spurpose);

   sCurrTag := '<RiskGroup>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDocRec;
      if recDocTree.Category = 914 then
         LoadDealReservRec;
         sPurpose := replace(sPurpose, sCurrTag, PactRiskGrouplabel(NVL(recDealReserv.RiskGroup, recDealReserv.OldRiskGroup)));
      else
         sPurpose := replace(sPurpose, sCurrTag, '');
      end if;
   end if ;
   -- dbms_output.put_line('7 ' || spurpose);

   sCurrTag := '<COUNTERPARTY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDeal.CounterParty));
         --dbms_output.put_line('8 ' || spurpose);
   end if ;

   sCurrTag := '<TICKETROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRollRec;
      sPurpose := replace(sPurpose, sCurrTag, recDealRoll.Ticket);
--dbms_output.put_line('9 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYROLL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRollRec;
      sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealRoll.CounterParty));
--dbms_output.put_line('10 ' || spurpose);
   end if ;

   sCurrTag := '<ROLLDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealDepositRec;
      sPurpose := replace(sPurpose, sCurrTag, to_char(recDealDeposit.RollOverStartDate,sDTFMT));
--dbms_output.put_line('11 ' || spurpose);
   end if ;

   sCurrTag := '<OPERDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
--    LoadDocRec;
      sPurpose := replace(sPurpose, sCurrTag, to_char(Message.dtDate,sDTFMT1));
      --dbms_output.put_line('12 ' || spurpose);
   end if ;

   sCurrTag := '<EXTRACT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDocRec;
      sPurpose := replace(sPurpose, sCurrTag, recDocTree.Extract);
      --dbms_output.put_line('13 ' || spurpose);
   end if ;

   sCurrTag := '<TRANSACTDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      sPurpose := replace(sPurpose, sCurrTag, to_char(recDeal.DealDate,sDTFMT1));
      --dbms_output.put_line('14 ' || spurpose);
   end if ;

   sCurrTag := '<VALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealNettingRec;
      sPurpose := replace(sPurpose, sCurrTag, to_char(recDealNetting.ValueDate,sDTFMT1));
      --dbms_output.put_line('15 ' || spurpose);
   end if ;

   sCurrTag := '<COUNTERPARTYNET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealNettingRec;
      sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealNetting.CounterParty));
      --dbms_output.put_line('16 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARYBANK>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealTransRec;
      sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealTrans.BeneficiaryBank));
      --dbms_output.put_line('17 ' || spurpose);
   end if ;

   sCurrTag := '<BENEFICIARY>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealTransRec;
      sPurpose := replace(sPurpose, sCurrTag, ClientLabel(recDealTrans.Beneficiary));
--dbms_output.put_line('18 ' || spurpose);
   end if ;

   sCurrTag := '<BEGPROCDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate(nDeal),sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;
   -- дата начала начисления %%
   sCurrTag := '<BEGACCRDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealRec;
      dtDateTemp := trunc(DealBegProcDate(nDeal)); -- дата последнего начисления %%
      if dtDateTemp > recDeal.ValueDate + 1 then
         dtDateTemp := dtDateTemp + 1;
      else
         dtDateTemp := recDeal.ValueDate + 1;
      end if;
      sPurpose := replace(sPurpose, sCurrTag, to_char(dtDateTemp,sDTFMT));
--dbms_output.put_line('19 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONAMOUNT>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealTransRec;
      sPurpose := replace(sPurpose, sCurrTag, recDealTrans.Amount);
      --dbms_output.put_line('20 ' || spurpose);
   end if ;

   sCurrTag := '<DEALTRANSACTIONVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDealTransRec;
      sPurpose := replace(sPurpose, sCurrTag, to_char(recDealTrans.ValueDate,sDTFMT));
      --dbms_output.put_line('21 ' || spurpose);
   end if ;

   sCurrTag := '<DOCTREEDOCVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadDocRec;
      sPurpose := replace(sPurpose, sCurrTag, to_char(recDocTree.DocValueDate,sDTFMT));
      --dbms_output.put_line('22 ' || spurpose);
   end if ;
   --тикет сделки (Deal.TICKET)
   sCurrTag := '<TICKET>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealRec;
        sPurpose := replace(sPurpose, sCurrTag, recDeal.Ticket);
   end if ;


   --кредитная линия по траншу (Deal.CREDITLINE.Label)
   sCurrTag := '<CLLabel>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDocCLRec;
        sPurpose := replace(sPurpose, sCurrTag, recDocTreeCL.Label);
   end if ;

   --дата начала кредитной линии по траншу (Deal.CREDITLINE.VALUEDATE)
   sCurrTag := '<CLVALUEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        LoadDealClRec;
        sPurpose := replace(sPurpose, sCurrTag, to_char(recDealCL.ValueDate,sDTFMT));
   end if ;

   --дата начала предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE2>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate2(nDeal),sDTFMT));
   end if ;

   --дата окончания предыдущего периода начисления %% по траншу
   sCurrTag := '<BEGPROCDATE3>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        to_char(DealBegProcDate3(nDeal),sDTFMT));
   end if ;


   -- номер договора с контрагентом
   sCurrTag := '<PACTLABEL>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadPact;
      sPurpose := replace(sPurpose, sCurrTag, recPact.Label);
   end if;
   -- дата начала действия договора с контрагентом
   sCurrTag := '<PACTSIGNEDATE>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      LoadPact;
      sPurpose := replace(sPurpose, sCurrTag, to_char(recPact.ValidFromDate,sDTFMT));
   end if ;
   -- сделки входящие в неттинг
   sCurrTag := '<NETTDEALS>';
   if INSTR(sPurpose, sCurrTag) > 0 then
      sPurpose := replace(sPurpose, sCurrTag, loc_GetNettDeals);
   end if;
   
   -- 17/03/2014 Панфилов М.С. наименование соответствующей комиссии
   sCurrTag := '<COMISSNAME>';
   if INSTR(sPurpose, sCurrTag) > 0 then
        sPurpose := replace(sPurpose, sCurrTag,
                        DealTrNameAssocCom_TCB(nDoc));
   end if ;
   
   return substr(sPurpose, 1, 254);
end DEAL_GetPaymentPurpose;





DealDep_proc.DealDepCommissEvents

select * from dealaccintention where classified in (
1000105424,
1000105427,
1000105430,
1108915750
)

elsif (nInt = 79)

select * from dealaccount where doc = parentdoc(258125716)

select * from doctree where classified = 256089828

select * from dealtransaction where doc = 258125716
select * from dealtraccount where doc = 258125716

select * from account where type in (1000064947,1000064955)

-- поправить подстановку счетов 70613/70414 в процедуре UT_DealCalcTSS_TCB (когда остатка на 526 счетах еще нет, то проводки должны генериться такие
-- если доход, то Дт:52601 Кт70613; если расход, то Дт70614 Кт52602) => поправил UT_DealCalcTSS_TCB                                                                ++

od.UT_DealCalcTSS_TCB

----------------------------------------------------------------------------------
--18/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

BBR_TCB_UNIV_RTF

 SELECT * FROM BlankList
 WHERE /*Reporter = 2 AND Editable = 0 AND */upper(Label) = upper('Распоряжение по векселям (погашение)')
 
  INSERT INTO BlankList( Classified, Label, FileName, Description, IsWork, Editable, Reporter, Type )
 VALUES( 1338457178, 'Распоряжение по векселям (погашение)', 'BBR_TCB_BILL_RASP_OPER_POG', 'отчет по распоряжениям Векселя (погашение)
IPI 74016 /Панфилов М.С./', 1, 0, 2, 0 )

SELECT rowid, d.* -- Classified, Label, FileName, DECODE( IsWork, 1, 'Да', 'Нет' )
 FROM BlankList d
 WHERE Editable = 0 AND Reporter = 2
   AND FileName = 'BBR_TCB_BILL_RASP_OPER_POG' 
  ORDER BY 3 ASC

select * from bill where num  = '0021196'

----------------------------------------------------------------------------------
--20/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- поправить UT_DealCalcTSS_TCB                                                                                                                                  ++
od.UT_DealCalcTSS_TCB

declare
sacccode varchar(50);

begin 
SELECT od.acccode(t.nostro)
   --INTO sacccode
   FROM dealtransaction t
   WHERE t.doc = 256597006
   
   SELECT od.acccode(t.nostro)
   --INTO sacccode
   FROM dealtransaction t
   WHERE t.doc = 256597006
 
   od.FXEvent_Doc
   
   select od.acccode(49339627) from dual
 
IF substr(sacccode, 1, 5) = '30109' 
    THEN :ncondresult := 1;
    ELSE  :ncondresult := 0 ;
END IF ;
end ;

----------------------------------------------------------------------------------
--21/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- сделать для Ледовской справочник "Вид продукта МБК (вн.)" (сначала на athena3)                                                                                ++
-- сделать таблицу tcb_mbk_product_type_in с триггером tcb_mbk_product_type_in, синонимами и грантами                                                            ++
-- завести словарь в manager                                                                                                                                     ++
-- в справочниках общего назначения добавить "Вид продукта МБК (вн.)", дать права                                                                                ++
-- сделать под справочник "Вид продукта МБК (вн.)" доп. описание и навесить его на депозитные сделки и транши привлечения (-1353)                                ++

select * from DealPortfolio 
select * from tcb_mbk_product_type_in
od.psb_counterparty_accounts
od.BANKOPERCONV_TCB
od.BIC_DIR_LOAD_CCH_TCB
select * from od.CASHPLAN_TCB
CREATE TABLE tcb_bki_mbk_tbl 

select* from tcb_mbk_product_type_in


CREATE TABLE tcb_mbk_product_type_in 
    (classified                     number(10,0) NOT NULL,
     label 	                        VARCHAR2(50) NOT NULL, 
	   description                    VARCHAR2(254), 
	   PRIMARY KEY ("CLASSIFIED")
     )
/
COMMENT ON TABLE tcb_mbk_product_type_in IS 'Вид продукта МБК (вн.)'
/
create or replace trigger t_tcb_mbk_product_type_in
before insert  on tcb_mbk_product_type_in
for each row
begin
      if :new.Classified is null or :new.Classified=0 then
         select Classified.nextval into :new.Classified from dual;
      end if;
   
end;
/
CREATE OR REPLACE SYNONYM "PUBLIC"."TCB_MBK_PRODUCT_TYPE_IN" FOR "OD"."TCB_MBK_PRODUCT_TYPE_IN";
/
CREATE OR REPLACE SYNONYM "REPORT"."TCB_MBK_PRODUCT_TYPE_IN" FOR "OD"."TCB_MBK_PRODUCT_TYPE_IN";
/
  GRANT SELECT ON "OD"."TCB_MBK_PRODUCT_TYPE_IN" TO "RPT_LIB_TCB";
  /
  GRANT SELECT ON "OD"."TCB_MBK_PRODUCT_TYPE_IN" TO "REPORT";
  /
  GRANT UPDATE ON "OD"."TCB_MBK_PRODUCT_TYPE_IN" TO PUBLIC;
  /
  GRANT SELECT ON "OD"."TCB_MBK_PRODUCT_TYPE_IN" TO PUBLIC;
  /
  GRANT INSERT ON "OD"."TCB_MBK_PRODUCT_TYPE_IN" TO PUBLIC;
  /
  GRANT DELETE ON "OD"."TCB_MBK_PRODUCT_TYPE_IN" TO PUBLIC;
  /


select * from All_Objects WHERE Object_Type IN ( 'TABLE', 'VIEW' )
select * from All_Synonyms where /*S.OWNER='PUBLIC' AND */ TABLE_NAME = 'CASHPLAN_TCB' -- 'TCB_MBK_PRODUCT_TYPE_IN'-- 'TCB_BKI_MBK_TBL'

SELECT DISTINCT O.Object_ID, S.Synonym_Name
 FROM All_Objects O, All_Synonyms S 
 WHERE O.Object_Type IN ( 'TABLE', 'VIEW' ) AND UPPER( S.Synonym_Name ) LIKE '%CASHPLAN_TCB%' ESCAPE '\'  AND S.OWNER='PUBLIC' AND S.TABLE_NAME= O.OBJECT_NAME  
  ORDER BY Synonym_Name
  
select * from tcb_mbk_product_type_in

select * from objenum where enumtype = 1054090600
select * from enumtype where classified = /*1054090601*/ 1054090600
select * from desclist
select * from proplist
  
----------------------------------------------------------------------------------
--24/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 258877298
select * from doctree where doctype = 1065679950

select rowid, b.* from bill b where num = '0001272'

select * from riskgroup = 1000063415

od.Bill_ReserveSum
od.dpc_billoper

select GetBillReserveSum(1299656323) from dual

select* from BillRiskGroup where bill = 1299656323

select * from billaccount 
select * from billaccintention
od.getbillaccount

select count(billgroup),  count(bill), account from billaccount where accintention = 1011996332 group by account
select * from billaccount where accintention = 1011996332 

select * from bill where num = '0001272'
select rowid, b.* from billaccount b where bill = 1299656323
select * from billsum where bill = 1299656323

select * from balance where account = 244825089

select * from account where code = '51405840900300201272' = 251830077

-- проблема со счетами при повторном переучете векселя (в Питере) => по векселю '0001272' удалил двойную привязку счета к векселю с периодом (по просьбе Волкорезова) ++
-- => позвонить Громовой, настроить привязку счетов к группе "USD Россия"                                                                                        
select * from doctree where classified in (244824419, 251535392, 252013871)

select * from billsumtype
select * from billoper

select * from bill where num = '0324682'
select rowid, b.* from billaccount b where bill = 1230893713

select * from doctree where classified in(
248137355,
251535392,
255928429
)

----------------------------------------------------------------------------------
--25/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------
od.DPC_BillOper
select * from doccategory
select * from bill 

BBR_TCB_BILL_RASP_OPER_POG

select * from BlankList

-- для Антиповой Е.С. сделал шаблоны BBR_TCB_BILL_RASP_OPER_POG и BBR_TCB_BILL_RASP_OPER документарными (сравнить с Бахавчуком)                                    

----------------------------------------------------------------------------------
--26/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.tcb_loan_pkg.isDocReal
select * from billaccintention

bbr.bbr_tcb_bill_oper_msk

----------------------------------------------------------------------------------
--27/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billaccintention
select* from billaccount

select * from billaccount

od.DPC_CHECKCLIENTACCOUNT

select acc.*
     from Account ACC --, Doctree DT
    where /*ACC.Doc = DT.Classified
      and*/ ACC.Client = ( select Classified from Client where Doc = 248770472)
     -- and DT.DocState not in (Constants.State_RollBack, Constants.State_Cancel, Constants.State_Close);

----------------------------------------------------------------------------------
--28/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from balance where account in (select classified from account where code = '52501978000000028529') 

select * from billsum where bill in (select classified from bill where num = '0028529')
od.accrest
select * from doctree where classified in (255662251,259604040)

select * from bbook

od.FUNC_BILL_DISCUNDEF
od.FUNC_BILL_DISCACCR_TCB

select * from billsumtype where classified in (1011996478,
1042775365
)

select * from billsum where bill in (select classified from bill where num = '070518') -- 37221,59

select 500000 - 446219.210 from dual -- 53780,79

select 53780.79 - 37221.59 from dual

select * from doctree where classified = 105625365

select GetBillHoldingsDiscSum(1102766011,td) from dual --  16559,2

select DiscSum_TCB2014(1102766011,td) from dual

select decode(4,4,1,4) from dual

-- по задаче IPI 81298 правил отчеты BBR_TCB_BILL_EXCHANGE_ACT и BBR_TCB_BILL_DOSR_ACT => отчеты сохранены в файлах, пока сделал только наименование банка спец.
-- для Питера, осталось разхардкодировать "адрес" (SBANKADDRESS2) , "суд" (SCITY2), "должность" (SDOLG2) и "гл.бухгалтера" (SFIO2) 
-- еще вопросы у Теплякова => 18/04/2014 закрыл задачу                                                                                                                ++

BBR_TCB_BILL_DOSR_ACT                                                                                                                                       

select * from TCB_Univ_Report

bbr.BBR_TCB_BILL_EXCHANGE_ACT
bbr.BBR_TCB_BILL_DOSR_ACT

bbr.BBR_TCB_BILL_EXCHANGE_ACT

bbr.BBR_TCB_BILL_DOSR_ACT

select * from client where classified = 157836918 

begin
 select o.Assoc /*into nCliPod1*/ from BillOper b, ObjAssoc o
  where nvl(o.ValidToDate,to_date('01/01/4444','DD/MM/YYYY')) > td
   and nvl(o.ValidFromDate,to_date('01/01/1998','DD/MM/YYYY')) <= td
   and o.Category = 49
   and o.Obj = b.client
   and b.doc = 259398266
   and RowNum <= 1
  order by o.Classified;
exception when OTHERS then
 nCliPod1 := NULL;
end;
  select GetQuestCodeValue('PactAttribute','Working',doc), -- äîëæíîñòü â ðîä. ïàäåæå
       GetQuestCodeValue('PactAttribute','SWork',doc), -- äîëæíîñòü êðàòêî
       GetQuestCodeValue('PactAttribute','FIO',doc), -- ÔÈÎ â ðîä. ïàäåæå
       GetQuestCodeValue('PactAttribute','NUM',doc), -- íîìåð äîâåðåííîñòè
       to_date(GetQuestCodeValue('PactAttribute','DATE',doc),'dd.mm.yyyy hh24:mi:ss'), -- äàòà äîâåðåííîñòè
       GetQuestCodeValue('PactAttribute','sFIO',doc)
  /*into sCliDolgKr,
       sCliDolg,
       sCliFioLabel,
       sCliDovNumber,
       dtCliDovDate,
       sCliFio*/
   from client where doc = 157836918
  sCliLico := sCliDolgKr||' '||sCliFioLabel;

select * from od.assoclist
select * from doctree where classified = 259398266

-- Äàííûå î êëèåíòå

select * from client where classified = 99418614

select c.label, clientaddress(c.doc), od.GetClientCode(c.doc,20), od.GetClientCode(c.doc,25), c.Executives
into sOrganization, sClientAddress, sClientINN, sClientKPP, sCliLico
from client c, billoper bo
where bo.doc = nDoc and c.doc = bo.client;

if instr(sCliLico,'Ãë. áóõãàëòåð') > 0 then
 sCliLico := substr (sCliLico, 1, instr(sCliLico,'Ãë. áóõãàëòåð') - 1);
end if;
sCliFio := sCliLico;

begin
 select b.BeneficiaryAccount, od.GetClientCode(b.BeneficiaryBank,7), c.Label, r.Code
 into sAccCli, sBikCli, sBankCli, sKsCli
  from BillOperBenef b, Client c, ClBankRel r where r.Relation = 1000002508 and r.ClBank = b.BeneficiaryBank
   and c.Doc = b.BeneficiaryBank and b.Doc = nDoc;
exception when OTHERS then
 begin
  select a.Code into sAccCli from account a, billoper bo
  where nvl(a.Opened,to_date('01/01/1998','DD/MM/YYYY')) <= dtDateDoc
   and nvl(a.Closed,to_date('01/01/4444','DD/MM/YYYY')) > dtDateDoc
   and a.Type = 1000002445 and a.Client = bo.client and bo.doc = nDoc and ROWNUM <= 1;
  sKsCli := sBankNostroAcc;
  sBikCli := sBik;
  sBankCli := sBankLabel;
 exception when OTHERS then
  begin
   select c.Code, od.GetClientCode(c.CorrClBank,7), ClientLabel(c.CorrClBank), r.Code
    into sAccCli, sBikCli, sBankCli, sKsCli from ClBankRel c, billoper bo, ClBankRel r
    where r.Relation = 1000002508 and r.ClBank = c.CorrClBank
     and nvl(c.OpenDate,to_date('01/01/1998','DD/MM/YYYY')) <= dtDateDoc
     and nvl(c.CloseDate,to_date('01/01/4444','DD/MM/YYYY')) > dtDateDoc
     and c.Relation = 1000002445 and c.ClBank = bo.client and bo.doc = nDoc and ROWNUM <= 1;
  exception when OTHERS then
   sAccCli := '';
   sKsCli := '';
   sBikCli := '';
   sBankCli := '';
  end;
 end;
end;
       
       
       
       select * from client where doc = 1

-- сделал функцию для отчетности Волкорезова                                                                                                                       ++
create or replace function DiscSum_TCB2014(
-- Сумма дисконта по векселю, расчитанная на заданную дату (на основе bill_p.DiscSum_TCB)
-- 28/03/2014 Панфилов М.С. 
   nBill       DT.Reference, -- вексель
   dtOperDate  date,         -- дата расчета
   nRedisc     dt.Status  default null  --  признак переучета
) return DT.Relation as
   nBillSum       Bill.BillSum%type;       --  номинал вексел
   nBillCurr      Bill.BillCurrency%type;  --  валюта весел
   nMaker         Bill.Maker%type;         --  векселедатель
   nPayDateVar    Bill.PayDateVar%type;       --  номинал вексел
   nBillDisc      DT.Amount;     --  дисконт учета весел
   nDoc           DT.Reference;  --  документ учета вексел
   nTimeTotal     DT.Quantity; -- кол-во дней в периоде начисления дисконта
   nTime          DT.Quantity; -- кол-во дней от начала периода начисления дисконта до рассчетной даты
   dtDiscFrom     date;        -- дата начала периода расчета дисконта (дата выдачи/учета векселя)
   dtDiscTo       date;        -- дата конца периода расчета дисконта (дата погашения)
   dtDate1        date;        -- Bill.Date1
   dtDate2        date;        -- Bill.Date2
   dtPresentDate  date;        -- Bill.Date2
   nOurBank       DT.Reference;
   nDiscSum       DT.Relation;
   nDate1Year     DT.Status;
begin
   select BillSum, BillCurrency, Maker, Date1, Date2, PayDateVar, PresentDate, OurBank
     into nBillSum, nBillCurr, nMaker, dtDate1, dtDate2, nPayDateVar, dtPresentDate, nOurBank
     from Bill B, Preference P
    where B.Classified = nBill and B.SysFilial = P.SysFilial(+);
    
   if nMaker = nvl(nOurBank, Pref.OurBank) then  --  собственный вексель
      -- Документ и дисконт выдачи вексел
      bill_p.Get_BillSum(nBill, bill_p.SumTypeClassified(11), nBillDisc, nDoc);
   else   --   чужой вексель
      -- Документ и цена учета вексел
      bill_p.Get_BillSum(nBill, bill_p.SumTypeClassified(23), nBillDisc, nDoc);
      -- Дисконт при учете векселя.
      nBillDisc := nBillSum - nBillDisc;
   end if;
--dbms_output.put_line('Вексель ' || BillLabel(nBill) || ' дисконт ' || nBillDisc);
   if nBillDisc > 0 and nDoc > 0 then
--dbms_output.put_line('Выдача/учет: дисконт ' || nBillDisc || ' документ ' || nDoc);
      select trunc(OperDate) into dtDiscFrom from DocTree where Classified = nDoc;
      nDate1Year := to_number(Registry.GetValue('\Bill\RepayDate1Year'));
      if nDate1Year = 1 or nDate1Year = 2 and nRedisc is null then
         if nPayDateVar in (4, 3) or nPayDateVar = 2 and dtPresentDate is not null then
            dtDiscTo := bill_p.RepayDate(nBill);
         else
            if dtDate2 is not null then
               dtDiscTo := dtDate2;
            elsif dtDate1 is not null then
               dtDiscTo := dpGeneral.AddInterval(dtDate1, 9, 1);
            else
               dtDiscTo := dpGeneral.AddInterval(dtDiscFrom, 9, 1);
            end if;
         end if;
      else
         dtDiscTo := bill_p.RepayDate(nBill);
         if dtDiscTo is null then  --  для векселей по предъявлении - год с даты составлени
            dtDiscTo := nvl(dtDate2, dpGeneral.AddInterval(dtDiscFrom, 9, 1));
         end if;
      end if;
      bill_p.DateDiff(nTime, dtDiscFrom, trunc(dtOperDate));  -- дней в периоде расчета
      bill_p.DateDiff(nTimeTotal, dtDiscFrom, dtDiscTo);      -- дней во всем периоде начисления дисконта
--dbms_output.put_line('Период:  всего ' || nTimeTotal || ' расчета ' || nTime);
      if nTimeTotal > 0 and nTime > 0 then
         nDiscSum := least(nBillDisc, round(nBillDisc * nTime/nTimeTotal, MinorUnit(nBillCurr)));
         if nMaker = 65184944 and trim(dtDate1) = to_date('26/05/2008','dd/mm/yyyy') then -- 28/03/2014 Панфилов М.С. 
                begin
                select sum(Amount) into nBillDisc from BillSum bs
                where Bill = nBill and sumtype = nvl( bill_p.SumTypeClassified(30),0) and doc in (select classified from doctree where bs.doc = classified and trim(operdate) <= dtOperDate);
                exception when others then nBillDisc := 0;
                end;
           nDiscSum := nBillDisc;
         end if;
      end if;
   end if;
   return nvl(nDiscSum, 0);
end DiscSum_TCB2014;




SELECT OurBank
FROM Preference
WHERE SysFilial = decode(4,4,1,4)

----------------------------------------------------------------------------------
--31/03/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select* from billoper where doc = 260427877

select * from billsum where bill = (select classified from bill where num = '0031593')

select * from doctree where classified = 1011996370

select * from billsumtype where classified = 1011996370

select * from objprop
select * from objdesc
select to_number('12') from dual

selec

-- поправить od.DPC_BillSumCorrectionDisc_TCB на предмет того, что, если в одну досрочку включать векселя с доп.атрибутом
-- и векселя без доп.атрибута, то сумма операций векселей без атрибута не попадает в общую сумму операции                                                         ++
create or replace procedure DPC_BillSumCorrectionDisc_TCB
/******************************************************************************
 Изменение суммы операции по непроцентному векселю (коррекция цены для досрочного выкупа по ставке досрочного учета векселя)
 для пермских непроцентных векселей, которые выдются по номиналу
 Дата: 16/07/2013
 Автор: Панфилов М.С.
 -- 16/08/2013 Панфилов М.С. - встроил проверку дисконтный вексель или нет
 -- 19/09/2013 Панфилов М.С. - поправил косяк, который нашла Епанова
 -- 31/03/2014 Панфилов М.С. - если в наборе есть векселя и без доп.описания, то теперь их цены также поппадают в общую сумму
******************************************************************************/
as
  psum           dt.Amount;
  allsum         dt.Amount := 0;                -- вся сумма по операции
  sPerc          objdesc.desctext%type;         -- процентная ставка дисконта из доп.описания
  nPerc          billrange.percentsum%type;     -- процентная ставка дисконта из доп.описания
  dateend        date;                          -- дата погашения векселя
  T              dt.Quantity;                   -- срок, оставшийся до погашения
  nPercent       Bill.Percent%type;
begin
  dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB ->');

  for rec in (select br.*, b.billsum, b.paydatevar, b.date1, b.date2, b.DRAWDATE, b.time from BillRange br, bill b where br.Doc = CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      nPercent := 0;
      select nvl(Percent,-1) into nPercent from Bill where Classified = rec.bill;
      if nPercent < 0 then -- 16/08/2013 Панфилов М.С. - встроил проверку дисконтный вексель или нет
      begin
        psum  := null;
        sPerc := null;
        nPerc := null;
        dateend := null;
        T := null;

      -- проверяем доп.описание
      begin
      select value into sPerc from ENUMTYPEVALUE where classified in (select ENUMTYPEVALUE from OBJENUM where enumtype = (select classified from enumtype where constenum = -5000) and obj = rec.bill);

      nPerc := sPerc;
      dbms_output.put_line('sPerc -> ' || sPerc);
      exception
             when others then null;
      end;

      -- если доп.описание есть
      if nPerc is not null then
      -- вычислим срок, оставшийся до погашения
      begin
                  select CASE
                  WHEN rec.paydatevar = 1 AND rec.date2 IS NOT NULL THEN
                   rec.date1
                  WHEN rec.paydatevar = 1 AND rec.date1 IS NOT NULL THEN
                   rec.date1
                  WHEN rec.paydatevar = 4 THEN
                   rec.date1
                  when rec.paydatevar = 1 and rec.date1 is null and rec.date2 is null then
                   rec.DRAWDATE
                    when rec.paydatevar = 3 then
                   rec.DRAWDATE + rec.time
                  ELSE
                   null
                  END into dateend from dual;
                  dbms_output.put_line('dateend -> ' || to_char(dateend,'dd.mm.yyyy'));
                  T := trunc(dateend) - trunc(CONTEXT.OperDate);
                  dbms_output.put_line('T -> ' || T);
      exception
        when others then null;
      end;
      -- вычислим сумму дисконта по новой ставке nPerc
      psum := round(rec.billsum*(1-T*nPerc/36500),MinorUnit(GetBillCurrency(rec.bill)));
      update BillRange set rowprice = psum where bill = rec.bill and Doc=CONTEXT.CurrentDoc; -- 19/09/2013 Панфилов М.С. - поправил косяк, который нашла Епанова
      allsum := allsum + psum;
      dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB ' || psum);
      else                                                                                   -- 31/03/2014 Панфилов М.С. - если в наборе есть векселя и без доп.описания, то теперь их цены также поппадают в общую сумму
        select rowprice into psum from BillRange where bill = rec.bill and Doc=CONTEXT.CurrentDoc; 
        allsum := allsum + psum;
      end if;
      exception
        when others then null;
      end;
    end if;
  end loop;
  update BillOper set OperSum=allsum, SumFrom=allsum, SumTo=allsum where Doc=CONTEXT.CurrentDoc;

dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB <- ');
exception
  when others then null;
end DPC_BillSumCorrectionDisc_TCB;

od.DPC_BillSumCorrection_TCB

-- проблема у Бахавчука с суммой FUNC_BILL_ACCRUALADD_TM_TCB (досрочный выкуп в 31/03/2014, когда проценты уже начислены)  => проблема решена 10/04/2014
-- исправлением в FUNC_BILL_ACCRUALRETURN_TY_TCB 

----------------------------------------------------------------------------------
--01/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.UT_DEALACCRUAL
od.UT_DealAccrual_EveryDayFT_TCB
od.UT_DealAccrual_EveryDay00_TCB

-- проставил для Молодовой галку "Передача в репозитарий отдельно по сделке"                                                                                      ++
declare
begin
  objattr.SaveOneProp(258532476,258532476,objattr.propclass(-2002),1);
  objattr.SaveOneProp(258776460,258776460,objattr.propclass(-2002),1);
end;


-- изменил привязку сертификатов к векселям для Калашниковой                                                                                                      ++
select * from bill where num = '0039283' 
select * from bill where num = '0039284'
select * from bill where num = '0039285'
select * from bill where num = '0039269'
select * from bill where num = '0039270'

update bill set syscertificate = null where classified = 1344468591
update bill set syscertificate = 1344468582 where classified = 1344341506

update bill set syscertificate = null where classified = 1344468594
update bill set syscertificate = 1344468592 where classified = 1344341509

update bill set syscertificate = null where classified = 1344468596
update bill set syscertificate = 1344468595 where classified = 1344341512

update bill set syscertificate = null where classified = 1344469316
update bill set syscertificate = 1344469315 where classified = 1344333749

update bill set syscertificate = null where classified = 1344469450
update bill set syscertificate = 1344469449 where classified = 1344340383

----------------------------------------------------------------------------------
--02/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

bbr.BBR_COUNTSUMM_DILING_TCB
bbr.BBR_SUMM_VAL2_CONV_TCB

tp_account_tcb

-- по задаче IPI 183090 сделал отчет BBR_SUMM_VAL2_CONV_TCB (пересоздавать его нельзя!!! иначе отвалится возможность запускать отчет по более чем 351 документу)  ++

select * from deal

  CREATE OR REPLACE TYPE T_BBR_SUMM_VAL_CONV_TCB IS TABLE OF number(10);
  GRANT EXECUTE ON "OD"."T_BBR_SUMM_VAL_CONV_TCB" TO "BBR";

select max(classified) from doctree where  

declare
nDoc dt.ClassType;
cl dt.Reference;
begin
select * from TABLE(CAST(nDoc as t_for_BBR_SUMM_VA_TCB));

      dbms_output.put_line('DPC_BillSumCorrectionDisc_TCB <- ');
      
end;

declare
sSQLb DT.Text;
function prepareSQLBay return DT.Text is
      sSQL      DT.Text;
      InnerMass od.T_BBR_SUMM_VAL_CONV_TCB := od.T_BBR_SUMM_VAL_CONV_TCB();
begin

--nPos := nDoc.First;

--while nPos <=  nDoc.Last 
--loop
--InnerMass.EXTEND(nDoc(nPos));
InnerMass.EXTEND;
InnerMass(1) := 1;
--end loop;

      sSQL := '
select 
  sum(nvl(amountb,0)), currencyiso(currencyb)
from deal where doc in (select * from TABLE(InnerMass))  group by currencyb
';
return sSQL;

end prepareSQLBay;

begin
sSQLb := prepareSQLBay();

end;

select * from deal

report.tcb_loan_pkg.isLoanInHolding$
tcb_rsrv.getRsrvElement
od.GetDocHolding
od.ReservGetElementHolding

----------------------------------------------------------------------------------
--03/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.deal_createaccount_tcb

select * from account where classified = 258320550
select * from client where classified = 24896
select * from account where classified = 260984227
select * from client where classified = 149101733

select * from billaccintention  where classified in (1011996343, 1011996470) 

----------------------------------------------------------------------------------
--04/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

BBR_TCB_BILL_BUY_AGR
bbr.BBR_TCB_BILL_BUY_AGREEMENT
select * from preference

select * from ClBankRel where clbank = 23647 /*and code = '30101810800000000388'*/ and relation = 1000002508 
and td /*CONTEXT.OperDate*/ >= opendate and td < nvl(closedate,Max_Date)

select * from ClBankRel where clbank = 23647 /*and code = '30101810800000000388'*/ and relation = 1000002508 

select * from accounttype where classified = 1000002508 

select * from account where doctype = 1000002508

select * from client where classified = 26591

-- поправить вычисление к/с (Кор.счет в РКЦ (Loro)) в bbr.BBR_TCB_BILL_BUY_AGR 
-- (bbr.BBR_TCB_BILL_BUY_AGREEMENT,BBR_TCB_BILL_BUY_AGREEMENTDISC,BBR_TCB_BILL_BUY_AGREEMENTPROC,BBR_TCB_BILL_BUY_AGREEMENTVAL)                                     ++

   SELECT OurBank
   --INTO nOurBank
   FROM Preference
   WHERE SysFilial = 1
   
   select * from client where classified = 1

   select c.label, ClientAddress(c.doc), od.GetClientCode(c.doc,20), a.code, od.GetClientCode(c.doc,7), od.GetClientCode(c.doc,25) 
  -- into sBankLabel, sBankAddress, sInn, sBankNostroAcc, sBik, sKPP
   from client c, preference p, account a 
   where c.doc = 1 and p.ourbank = c.doc and p.NOSTROACCOUNT = a.doc;
   
   select * from preference
   
   select * from account where classified = 20100062

select rowid, b.* from bill b where num = '0031598'

select * from billsum where bill = 1345602604

bbr.BBR_DEPO_CHECKBAL_TCB7

-- делал для Антиповой Т.М. отчет BBR_DEPO_CHECKBAL_TCB8 (для красивой выгрузки в excel) для проверки ЦБ                                                            ++

bbr.BBR_DEPO_CHECKBAL_TCB8

----------------------------------------------------------------------------------
--07/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select d.* from DealSwapInterestLOG d where doc = 247923978

select * from DealSwapInterest where doc = 247923978   
select * from DealSwapPayPeriod where InterestPeriod = 1236447838
select * from Dealswappayment where doc = 217673359
select rowid, d.* from DealSwapInterestLOG d where doc = 247923978

select * from preparemoney where acc in (select classified from account where code = '52306978200000028537')
select * from preparemoney where acc in (select classified from account where code = '52306978200000028537')
select * from doctree

select * from account

BBR_TCB_BILL_OPER_MSK

select * from billstatushistory
select 17500000*0.0001*(7/365) from dual

select 17500000*0.0001*((15+30+31+31+30+31+30+31+90+7)/365) from dual
select 17500000*0.0001*((6)/365) from dual
select 17500000*0.0675*((90)/365) - 17500000*0.0001*((90)/365) from dual -- 290835,61
select 17500000*0.0675*((90)/365) - 17500000*0.0001*((89)/365) from dual -- 290840,41

od.FUNC_BILL_ACCRUALRETURN_TY_TCB
FUNC_BILL_ACCRUALRETURN_TY_TCB

select * from billsum where bill in (select classified from bill where num = '0030921')

----------------------------------------------------------------------------------
--08/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billsumtype
18	1241786408	1011996370	219887444	335823,250	
6	1241786151	1011996477	222257878	0,000	
14	1241786151	1042775368	222257878	26865,860	


-- при погашении дисконтного векселя (по предъявлению но не ранее) в период, когда дата "по предъявлению" уже наступила, а +год еще не прошел, некорректно 
-- рассчитывалась сумма FUNC_Bill_OwnDiscOff => пришлось сделать свою сумму (на основе FUNC_Bill_OwnDisc_DiscOff) и заменить её в схеме проводок                   ++

create or replace function FUNC_Bill_OwnDisc_DiscOf_TCB
/******************************************************************************
 Назначение:  Функция возвращает разницу между дисконтом выдачи векселя и
  списанным дисконтом. Только для операции погашения.
 08/04/2014 Панфилов М.С. на основе FUNC_Bill_OwnDisc_DiscOff (добавлено только сохранение SaveBillSum)
******************************************************************************/
return DT.Amount as
   nAmount  DT.Amount;
begin
   if BC.recDoc.nCategory in (703, 722) then
      nAmount := BC.GetBillSum(BC.GetBill, 11) -
                 nvl(BC.GetBillSum(BC.GetBill, 15), 0);
      if nvl(nAmount, 0) != 0 then
         BC.SaveBillSum(BC.GetBill, bill_p.SumTypeClassified(15), BC.GetDoc, nAmount);
      end if;
   end if;
   return nAmount;
end FUNC_Bill_OwnDisc_DiscOf_TCB; 

----------------------------------------------------------------------------------
--09/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from bankoper where doc = 254001291

BBR_TCB_BILL_OPER_MSK

----------------------------------------------------------------------------------
--10/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

bbr.BBR_RASP_DILING_TCB

-- исправить по векселю СберБанка 0321334 дату предъявления с 24/05/2013 на 27/05/2013 для Епановой                                                                 ++
select rowid, b.* from bill b where num = '0321334'                                                 

select * from bill where num = '0023965'
select * from billsum where bill = 1207295976

select 
17808.220+
42465.750+
41095.890+
42465.760+
41095.890+
42465.750+
42465.750+
41095.890+
42465.760+
41095.890+
42465.750+
42465.750  -- 479  47
 from dual

od.BillDPPercentSum_TCB

od.FUNC_BILL_ACCRUALADD

select * from billsumtype
0023965

od.DPC_BillOper

od.FUNC_BILL_ACCRUALADD_TM_TCB

od.FUNC_BILL_ACCRUALRETURN_TY_TCB

DPC_BillSumCorrection_TCB

od.FUNC_BILL_ACCRUALADD_TM_TCB

-- поправил ошибку в процедуре BillDPPercentSum_TCB2                                                                                                               ++
create or replace function BillDPPercentSum_TCB2(
/******************************************************************************
 Сумма процентов по векселю на заданную дату по указанной ставке, с доп. параметром
 Дата: 25/04/2013
 Автор: Панфилов М.С.
 -- 14/02/2014 Панфилов М.С.
 -- 10/04/2014 Панфилов М.С. заменил dtFirstRateTo на dtFirstRateTo+1, чтобы брался правильный предыдущий год (т.е. если сюда пришла 
 -- дата 31/01/2013, то год надо брать 2013) 
******************************************************************************/
   nBill       DT.Reference,            -- вексель
   dtPayDate   date,                    -- дата платежа
   DPPerc      Bill.Percent%type,       --  процентная ставка по векселю
   flag        DT.status default 0      --  0 - с даты выдачи векселя, 1 - с начала текущего года
) return DT.Relation as

   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;

-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
 --dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;

begin
   dt_PayDate := trunc(dtPayDate);
   select PayDateVar, BillSum, BillCurrency,
          DPPerc, decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2, DPPerc
     into nPayDateVar, nBillSum, nBillCurr,
          nPercent, dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2, nSecondRate
     from Bill
    where Classified = nBill;

   --  для векселей "по предъявлению", у которых с даты составления или даты "не ранее" прошло более года
   if nPayDateVar = 1 and months_between(dtPercentTo, nvl(dtDate1, dtDrawDate)) >= 12 then
      dtPercentTo := add_months(nvl(dtDate1, dtDrawDate), 12);
   end if;

   if nPayDateVar != 1 and nPayDateVar != 2 then
      -- у векселей не по предъявлению % не бывает
      return null;
   elsif dtPercentTo <= dtPercentFrom then
      return 0;
   end if;
   if dtPercentFrom is null then
      return 0;
   end if;

   dtFirstRateTo := dtPercentTo;
   -- если есть вторая ставка
   if nvl(nSecondRate, 0) > 0 then
      if dtDate2 is not null and dt_PayDate > trunc(dtDate2) then
         dtFirstRateTo := dtDate2;
      end if;
      if dtDate2 is null and dtDate1 is not null and dt_PayDate > trunc(dtDate1) then
         dtFirstRateTo := dtDate1;
      end if;
   end if;
   -- Расчет суммы по первой ставке
   dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtFirstRateTo,'dd.mm.yyyy'));
   dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - flag = ' || flag);
   if flag = 0 then
   nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
   else
     if dtPercentFrom < trunc(/*dtPercentFrom*/dtFirstRateTo+1,'YYYY') then -- 14/02/2014 Панфилов М.С.
       nPercentSum := GetAmountPercent(trunc(/*dtPercentFrom*/dtFirstRateTo+1,'YYYY')-1, dtFirstRateTo, nPercent); -- 14/02/2014 Панфилов М.С.
     else
       nPercentSum := GetAmountPercent(dtPercentFrom, dtFirstRateTo, nPercent);
     end if;
   end if;
   -- Расчет суммы по второй ставке
   if nvl(nSecondRate, 0) > 0 and dtFirstRateTo < dt_PayDate then
--      DateAddTime(dtPercentFrom, dtFirstRateTo, 1, 1);
      dtPercentFrom := dtFirstRateTo;
      if flag = 0 then
      nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
      else
        if dtPercentFrom < trunc(/*dtPercentFrom*/dtFirstRateTo+1,'YYYY') then -- 14/02/2014 Панфилов М.С.
          nPercentSum := nPercentSum + GetAmountPercent(trunc(/*dtPercentFrom*/dtFirstRateTo+1,'YYYY'), dt_PayDate, nSecondRate); -- 14/02/2014 Панфилов М.С.
        else
          nPercentSum := nPercentSum + GetAmountPercent(dtPercentFrom, dt_PayDate, nSecondRate);
        end if;
      end if;
   end if;

   return nPercentSum;
end BillDPPercentSum_TCB2;

-- поправил ошибку в процедуре FUNC_Bill_AccrualReturn_TY_TCB

create or replace function FUNC_Bill_AccrualReturn_TY_TCB
/******************************************************************************
 Описание: Функция возвращает сумму излишненачисленных процентов ЗА ТЕКУЩИЙ ГОД (с проверкой ставки досрочного погашения при досрочном выкупе):
 Автор: Панфилов М.С.
 Версия от: 24/09/2013
 -- 14/02/2014 Панфилов М.С.
 -- 17/02/2014 Панфилов М.С.
 -- 10/04/2014 Панфилов М.С. теперь в nPrePercSum вместо null попадает 0
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
******************************************************************************/
return DT.Amount as
   nSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   nPercSum       dt.Amount;                          -- начисленные проценты
   nPrePercSum    dt.Amount;                          -- ранее начисленные проценты
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания
   bClassified     dt.Reference;
begin
  dbms_output.put_line('FUNC_Bill_AccrualReturn_TY_TCB: started ');

   dtAccrDate := nvl(dtAccrDate, Context.OperDate);

   begin
   select nvl(sum(bs.Amount),0) into nPrePercSum from BillSum bs, doctree dt
   where dt.classified = bs.doc and dt.operdate > trunc(Context.OperDate,'YYYY') and dt.operdate < trunc(Context.OperDate,'MM') and bs.Bill = bc.getbill and bs.SumType = nvl( bill_p.SumTypeClassified(14),0); -- 14/02/2014 Панфилов М.С.
   exception when others then nPrePercSum := 0;
   end;   
      dbms_output.put_line('nPrePercSum = ' || nPrePercSum);
      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then
    --nPercSum := BillDPPercentSum_TCB2(bc.getbill,Context.OperDate,nPerc,1);
   nPercSum := BillDPPercentSum_TCB2(bc.getbill,trunc(Context.OperDate,'MM')-1,nPerc,1); -- 14/02/2014 Панфилов М.С.   -- 17/02/2014 Панфилов М.С. -1 день
   dbms_output.put_line('nPercSum = ' || nPercSum || ' nPrePercSum = ' || nPrePercSum );
   nSum := nPercSum - nPrePercSum;
else
  nSum := 0;
end if;
   -- запишем константную сумму (14) для вытаскивания в отчетах
   dbms_output.put_line('BC.GetBill = ' || BC.GetBill || ' bill_p.SumTypeClassified(14) = ' || bill_p.SumTypeClassified(14) || ' BC.GetDoc = ' || BC.GetDoc || ' nSum = ' || nSum);
      insert into BillSum(Bill, SumType, Doc, Amount)
         values(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nSum);

   return abs(nSum);
end FUNC_Bill_AccrualReturn_TY_TCB;


-- проблема двойного начисления процентов при досрочном погашении после группового начисления процентов 
-- (когда новая ставка досрочного погашения равна исходной ставке по векселю) Бахавчук => поправить процедуры DPC_BillSumCorrection_TCB FUNC_Bill_AccrualAdd_TM_TCB ++

create or replace procedure DPC_BillSumCorrection_TCB
/******************************************************************************
 Изменение суммы %% по векселю (коррекция %% для досрочного выкупа по ставке досрочного погашения)
 Дата: 25/04/2013
 Автор: Панфилов М.С.
  -- 16/08/2013 Панфилов М.С. - встроил проверку, процентный вексель или нет
  -- 19/09/2013 Панфилов М.С. - поправил косяк, который нашла Епанова
  -- 10/04/2014 Панфилов М.С. если старая и новая ставки одинаковые, то НЕ считаем проценты по-новому 
******************************************************************************/
as
  psum           dt.Amount;
  pallsum        dt.Amount := 0;                -- вся сумма процентов по операции
  allsum         dt.Amount := 0;                -- вся сумма по операции
  sPerc          objdesc.desctext%type;         -- процентная ставка из доп.описания
  nPerc          billrange.percentsum%type;     -- процентная ставка из доп.описания
  nPercent       Bill.Percent%type;
begin
      -- проверяем доп.описание
      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

dbms_output.put_line('DPC_BillSumCorrection_TCB ->');

begin

  -- если доп.описание есть
  if nPerc is not null then
  for rec in (select br.*, b.billsum from BillRange br, bill b where br.Doc=CONTEXT.CurrentDoc and br.bill = b.classified)
    loop
      nPercent := 0;
      select nvl(Percent,-1) into nPercent from Bill where Classified = rec.bill;
      dbms_output.put_line('nPerc = ' || nPerc || ' nPercent = ' || nPercent);
      if nPercent >= 0 and nPerc != nPercent then -- 16/08/2013 Панфилов М.С. - встроил проверку, процентный вексель или нет 
                                                  -- 10/04/2014 Панфилов М.С. если старая и новая ставки одинаковые, то НЕ считаем проценты по-новому 
      -- вычислим сумму процентов по новой ставке nPerc
      psum := BillDPPercentSum_TCB(rec.bill,Context.OperDate,nPerc);
      update BillRange set percentsum = psum, rowprice = psum + rec.billsum where bill = rec.bill and Doc=CONTEXT.CurrentDoc; -- 19/09/2013 Панфилов М.С. - поправил косяк, который нашла Епанова
      pallsum := pallsum + psum;
      allsum := allsum + psum + rec.billsum;
      dbms_output.put_line('DPC_BillSumCorrection_TCB <- ' || psum);
      end if;
    end loop;

  update billpercent set percentsum = pallsum where doc = Context.CurrentDoc;

  update BillOper set OperSum=allsum, SumFrom=allsum, SumTo=allsum where Doc=CONTEXT.CurrentDoc;

  end if;

exception
  when others then null;
end;

end DPC_BillSumCorrection_TCB;

create or replace function FUNC_Bill_AccrualAdd_TM_TCB
/******************************************************************************
 Описание: Функция возвращает сумму процентов для доначисления по векселю ЗА ТЕКУЩИЙ МЕСЯЦ (с проверкой ставки досрочного погашения при досрочном выкупе):
           >0 - надо доначислить проценты
 Автор: Панфилов М.С.
 Версия от: 23/09/2013
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
  -- 10/04/2014 Панфилов М.С. если старая и новая ставки одинаковые, то НЕ считаем проценты по-новому 
******************************************************************************/
return DT.Amount as
   nResSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания

   dt_PayDate     DATE;
   nPayDateVar    Bill.PayDateVar%type;
   nBillSum       Bill.BillSum%type;
   nBillCurr      Bill.BillCurrency%type;
   nPercent       Bill.Percent%type;
   dtPercentFrom  Bill.PercentDate%type;
   dtPercentTo    Bill.PercentDate%type;
   dtFirstRateTo  Bill.PercentDate%type;
   dtDate1        Bill.PercentDate%type;
   dtDate2        Bill.PercentDate%type;
   dtDrawDate     Bill.DrawDate%type;
   nSecondRate    Bill.SecondRate%type;
   nPercentSum    DT.Relation;

-- Признак 360-дневного года
function IsYear360
return DT.Status as
begin
   if to_number(Registry.GetValue('\Bill\General\Year360')) = 1 then
      return 1;
   end if;
   return 0;
end IsYear360;

-- Разница между датами в днях
procedure DateDiff(
   nTime       in out   DT.Quantity, -- разница
   dtDateBeg            date, -- начальная дата
   dtDateEnd            date -- конечная дата
) as
   nTimeBase   DT.Status := 0;
begin
   if IsYear360 = 1 then
      nTimeBase := 1;
   end if;
   nTime := DPGeneral.DaysInInterval(dtDateBeg, dtDateEnd, nTimeBase);
end DateDiff;

   function GetAmountPercent(
      dtPercentFrom date,  --  начало периода
      dtPercentTo   date,  --  конец периода
      nPercent      Bill.Percent%type  --  процент по векселю
   ) return DT.Relation as
     nTime          DT.Quantity;
     nSum           DT.Relation := 0;
     nYearLen       DT.Quantity := 365;
     dtYearFrom     date;
     dtYearTo       date;
     dtYear         date;
     dtYearNext     date;
   begin
     if IsYear360 = 1 then
        DateDiff(nTime, dtPercentFrom, dtPercentTo);
        nYearLen := 360;
        nSum := nBillSum * nPercent/100 *nTime/nYearLen;
     else
-- dbms_output.put_line(to_char(dtPercentFrom,'dd.mm.yyyy') || ' - ' || to_char(dtPercentTo,'dd.mm.yyyy'));
        dtYearFrom := trunc(dtPercentFrom, 'YEAR');
        dtYearTo := trunc(dtPercentTo, 'YEAR');
        dtYear := dtYearFrom;
        while dtYear <= dtYearTo loop
           dtYearNext := Add_Months(dtYear, 12);
           nYearLen := dtYearNext - dtYear;
           if dtYearFrom = dtYearTo then
              DateDiff(nTime, dtPercentFrom, dtPercentTo);
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
              exit;
           end if;
           if dtYear = dtYearFrom then
              DateDiff(nTime, dtPercentFrom, dtYearNext-1);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear = dtYearTo then
              DateDiff(nTime, dtYear-1, dtPercentTo);
-- dbms_output.put_line(dtYear || ' год - ' || nTime || ' дней из ' || nYearLen );
              nSum := nSum + nBillSum * nPercent/100*nTime/nYearLen;
           end if;
           if dtYear != dtYearFrom and dtYear != dtYearTo then
              nSum := nSum + nBillSum * nPercent/100;
           end if;
           dtYear := dtYearNext;
        end loop;
     end if;
     return nvl(round(nSum, MinorUnit(nBillCurr)), 0);
   end GetAmountPercent;

begin

dbms_output.put_line('FUNC_Bill_AccrualAdd_TM_TCB: started ');

   dtAccrDate := nvl(dtAccrDate, trunc(s.ysdate));

      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then

select PayDateVar, BillSum, BillCurrency,
          decode(nvl(AccrualMethod, 0), 0, nvl(nvl(PercentDate, Date1), DrawDate), 1, PresentDate),
          least(nvl(Date2, dt_PayDate), dt_PayDate), DrawDate, Date1, Date2, nvl(Percent,0)
     into nPayDateVar, nBillSum, nBillCurr,
          dtPercentFrom, dtPercentTo, dtDrawDate, dtDate1, dtDate2, nPercent
     from Bill
    where Classified = bc.getbill;
    if nPerc != nPercent then         -- 10/04/2014 Панфилов М.С. если старая и новая ставки одинаковые, то НЕ считаем проценты по-новому 
      nResSum := GetAmountPercent(greatest(trunc(dtAccrDate,'MM')- 1,dtPercentFrom),dtAccrDate,nPerc);  -- 31/01/2014 Панфилов М.С. добавил сравнение с dtPercentFrom
    else
      nResSum := GetBillAccrualSum(bc.getbill,Context.OperDate);
    end if;
else
  nResSum := GetBillAccrualSum(bc.getbill,Context.OperDate);
end if;
dbms_output.put_line('nResSum = ' || nResSum || ' nResSum = ' || nResSum);
   -- запишем константную сумму (14) для вытаскивания в отчетах
      insert into BillSum(Bill, SumType, Doc, Amount)
         values(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nResSum);

   return nResSum;

end FUNC_Bill_AccrualAdd_TM_TCB;

od.FUNC_BILL_ACCRUALRETURN_TY_TCB

od.FUNC_BILL_ACCRUALRETURN_TL_TCB

select * from bill where num = '0031440'
select * from billsum where bill = 1292963478
select * from desclist

select
53561.640+
332082.200+
332082.190+
299945.200+
332082.190+
1953.420
-960391.770
-383375.350
from dual

--7939,72

select * from desclist

-- проблема некорректного расчета суммы излишненачисленных процентов ЗА ТЕКУЩИЙ ГОД при досрочном погашении после группового начисления процентов 
-- (когда есть новая ставка досрочного погашения) Бахавчук => поправить процедуру FUNC_Bill_AccrualReturn_TY_TCB                                                     ++
create or replace function FUNC_Bill_AccrualReturn_TY_TCB
/******************************************************************************
 Описание: Функция возвращает сумму излишненачисленных процентов ЗА ТЕКУЩИЙ ГОД (с проверкой ставки досрочного погашения при досрочном выкупе):
 Автор: Панфилов М.С.
 Версия от: 24/09/2013
 -- 14/02/2014 Панфилов М.С.
 -- 17/02/2014 Панфилов М.С.
 -- 10/04/2014 Панфилов М.С. теперь в nPrePercSum вместо null попадает 0
 -- 10/04/2014 Панфилов М.С. теперь при вычислении суммы nPrePercSum берем все документы этого года, за исключением текущего документа
 
использовать только для досрочных выкупов BC.recDoc.nDocType = 1065658588
******************************************************************************/
return DT.Amount as
   nSum        DT.Amount;
   dtAccrDate  Date;       -- дата, по которую рассчитываются %
   nPercSum       dt.Amount;                          -- начисленные проценты
   nPrePercSum    dt.Amount;                          -- ранее начисленные проценты
   sPerc            objdesc.desctext%type;          -- процентная ставка из доп.описания
   nPerc            billrange.percentsum%type;     -- процентная ставка из доп.описания
   bClassified     dt.Reference;
begin
  dbms_output.put_line('FUNC_Bill_AccrualReturn_TY_TCB: started ');

   dtAccrDate := nvl(dtAccrDate, Context.OperDate);

   begin
   select nvl(sum(bs.Amount),0) into nPrePercSum from BillSum bs, doctree dt                        -- 14/02/2014 Панфилов М.С.
   where dt.classified = bs.doc and dt.operdate > trunc(Context.OperDate,'YYYY') 
   /*and dt.operdate < trunc(Context.OperDate,'MM')*/ and bs.doc != Context.CurrentDoc              -- 10/04/2014 Панфилов М.С.
   and bs.Bill = bc.getbill and bs.SumType = nvl( bill_p.SumTypeClassified(14),0);
   exception when others then nPrePercSum := 0;
   end;   
      dbms_output.put_line('nPrePercSum = ' || nPrePercSum);
      begin
      select trim(OD.desctext) into sPerc
             from objdesc OD, desclist DL
             where OD.doc = Context.CurrentDoc
             and OD.description = DL.classified
             and DL.constdesc = -1370;
      nPerc := sPerc;
      exception
             when others then null;
      end;

if nPerc is not null then
    --nPercSum := BillDPPercentSum_TCB2(bc.getbill,Context.OperDate,nPerc,1);
   nPercSum := BillDPPercentSum_TCB2(bc.getbill,trunc(Context.OperDate,'MM')-1,nPerc,1); -- 14/02/2014 Панфилов М.С.   -- 17/02/2014 Панфилов М.С. -1 день
   dbms_output.put_line('nPercSum = ' || nPercSum || ' nPrePercSum = ' || nPrePercSum );
   nSum := nPercSum - nPrePercSum;
else
  nSum := 0;
end if;
   -- запишем константную сумму (14) для вытаскивания в отчетах
   dbms_output.put_line('BC.GetBill = ' || BC.GetBill || ' bill_p.SumTypeClassified(14) = ' || bill_p.SumTypeClassified(14) || ' BC.GetDoc = ' || BC.GetDoc || ' nSum = ' || nSum);
      insert into BillSum(Bill, SumType, Doc, Amount)
         values(BC.GetBill, bill_p.SumTypeClassified(14), BC.GetDoc, nSum);

   return abs(nSum);
end FUNC_Bill_AccrualReturn_TY_TCB;


select * from DealSwapInterest where doc = 236239460   
select * from DealSwapPayPeriod where InterestPeriod = 1347851594
select * from Dealswappayment where doc = 217673359
select rowid, d.* from DealSwapInterestLOG d where doc = 236239460

select * from DealSwapInterest where doc = 217656385   
select * from DealSwapPayPeriod where InterestPeriod = 1347851594
select * from Dealswappayment where doc = 217673359
select rowid, d.* from DealSwapInterestLOG d where doc = 217656385

236239460 
217656385

select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

select * from docstate 

--delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

-- зачистить удаленные документы из DealSwapInterestLog - просила Бакумцева, чтобы не возникало ошибки "о невозможности росписи остатка по периодам начисления"      ++ 
select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)
delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

select * from customertransfer where doc = 260681919

----------------------------------------------------------------------------------
--15/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- сделать новый отчет BBR_RASP_DILING_MT202_TCB на основе BBR_RASP_DILING_TCB по задаче 184493 для Молодовой                                                        ++
-- 23/04/2014 правил отчет BBR_RASP_DILING_MT202_TCB (добавил вторую строку для поля 72 и сделал спец.заполнение полей для INTL FCSTONE (EUROPE) LTD)                ++

select * from customertransfer where doc = 262306637
select * from customeriso where doc = 262306637
select * from account where classified = 30135695
select * from corraccount where account = 30135695
select * from client where classified = 27489
address
od.clientanyaddress

select substr('123'||chr(13)||chr(10)||'456',1,instr('123'||chr(13)||chr(10)||'456',chr(13)||chr(10)))from dual
select substr('123'||chr(13)||chr(10)||'456',instr('123'||chr(13)||chr(10)||'456',chr(13)||chr(10)))from dual

select * from CLIENTPROPERTY where prop = 1000005026
 .1000005026.1000012588
select getclientconstattr from getclientconstattr 

select * from desclist
select * from ClearingHouse 

  select * /*DescText into sLine*/ from ObjDesc
  where Obj = 63908135
    --and Description = (select Classified from DescList where ConstDesc = ConstAttr)
    and Variant = (select Classified from ClearingHouse where Const = 1)

select * from DescList
select * from customerISO
od.findclientbycode

GetClientConstAttr

bbr.BBR_RASP_DILING_MT202_TCB

select nvl(od.GetClientConstAttr(12769,1,64),'') from dual
select nvl(od.GetClientConstAttr(63908135,1,64),'') from dual

od.getclientconstattr

  select * from ObjDesc
  where Obj = 12769
    and Description = (select Classified from DescList where ConstDesc = 65)
    and Variant = (select Classified from ClearingHouse where Const = 1)
    and td >= validfromdate and td <= validtodate

--select * from DEALTRANSACTION where doc = 262721031 .BENEFICIARYBANKNAME

select * -- replace(INFOAGENTBANK,chr(13)||chr(10)), od.clientlabel(FindObjectByCode(receivercode,receivercodetype)), receivercode --into sInfoAgentBank, sOurBA, sOurBACode
from CUSTOMERISO where doc = 262936654
262936654
select * from dealtransaction where doc = parentdoc(262936654)

select client,
(SELECT bc.code FROM bankcode bc WHERE bc.codesystem = 1000004993 AND bc.client = a.client
                                 AND td BETWEEN nvl(bc.validfromdate, od.min_date) AND nvl(bc.validtodate, od.max_date))
from account a
where doc=(
select nostro 
from customertransfer 
 where doc = 262936654
 )
 
 
28      
29      select DT.DOCTYPE into ndoctype from doctree dt where DT.CLASSIFIED = nIdDoc; 
30        
31      select client into nCli
32      from account
33      where doc=nAccount; 

select * from client where classified = 30135695
bbr.BBR_RASP_DILING_MT202_TCB

----------------------------------------------------------------------------------
--17/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.FUNC_BILL_DISCACCR_TCB

----------------------------------------------------------------------------------
--21/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- обновить структуру данных в webservice (проектом заинтересовался Ким) => 22/05/2014 новый подрядчик buscredit.ru                                              ++
-- 23/04/2014 новое поле "Источник траффика"
-- 03/06/2014 новое поле "Продукт" 
select rowid, z.* from zayavka z order by datedownload
delete from zayavka

SELECT * FROM NLS_DATABASE_PARAMETERS

marko common osok d9kf87rgd
drop table ZAYAVKA;
-- connTemp = DriverManager.getConnection("jdbc:oracle:thin:@10.97.200.42:1521:common","osok","d9kf87rgd");

CREATE TABLE "OSOK"."ZAYAVKA" 
   (	"CLASSIFIED" NUMBER(11,0) NOT NULL ENABLE, 
	"FAMILY" VARCHAR2(100) DEFAULT NULL, 
	"NAME" VARCHAR2(100) DEFAULT NULL, 
	"PATR" VARCHAR2(100) DEFAULT NULL, 
	"BIRTHDAY" VARCHAR2(100) DEFAULT NULL, 
	"PHONE" VARCHAR2(100) DEFAULT NULL, 
	"EMAIL" VARCHAR2(100) DEFAULT NULL, 
	"SUMM" VARCHAR2(100) DEFAULT NULL, 
	"PERIOD" VARCHAR2(100) DEFAULT NULL, 
	"NATIONALITY" VARCHAR2(100) DEFAULT NULL, 
	"REGION_OF_RESIDENCE" VARCHAR2(100) DEFAULT NULL, 
	"REGION_OF_EMPLOYMENT" VARCHAR2(100) DEFAULT NULL, 
	"FORM" VARCHAR2(100) DEFAULT NULL, 
	"SENIORITY" VARCHAR2(100) DEFAULT NULL, 
	"SENIORITY_ALL" VARCHAR2(100) DEFAULT NULL, 
  "TRAFFIC_SOURCE" VARCHAR2(100) DEFAULT NULL, 
	"STATUS" NUMBER(11,0) DEFAULT 0, 
	"DATEDOWNLOAD" DATE DEFAULT NULL, 
	"EXT_ID" NUMBER(11,0) DEFAULT NULL, 
	"DATEUNLOAD" DATE DEFAULT NULL, 
	"VSUMM" NUMBER(12,2) DEFAULT 0, 
	"VPERIOD" NUMBER(4,0) DEFAULT 0, 
	"VBIRTHDAY" DATE DEFAULT NULL, 
	"VREGION1" NUMBER(11,0) DEFAULT NULL, 
	"VREGION2" NUMBER(11,0) DEFAULT NULL, 
	"VFORM" NUMBER(11,0) DEFAULT NULL, 
  "VTRAFFIC_SOURCE" VARCHAR2(100) DEFAULT NULL, 
	 PRIMARY KEY ("CLASSIFIED")
   );
  /*USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK" ;
  CREATE UNIQUE INDEX "OSOK"."SYS_C0080166" ON "OSOK"."ZAYAVKA" ("CLASSIFIED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK" ;
  ALTER TABLE "OSOK"."ZAYAVKA" ADD PRIMARY KEY ("CLASSIFIED")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "OSOK"  ENABLE;
  ALTER TABLE "OSOK"."ZAYAVKA" MODIFY ("CLASSIFIED" NOT NULL ENABLE);*/
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."CLASSIFIED" IS 'идентификатор';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."SUMM" IS 'желаемая суммма кредита';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."PERIOD" IS 'желаемый срок кредита';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."NATIONALITY" IS 'гражданство';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."REGION_OF_RESIDENCE" IS 'регион проживания';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."REGION_OF_EMPLOYMENT" IS 'регион трудоустройства';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."FORM" IS 'форма подтверждения ежемесячного дохода';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."SENIORITY" IS 'стаж на текущем месте работы';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."SENIORITY_ALL" IS 'общий трудовой стаж';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."STATUS" IS '0 - загружена из вне; 1 - прошла проверку (готова к выгрузке); 2 - выгружена в mssql';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."DATEDOWNLOAD" IS 'время загрузки';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."DATEUNLOAD" IS 'время выгрузки';
   COMMENT ON COLUMN "OSOK"."ZAYAVKA"."TRAFFIC_SOURCE" IS 'источник траффика';

CREATE OR REPLACE TRIGGER zayavka_tr
BEFORE INSERT
ON OSOK.ZAYAVKA 
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
tmpVar NUMBER;
BEGIN
   tmpVar := 0;

   SELECT zayavka_sq.NEXTVAL INTO tmpVar FROM dual;
   :NEW.classified := tmpVar;
   
   :NEW.datedownload := CURRENT_TIMESTAMP;

   EXCEPTION
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END ZAYAVKA_TR;

----------------------------------------------------------------------------------
--22/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- по задаче IPI 186620 добавил колонку в отчет в RN "Отчет_финдеп (привлечение)" для Огневой                                                                        ++
select * from tcb_mbk_product_type_in where classified = od.GetObjDesc(253303213, DescClass(-1353))                                                                   
select od.GetObjDesc(253303213, DescClass(-1353)) from dual

select * from objdesc where doc = 253303213
select * from desclist where classified = 1340502465

od.Setobjdesc

select * from doctype

-- для Ледовской сделать спец.операцию SPEC_SetDesc1353ForTrMBK_TCB (Установить "Вид продукта МБК (вн.)") по простановке доп. описания 
-- DescClass(-1353) "Вид продукта МБК (вн.)"                                                                                                                         ++
-- для Ледовской сделать процедуру DPC_SetDesc1353ForMBK_TCB и повесить её на "Депозитные сделки привлечения/размещения"                                             ++
create or replace procedure SPEC_SetDesc1353ForTrMBK_TCB
/**********************************************************************************
Процедура для установки доп.описания -1353. Только для траншей привлечния
22/04/2014 Панфилов М.С.
**********************************************************************************/
( nDoc         dt.Reference,
  nNew1353     dt.Reference
 )
as
nDocType DocTree.Doctype%type;
begin
   select doctype into nDocType from DocTree where Classified = Context.CurrentDoc;
   if nDocType = 1179850206 then -- транш привлечения
     od.Objattr.SaveOneDesc(Context.CurrentDoc,Context.CurrentDoc, DescClass(-1353), NULL, nNew1353);
   end if;
exception when others then
  null;
end SPEC_SetDesc1353ForTrMBK_TCB;

create or replace procedure DPC_SetDesc1353ForMBK_TCB
/**********************************************************************************
Процедура для установки доп.описания -1353 равным 1351887875 (Казначейство). Для депозитных сделок.
22/04/2014 Панфилов М.С.
**********************************************************************************/
as
nDocCat DocTree.Category%type;
begin
   select category into nDocCat from DocTree where Classified = Context.CurrentDoc;
   if nDocCat = 908 then -- депозитные сделки
     od.Objattr.SaveOneDesc(Context.CurrentDoc,Context.CurrentDoc, DescClass(-1353), NULL, 1351887875);
   end if;
exception when others then
  null;
end DPC_SetDesc1353ForMBK_TCB;


od.DPC_CreatePercentAccountDoc
od.SPEC_movepaydate_tcb
od.SPEC_SetDesc1353ForTrMBK_TCB



-- правил дату составления векселя 0031822 с 18/04/2014 на 21/04/2014 (просила Герасимова)                                                                           ++
select rowid, b.* from bill b where num = '0031822'

----------------------------------------------------------------------------------
--24/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select parentdoc(parent)
from od.bbook where parent = 209943962 

select * from doctree where classified in (209943962,209925924,209924558)
select * from doctype where classified in (1047492427,1047177856,1047168245)

select parentdoc(parentdoc(parent))
from od.bbook where parent = 209943962 

select * from doccategory

select * from dealtransaction where 
select parentdoc(parent) from bbook where parent = 258131563 --258125716

select parentdoc(parent)
from od.bbook where parent = 209943962 

select parentdoc(parent)
from od.bbook where parent = 250206532 
select * from doccategory

select * from bbook where parentdoc(parentdoc(parentdoc(parent))) = 224679515 --and od.getdoccategory(parentdoc(parentdoc(parent))) = 908 

select *
  from bbook bb
 where parent in
       (select classified
          from doctree
         where parent in
               (select dt.classified
                  from doctree dt
                 where category = 905
                   and parent in (select dt.classified
                                    from doctree dt
                                   where classified = 224679515)))
                                   
select *
  from bbook bb
 where parent in
       (select classified
          from doctree
         where parent in
               (select dt.classified
                  from doctree dt
                 where category = 905
                   and parent in (select dt.classified
                                    from doctree dt
                                   where category = 908)))

select * from doctree where classified in (258125716,258131563,224679515)

select * from subsystem

select * from doctype where classified = 1000135409
select * from billoper

select * from billaccintention 
select * from billrange
od.bill_p

(select rd.doc, rd.initdoc ,rd.reestrinit, rd.accountwithreestr from reestrdoc rd, doctree dt where dt.classified = rd.doc --and da.rsaccount = rd.reestrinit 
and dt.parent = 209911382/*nBbookParent --*/)

select d.doc from deal d, doctree dtr where d.doc = dtr.classified and dtr.category = 908 and
EXISTS (
select * from dealaccount da where d.doc = da.doc and da.accintention in (select classified from dealaccintention where constintention in (15,16,17,18))
and (da.account in (select debaccount from bbook where parent = 209911382/*nBbookParent --*/) or account in (select credaccount from bbook where parent = 209911382/*nBbookParent --*/)) 
and ( 
(da.rsaccount is null)
or
exists (select rd.doc, rd.initdoc ,rd.reestrinit, rd.accountwithreestr from reestrdoc rd, doctree dt where dt.classified = rd.doc and da.rsaccount = rd.reestrinit 
and dt.parent = 209911382/*nBbookParent --*/)
)
)

select * from doctree where classified in (209911382,209930904)
select * from doctype where classified in (1047625339,1000135307)
select 



select d.doc from deal d, doctree dtr where d.doc = dtr.classified and dtr.category = 908 and
EXISTS (
select * from dealaccount da where d.doc = da.doc and da.accintention in (select classified from dealaccintention where constintention in (15,16,17,18))
and (da.account in (select debaccount from bbook where parent = 209911382/*nBbookParent --*/) or account in (select credaccount from bbook where parent = 209911382/*nBbookParent --*/)) 
and ( 
(da.rsaccount is null)
or
exists (select rd.doc, rd.initdoc ,rd.reestrinit, rd.accountwithreestr from reestrdoc rd, doctree dt where dt.classified = rd.doc and da.rsaccount = rd.reestrinit 
and dt.parent = 209911382/*nBbookParent --*/)
)
)




select d.doc from deal d, doctree dtr where d.doc = dtr.classified and dtr.category = 908 and
EXISTS (
select * from dealaccount da where d.doc = da.doc and da.accintention in (select classified from dealaccintention where constintention in (15,16,17,18))
and (da.account in (select debaccount from bbook where parent = 209911382/*nBbookParent --*/) or account in (select credaccount from bbook where parent = 209911382/*nBbookParent --*/)) 
and ( 
(da.rsaccount is null)
or
exists (select rd.doc, rd.initdoc ,rd.reestrinit, rd.accountwithreestr from reestrdoc rd, doctree dt where dt.classified = rd.doc and da.rsaccount = rd.reestrinit 
and dt.parent = 209911382/*nBbookParent --*/)
)
)


----------------------------------------------------------------------------------
--25/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- зачистить удаленные документы из DealSwapInterestLog - просила Ледовская, чтобы не возникало ошибки "о невозможности росписи остатка по периодам начисления"      
select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)
delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

select rowid, d.* from DealSwapInterestLog d where doc = 224603092

----------------------------------------------------------------------------------
--28/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

--declare
--begin
--bbr.BBR_TCB_TRANSACT_2WH_XML(to_date('25/04/2014','dd/mm/yyyy'),to_date('25/04/2014','dd/mm/yyyy'),2,0);
--end;

select * from sysfilial
select * from billoper
select * from doccategory

-- правил отчет BBR_TCB_BILL_OPER_MSK для Бахавчука (добавил входящий параметр "контр. по 2-ой опер." - пришлось сделать два доп. цикла с right join)                ++
bbr.BBR_TCB_BILL_OPER_MSK
-- проблема у Бакумцевой с назначениями платежей при уплате процентов за МАРТ 2014 по сделкам МБК => всё из-за того, что сначала начали делать уплату процентов,
-- а потом - их учет                                                                                                                                                 ++
select * from DealSwapInterestLog where doc = 217773911
select * from DealSwapInterestLog where doc = 217773042
select * from DealSwapInterest where doc = 224980622

declare
d date;
begin
select od.DealBegProcDate3(255725245) into d from dual;
dbms_output.put_line(d);
end;

----------------------------------------------------------------------------------
--29/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил od.tcb_bki_mbk_proc (доавлял новый адрес в список рассылки)                                                                                                ++
od.SPEC_DealLimit_PercentAccrual

----------------------------------------------------------------------------------
--30/04/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billsum where bill in (select classified from bill where num = '0032301') 

select * from doctree where classified = 265355324

-- в Перми накосячили с выдачей векселя 0032301 (указали дисконт по векселю в 50%, хотя дсконта впринципе быть не должно) =>
-- пришлось исправлять:                                                                                                                                              ++
--delete from billsum where bill = 1352374804 and sumtype in (1011996370,1042775368)
--update billrange set rowprice = 1200000 where bill = 1352374804 and doc = 264215144

select * from billoper where doc = 264215144
select * from billrange where doc = 264215144

od.DPC_BillOper
select * from doctree where classified = 265331119
od.GET_TCB_BILLACCOUNTLABEL
select * from billaccintention 

-- поправил GET_TCB_BILLACCOUNTLABEL, по просьбе Киселевой                                                                                                           ++
CREATE OR REPLACE PROCEDURE GET_TCB_BILLACCOUNTLABEL
(
  nDocTypeClass                    in  NUMBER,
  nDocCategory                     in  NUMBER,
  nAccInt                          in  NUMBER,
  dtOperDate                       in  DATE,
  nParentDoc                       in  NUMBER,
  CurrencyClass                    in  NUMBER,
  IsForCheck                       in  integer,
  PatternValue                     in out varchar2
)
is
  sNum                             DT.Label;
  nMaker                           DT.Reference;
  nPayee                           DT.Reference;
  sLabel                           DT.Label;
  sName                            DT.Label;
  sPayee                           DT.Label;
begin
  select Num,Maker,Payee into sNum,nMaker,nPayee from bill where classified=BC.getbill;
  select Label into sName from Client where classified=nMaker;
	IF nPayee IS NOT NULL THEN 
  select Label into sPayee from Client where classified=nPayee;
	END IF;
  if nAccInt=34 then
     sLabel:=Substr('Векселя по дог.отв.хран.№ '||DocTreeLabel(BC.recBillOper.doc)||' от '||to_char(dtOperDate,'DD-MM-YY')||'г. с '||ClientLabel(BC.recBillAcc.nClient),1,50);
  elsif nAccInt = 12 THEN    -- srb 17.05.2011 Добавлено название контрагента
                             -- Панфилов М.С. 23/05/2012 Добавлен поиск контрагента для названия из клиента счета
	   IF length(clientlabeltcb(nvl(bc.recBillOper.client,BC.recBillAcc.nClient))||' вексель "ТКБ" (ЗАО) №'||sNum)<=50 THEN
         sLabel:=Substr(clientlabeltcb(nvl(bc.recBillOper.client,BC.recBillAcc.nClient))||' вексель "ТКБ" (ЗАО) №'||sNum,1,50);
		 ELSIF length(clientlabeltcb(nvl(bc.recBillOper.client,BC.recBillAcc.nClient))) < 28 THEN
		     sLabel:=Substr(clientlabeltcb(nvl(bc.recBillOper.client,BC.recBillAcc.nClient))||' "ТКБ" (ЗАО) №'||sNum,1,50); 
		 ELSE sLabel:=Substr(substr(clientlabeltcb(nvl(bc.recBillOper.client,BC.recBillAcc.nClient)),1,28)||' "ТКБ" (ЗАО) №'||sNum,1,50); 
		 END IF;	  
  elsif nAccInt = 21 then
     sLabel:=Substr('Обязательства по процентам по векселю "ТКБ" (ЗАО) №'||sNum,1,50);
  elsif nAccInt = 5 then
     sLabel:=Substr('Дисконт по векселю "ТКБ" (ЗАО) №'||sNum,1,50);
  elsif nAccInt = 23 then
     sLabel:=Substr('Вексель "ТКБ" (ЗАО) №'||sNum||' к исполнению',1,50);
  elsif nAccInt = 24 then
     sLabel:=Substr('Вексель "ТКБ" (ЗАО) №'||sNum||',предъявленный к погашению',1,50);
  elsif nAccInt = 6 then
     sLabel:=Substr(sPayee||' вексель "ТКБ" (ЗАО) №'||sNum,1,50); --pms 13.12.2010 
  elsif nAccInt = 1 then
     sLabel:=Substr('Вексель '||sName,1,50); --srb 05.10.2010  По просьбе Сехиной М. и Крендель А. убран из названия счета номер векселя
  elsif nAccInt = 7 then
     sLabel:=Substr('Вексель не опл.в срок'||sName||' №'||sNum,1,50);
  elsif nAccInt = 9 then
     sLabel:=Substr('Вексель для акцепта'||sName||' №'||sNum,1,50);
  elsif nAccInt = 10 then
     sLabel:=Substr('Вексель на инкассо'||sName||' №'||sNum,1,50);
  elsif nAccInt = 18 then
     sLabel:=Substr('Резерв по векс.'||sName||' №'||sNum,1,50);
  elsif nAccInt = 36 then
     sLabel:=Substr('Вексель не опротест.'||sName||' №'||sNum,1,50);
  elsif nAccInt = 58 then
     sLabel:=Substr('Начисл.% по учт.векс.'||sName/*||' №'||sNum*/,1,50); -- Панфилов М.С. 30/04/2014 счета открываются на группу, так что номер убираем
  elsif nAccInt = 59 then
     sLabel:=Substr('Нач.диск.по учт.векс.'||sName/*||' №'||sNum*/,1,50); -- Панфилов М.С. 30/04/2014 счета открываются на группу, так что номер убираем
elsif nAccInt = 27 then
     sLabel:=Substr('Расчеты с '||clientlabeltcb(bc.recBillOper.client)||' по операциям с  ЦБ',1,50);  --srb 15.11.2010 - IPI №48459
  end if;
  PatternValue := sLabel;
end Get_TCB_BillAccountLabel;

-- зачистить удаленные документы из DealSwapInterestLog - просила Ледовская, чтобы не возникало ошибки "о невозможности росписи остатка по периодам начисления"      
select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)
delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

----------------------------------------------------------------------------------
--05/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.DPC_PROCESSLINKOBJECT

-- по банкнотным сделкам не исполняется автоматом второе подтверждение по сделке => пришлось добавить дублирующий обработчик дочерних объектов в manager на действие
-- "В ДВР" для "Исходящих х-99"                                                                                                                                      ++

-- проблема у Ледовской - не генерятся события по разовым комиссиям на КЛ => Сделал спец.операцию для «Кредитной линии» «Пересчет событий по комиссиям по графику»
-- Эта спец.операция формирует события по разовым комиссиям. Под событиями формируются платежки, как обычно.                                                         ++
-- проблема с заведение платежной инструкции для Лимитов, сейчас галку "проц." приходится убирать прям в базе => 07/05/2014 зарегистрировали замечание 52174 =>
-- 29/05/2014 проблема не повторяется, вероятно ранее плохо тестировали (после добавление платежной инструкции в договор не обновляли КЛ)                            ++
-- события по разовым комиссиям для Траншей генерятся с неправильным типом "Событие банкнотной сделки" => добавил в manager для "Транша привлечения" на состояние
-- "День 1" порождение дочернего документа "События депозитной сделки" с причиной "Взятие комиссии"                                                                  ++ 

select rowid, d.* from dealpactpayreq d where doc = 181847334

select rowid, d.* from dealpactpayreq d where doc = 224361522

od.DPC_DealDepCommiss_Events

----------------------------------------------------------------------------------
--06/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from bill where num = '0031909' 
-- менял номер векселя 0031909 на 0031911 по просьбе Рыжовой                                                                                                         ++
update bill set num = '0031911' where num = '0031909'
select * from billoper where doc = 266103976 

select * from billrange where doc = 266103976 
update billrange set numfrom = '0031911', numto = '0031911' where doc = 266103976  and bill = 1356706537

select * from DEPOSECURITY where label = 'ВЕКСЕЛЯ_ТСВМ_МОСКВА_RUB' -- 1066859335
select * from SYSCERTIFICATE where num = '0031909'
update SYSCERTIFICATE set num = '0031911' where num = '0031909'

----------------------------------------------------------------------------------
--07/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

SELECT ROWID, d.* FROM doctree d where classified in (266401760, 266402109, 266509301)

----------------------------------------------------------------------------------
--08/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- зачистить удаленные документы из DealSwapInterestLog - просила Бакумцева, чтобы не возникало ошибки "о невозможности росписи остатка по периодам начисления"      
select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)
delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

select * from accountwithreestr where account = 214300042

select rowid, r.* from reestr r where accountwithreestr = 1252215611 and reestrinit = 225472291 order by reestrinit, begdate;
select * from reestrdoc where accountwithreestr = 1252215611 and reestrinit = 225472291 order by reestrinit, classified

select * from doctree where classified = 266649610
select * from doctree where classified = 266649611
select * from doctype where classified = 1000135307
select * from doctype where classified = 1000135409

select * from accountwithreestr where classified = 1252215611
select * from balance where account = 214300042
select * from account where classified = 214300042

----------------------------------------------------------------------------------
--12/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- завесил в реестр по счету 47426`840`6`5000`0100086  0,02                                                                                                          ++
insert into reestr (Classified, Reestrinit, accountwithreestr, Docsum, Type, BegDate, EndDate) values 
                   (null, 225472291, 1252215611, 0.02, 1, to_date('07/05/2014 9:39:00','dd/mm/yyyy hh:mi:ss'), to_date('01/01/4444 12:00:00','dd/mm/yyyy hh:mi:ss'))
/*insert into reestrdoc (Classified, Doc, Sysfilial, Doctype, Ishidden, Type, accountwithreestr, Docsum, Reestrinit, Initdoc, Isclear, Rate) values 
                      (Classified.nextval, Classified.nextval, 1, 1000135223, '', 1, 1298582954, 12439586.69, 224614747, null, 1, null)*/

-- апдейтил состояния форексных сделок из "Исполнен" в "День 2", чтобы можно было переисполнить события по ним (это делать было не обязательно, достоточно было
-- зачистить журнал по семи срочным сделкам) => закрыть назад                                                                                                        ++
select rowid, d.* from doctree d where classified = 266373379 -- 1000000035 1047169231 - было
select rowid, d.* from doctree d where classified = 266523353 --
select rowid, d.* from doctree d where classified = 266426328 --
select rowid, d.* from doctree d where classified = 266396309 --
select rowid, d.* from doctree d where classified = 266372941 --
select rowid, d.* from doctree d where classified = 266372940 --

select rowid, d.* from doctree d where classified in (266373379,266523353,266426328,266396309,266372941,266372940)

select * from doctree where classified = 266330921 -- 1000000039  1047399138 - стало

-- нужно зачистить журнал по семи срочным сделкам:
/*select * from TimedOperLog where timedoper = 2920 --where doc = 266718969
delete TimedOperLog where timedoper = 2920 and opertype = 4
select * from TimedOperLog where timedoper = 2930
delete TimedOperLog where timedoper = 2930 and opertype = 4
select * from TimedOperLog where timedoper = 2928
delete TimedOperLog where timedoper = 2928 and opertype = 4
select * from TimedOperLog where timedoper = 2929
delete TimedOperLog where timedoper = 2929 and opertype = 4
select * from TimedOperLog where timedoper = 2934
delete TimedOperLog where timedoper = 2934 and opertype = 4
select * from TimedOperLog where timedoper = 2941
delete TimedOperLog where timedoper = 2941 and opertype = 4
select * from TimedOperLog where timedoper = 2952
delete TimedOperLog where timedoper = 2952 and opertype = 4*/


-- апдейтил состояние транша из "Исполнен" в "День 1", чтобы можно было доначислить проценты по траншу => закрыть назад                                              ++

select rowid, d.* from doctree d where classified = 224679515 -- 1000000035 1179850218 - было

select * from doctree where classified = 250987007 -- 1000000039 1179850227 - стало

od.DPC_TERMDEAL_OPENCLOSE
od.Timed_Proc.DelTimedOperLogByDoc 

----------------------------------------------------------------------------------
--13/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

SELECT  /*+ INDEX(DT IX_DOCTREE_23) */ DT.Classified, DT.Label, DT.DocType, SUBSTR(EntityStateLabel( DT.EntityState ), 1, 50), ' ', DT.OperDate, null, DT.DealDate, DT.ValueDate, DT.MaturityDate, null, substr( Get_BankCode( DT.CounterParty, 1000104502 ), 1, 50 ), null, null, null, null, decode( DT.IsNetting, 1, 'да', 'нет' ), DT.Ticket, substr( CurrencyISO( DT.CurrencyB ), 1, 3 ), substr( FmtDocSum( DT.AmountB, DT.CurrencyB ), 1, 50 ), DT.AmountB, DT.Rate, substr( CurrencyISO( DT.CurrencyS ), 1, 3 ), substr( FmtDocSum( DT.AmountS, DT.CurrencyS ), 1, 50 ), DT.AmountS, null, null, null, null, null, null, null
 FROM  V_Deal DT 
  WHERE EXISTS (SELECT * FROM V_EntityStateWindow WHERE EntityState = DT.EntityState
        AND WindowName IN ('frmDeal') )
    AND DT.DocType = 1047166507
    AND DT.OperDate >= TO_DATE( '2014-05-12-00.00.00', 'YYYY-MM-DD-HH24.MI.SS' )
    AND DT.OperDate <= TO_DATE( '2014-05-13-23.59.00', 'YYYY-MM-DD-HH24.MI.SS' ) 
  ORDER BY 8 ASC
  
bbr.BBR_FORM128  
  
select (13.98*27000000+15.54*45000000+10.53*93000000)/165000000 from dual

----------------------------------------------------------------------------------
--14/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)
delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

select rowid, d.* from DealSwapInterestLog d where doc = 253303213 --322191.78 (161095.89-80547.95) = 80547,94
select 161095.89-80547.95 from dual

select * from DealSwapInterest where doc = 253303213

select * from account where code = '47426810250010030000'
select * from accountwithreestr where account = 253304535

select * from reestr where accountwithreestr = 1327112224
select * from reestrdoc where accountwithreestr = 1327112224

select * from balance where account = 253304535

----------------------------------------------------------------------------------
--15/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from billaccount where billgroup in (select classified from billgroup where label = 'Векселя банка ОАО "Альфа Банк"  ') -- bill in (select classified from bill where num = '0039283')

select * from billgroup

----------------------------------------------------------------------------------
--16/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

EditDealAccMethod(recDeal, niAccMethod)
od.FXDeal_TimedBeg
select * from dealaccintention
od.FXDeal_Conv

select da.doc,d.doc        
  from account a
    join dealaccount da
      on da.account = a.classified
     and trunc(da.startdate,'dd') <= '18.04.2014'
     and da.enddate >= '18.04.2014'
    left join deal d
      on d.doc = da.doc
   where 1=1
     and a.code = '93306840100000000056'

select * from dealaccount where doc = 75479481 and account = (select classified from account where code = '93306840100000000056' )

select * from deal where doc = 75479481

select * from doctree where classified = 263136892--75479481

select * from doctype where classified = 1047124628

select da.*,d.doc        
  from account a
    join dealaccount da
      on da.account = a.classified
     --and trunc(da.startdate,'dd') <= '18.04.2014'
     --and da.enddate >= '18.04.2014'
    left join deal d
      on d.doc = da.doc
   where 1=1
     --and a.code = '93306840100000000056'
     and a.code =   '93307840400000000056'

----------------------------------------------------------------------------------
--19/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.MoveAllTimedSum2_TCB

select dt.*, r.AccountWithReestr --, acccode()
       from DocTree dt, Reestr r
      where dt.Classified = r.ReestrInit
        and r.EndDate = TO_DATE('4444-01-01 12:00:00','YYYY-MM-DD HH24:MI:SS')       --  Документ не закрыт
        and r.Type = 1          --  Остаток-реальный
        and r.DocSum != 0               --  Остаток ненулевой
        and r.AccountWithReestr in 
        (
        
select Classified from AccountWithReestr where Account in (
select a.Classified
       from Account a
      where a.Type in ( select Classified
                          from AccountType
                         where Category = 66 -- Срочные счета
                           and IsNeedReestr = 1 )           -- Признак ведения реестра по счету
        and a.Opened <= TO_DATE('2014-05-16','YYYY-MM-DD')
        and a.Closed  > TO_DATE('2014-05-16','YYYY-MM-DD')
        and a.SysFilial = 1
        )        
        
        )
        AND nvl(GetDocType(dt.parent),1) != 1034077811 -- 12/02/2014 Панфилов М.С. (не берем переводы по срочным ц.б.)
        and dt.ValidToDate < TO_DATE('2014-05-16','YYYY-MM-DD') --dtValidMin;
        
select * from AccountWithReestr where classified = 1115141415


select Classified from AccountWithReestr where Account in (
select a.Classified
       from Account a
      where a.Type in ( select Classified
                          from AccountType
                         where Category = 66 -- Срочные счета
                           and IsNeedReestr = 1 )           -- Признак ведения реестра по счету
        and a.Opened <= TO_DATE('2014-05-18','YYYY-MM-DD')
        and a.Closed  > TO_DATE('2014-05-18','YYYY-MM-DD')
        and a.SysFilial = 1
        )
select * from od.GENERALACCTREE

-- правил отчет BBR_TCB_BILLOWN_MFSO_REP_NEW для Огневой Т.С. из-за кривого векселя НН 0019436                                                                       ++

bill_p.percentsum

select rowid, b.* from bill b where num = '0019436' 

----------------------------------------------------------------------------------
--20/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------


-- выровнять DealSwapInterestLog по BKRZ на 500000000 - просила Бакумцева, чтобы не возникало ошибки "о невозможности росписи остатка по периодам начисления"        ++
select * from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)
delete from DealSwapInterestLog where paydoc in (select classified from doctree where docstate = 1000000037)

17 	AAARsTAA9AAHQmAACL	1359379396	226012817	226288385	1359379395	78767,120	31.07.2013	0
18 	AAARsTAA9AAHQmAACM	1359379401	226012817	228783643	1359379395	1575342,470	20.08.2013	0
19 	AAARsTAA9AAHQmAACN	1359379402	226012817	230448102	1359379399	866438,360	31.08.2013	0
20 	AAARsTAA9AAHQmAACP	1359379407	226012817	233249111	1359379399	1575342,460	20.09.2013	0
21 	AAARsTAA9AAHQmAACR	1359379415	226012817	234646974	1359379405	787671,230	30.09.2013	0
22 	AAARsTAA9AAHQmAACS	1359379416	226012817	237481787	1359379405	1654109,590	21.10.2013	0
11 	AAARsTAA9AAHQl9AAJ	1359379429	226012817	239096837	1359379411	787671,230	31.10.2013	0
12 	AAARsTAA9AAHQl9AAb	1359379433	226012817	241745170	1359379411	1575342,470	20.11.2013	0
13 	AAARsTAA9AAHQl9AA3	1359379434	226012817	243414113	1359379414	787671,230	30.11.2013	0
14 	AAARsTAA9AAHQl9ABm	1359379440	226012817	246464055	1359379414	1575342,470	20.12.2013	0
15 	AAARsTAA9AAHQl9ABy	1359379441	226012817	248080984	1359379419	866438,360	31.12.2013	0
16 	AAARsTAA9AAHQl9ABz	1359379442	226012817	249804778	1359379419	1575342,460	20.01.2014	0
1 	AAARsTAA6AAO87yAA8	1361217162	226012817	251617900	1359379423	866438,360	31.01.2014	0
2 	AAARsTAA6AAO87yAA9	1361217163	226012817	254511171	1359379423	1575342,460	20.02.2014	0
3 	AAARsTAA6AAO87yABA	1361217165	226012817	255753922	1359379428	630136,990	28.02.2014	0
5 	AAARsTAA6AAO87yABF	1361217167	226012817	258744761	1359379428	157534,240	20.03.2014	0
4 	AAARsTAA6AAO87yABB	1361217166	226012817	258744761	1359379431	1787671,240	20.03.2014	0
6 	AAARsTAA6AAO87yABG	1361217168	226012817	260342942	1359379438	1092465,750	31.03.2014	0
7 	AAARsTAA6AAO87yABH	1361217169	226012817	263828827	1359379438	2085616,440	21.04.2014	0
8 	AAARsTAA6AAO87yABP	1361217170	226012817	265462755	1361217146	595890,410	30.04.2014	0
9 	AAARsTAA6AAO87yABQ	1361217171	226012817	265462755	1361217148	297945,210	30.04.2014	0
10 	AAARsTAA6AAO87yABo	1361272381	226012817	268131505	1361217148	2143835,610	20.05.2014	0



-- BKRZ 500000000 00001                                                                                                                                              ++
select rowid, d.* from DealSwapInterestLog d where doc = 226012817 -- (157534,24 + 1787671,24) (297945,21 + 595890,41)
select 161095.89-80547.95 from dual

select * from DealSwapInterest where doc = 226012817 --1359379411  

select * from DealSwapPayPeriod where InterestPeriod in (select classified from DealSwapInterest where doc = 226012817)
select * from Dealswappayment where doc = 226012817

-- BKRZ 500000000 00002                                                                                                                                              ++

select rowid, d.* from DealSwapInterestLog d where doc = 226015768 

select * from DealSwapPayPeriod where InterestPeriod in (select classified from DealSwapInterest where doc = 226015768)

SELECT t.Username FROM t_users t WHERE t.id=:userid
select * from TimedOperLog where timedoper in (2361,2301,2105)
delete from TimedOperLog where timedoper in (2361,2301,2105)

select * from TimedOperLog where timedoper = 2952
delete TimedOperLog where timedoper = 2952 and opertype = 4

select  * from TimedOperLog where timedoper in (2361,2301,2105) -- doc = 261158586

od.MoveAllTimedSum2_TCB


select DiscSum_TCB2014(1344333749, to_date('30.04.2014','dd.mm.yyyy')) from dual

select * from bill where classified = 1344333749  

od.bill_p.DiscSum_TCB
od.getbillaccount

select (100000000-93000000)*(29/(29+31+30+31+31+30+31+30+18)) from dual
select * from balance where account = 265352489

select b.classified, ba.account PercentAccountID, a.*
   from bill b
  inner join BillAccount ba
     on ba.bill = b.classified
  inner join account a
     on a.classified = ba.account
  inner join BillAccIntention bai
     on bai.classified = ba.ACCINTENTION
    and bai.CONSTINTENTION in (3, 59)
  where ba.account = 265352489
UNION
select b.classified, ba.account PercentAccountID, a.*
   from billgroup b
  inner join BillAccount ba
     on ba.billgroup = b.classified
  inner join account a
     on a.classified = ba.account
  inner join BillAccIntention bai
     on bai.classified = ba.ACCINTENTION
    and bai.CONSTINTENTION in (3, 59)
  where ba.account = 265352489
  
  select * from BillAccIntention
  
  
  
  select * from billaccount where account = 265352489
  
  
select bb.classified, t.* from bill bb, 
  (select b.classified as bgclassified, ba.account PercentAccountID, a.*
   from billgroup b
  inner join BillAccount ba
     on ba.billgroup = b.classified
  inner join account a
     on a.classified = ba.account
  inner join BillAccIntention bai
     on bai.classified = ba.ACCINTENTION
    and bai.CONSTINTENTION in (3, 59)
  where ba.account = 265352489) t 
where t.bgclassified = bb.billgroup

od.FUNC_TCB_ACCGROUP_NEED

----------------------------------------------------------------------------------
--21/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select DiscSum_TCB2014(bb.classified, to_date('30.04.2014', 'dd.mm.yyyy')),
       sum(DiscSum_TCB2014(bb.classified, to_date('30.04.2014', 'dd.mm.yyyy'))) over(partition by t.PercentAccountID), -- 1 633 333,34
       
       DiscSum_TCB2014(bb.classified, to_date('19.05.2014', 'dd.mm.yyyy')),
       sum(DiscSum_TCB2014(bb.classified, to_date('19.05.2014', 'dd.mm.yyyy'))) over(partition by t.PercentAccountID), -- 2 703 448,27

       bb.classified,
       t.*
  from bill bb,
       
       (select b.classified as bgclassified,
               ba.account   PercentAccountID,
               a.*
          from billgroup b
         inner join BillAccount ba
            on ba.billgroup = b.classified
         inner join account a
            on a.classified = ba.account
         inner join BillAccIntention bai
            on bai.classified = ba.ACCINTENTION
           and bai.CONSTINTENTION in (59)
         where ba.account = 265352489) t

where t.bgclassified = bb.billgroup
   and Bill_p.RepayDate(bb.classified) > '30.04.2014'
   
select DiscSum_TCB2014(1344333749, to_date('30.04.2014', 'dd.mm.yyyy')), DiscSum_TCB2014(1344333749, to_date('19.05.2014', 'dd.mm.yyyy')) from dual


select * from Deposecurity where label = 'Шишова Е.А.'
select * from syscertificate

select * from sysfilial

----------------------------------------------------------------------------------
--23/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- написал процедуру DPC_CheckFilial_TCB (по просьбе Герасимовой), чтобы запретить филиалам выдавать векселя => осталось только включить IPI 191058 =>
-- 17/06/2014 отключил для Перми => ждем отмашки на отключение процедуры => 11/07/2014 отключил процедуру                                                            ++

create or replace procedure DPC_CheckFilial_TCB
/**********************************************************************************
Описание: процедура проверки филиала, в котором проводится операция 
23/05/2014 Панфилов М.С.
**********************************************************************************/
as
   nFilial sysfilial.code%type;
begin
   select sysfilial into nFilial from doctree where classified = Context.CurrentDoc;
   if nFilial != 1 and nFilial != 2 then
      raise_application_error(-20000, 'Выдачу собственных векселей делать запрещено! (по всем вопросам обащайтесь к Герасимовой Е.М.)');
   end if;
end DPC_CheckFilial_TCB; 


----------------------------------------------------------------------------------
--26/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from sysfilial

od.UT_DealCalcTSS_TCB

select * from dealpact where doc = 166998604
select * from client where classified = 149101733 
select * from doctree where classified = 166998604

create or replace procedure UT_DealCalcTSS_TCB(
----------------------------------------------------------------------------------------------------------------------------
-- Описание: Переоценка ТСС по сделкам ПФИ. (на основе UT_DealCFVRevaluation)
-- 29/01/2014 Панфилов М.С.
-- Параметры:
--       dtiDate         - дата переоценки
--       nCategory_      - категория документов (все ПФИ)
--       nMode           - режим работы утилиты: переоценка - 1 / откат - 2
--       nIsEchDealLog   - вести ли логирование успешной обработки сделок (сделка, документы переоценки, расчетов)
--       nIsCommitDoc    - фиксации транзакции после каждой успешной обработки сделки ("да" по умолчанию) нет
--       nProcessLockDoc - режим переоценки даже заблокированных сделок (по-умолчанию нет) да

-- 26/05/2014 Панфилов М.С. подправил формирование лога и ошибку при большом колическве сделок (sDesc2)
----------------------------------------------------------------------------------------------------------------------------
   dtiDate         Date,
   nCategory_      DT.ConstValue default null,
   nMode           DT.Status     default 1,
   nIsEchDealLog   DT.Status     default 1,
   nIsCommitDoc    DT.Status     default 0,
   nProcessLockDoc DT.Status     default 1
) is
   dtDate          Date := s.ysDate;
   nCategory       DT.ConstValue;
   nTSS913Group    DT.ConstValue;        -- ведется ли учет ТСС по группе
   nTSS914Group    DT.ConstValue;        -- ведется ли учет ТСС по группе
   nCnt            DT.Counter := 0;
   nErr            DT.Counter := 0;
   nSucc           DT.Counter;
   --  для отбора
   sSqlExpr        DT.Text4000;         -- текст запроса
   type            T_PactType is ref cursor;
   curPact         T_PactType;  -- курсор
   -- тип для отбора сделок;
   type            tPact       is record(nDoc           DT.Reference,
                                         nSubSystem     DocTree.SubSystem%type);
   recPact         tPact;
   recPact2        DealPact%RowType;
   nDeal           DT.Reference;
   nIsMid          Dt.Status;
   idMessage       DT.Reference;
   sReturn         DT.LongText;
   sUTDesc         DT.Description;
   sMessage        DT.Label;
   nExists         Dt.Status;
   nextdeal        exception;
   --
   sPact           Dt.Text;
   sGroup          Dt.Label;
   sCatGroup       Dt.Label;
   nTssAmount      Dt.Amount;
   sDesc           Dt.Text;
   sCrlf           constant DT.Label := CHR(13)||CHR(10);
   nSysContext     DT.Reference;
   nLockMode       DT.Status;   -- режим блокировки
   nRequest_status DT.Quantity;

   nTransfer       DT.Reference;
   tempSum         DT.Amount;   -- остаток, который должен быть на счетах 52601/52602 после этой переоценки
   tempSum2        DT.Amount;   -- дельта
   acc52601        DT.Reference;
   acc52602        DT.Reference;
   acc70614        DT.Reference;
   acc70613        DT.Reference;
   nRest526Old     DT.Amount;   -- сумма остатка на счетах 52601/52602 до этой переоценки
   accDeb          DT.Reference;
   accCred         DT.Reference;
   
   sClient         DT.Label;             -- контрагент по договору
   nCntDeals       DT.Counter;           -- количество сделок
   sDatDeals       DT.Description;       -- данные сделок
   accrest52601    Balance.Amount%type;  -- остаток на счете 52601
   accrest52602    Balance.Amount%type;  -- остаток на счете 52602
   
   sDesc2          Dt.Description;

   -- определение отбора сделок
   function loc_GetSql
   --
   return DT.Text4000
   is
      sRet  DT.Text4000;
   begin
               sRet := 'select dp.doc, dtr.subsystem from dealpact dp, doctree dtr where dp.doc = dtr.classified and exists '||
                        ' (select d.doc from deal d, doctree dt where d.pact = dp.doc and dt.classified = d.doc '||
                        ' and dt.category = 901 and d.AccMethod in(1,2) and dt.docstate not in (1000000036, 1000000037) '||
                        ' and to_date('''|| trunc(dtDate) ||''',''dd/mm/yyyy'') >= d.dealdate '||
                        ' and to_date('''|| trunc(dtDate) ||''',''dd/mm/yyyy'') <= d.valuedate)';
      return sRet;
   end loc_GetSql;
begin
   if nMode not in (1, 2) then
      return;
   end if;
   dtDate := nvl(dtiDate, s.ysDate);
   -- проверка операционной даты
   if trunc(dtDate) != trunc(s.ysDate) then
      -- если архивная дата отличается от параметра, выставим архивную дату - переоценка скореее всего выполняется за пред. день
      nSysContext := Context.SetContext(null, trunc(dtDate)+1 -1/86400, 9);
   end if;
   nCategory := nvl(nCategory_, 0);
   nTSS913Group := i.f(DealPFI.IsTSS913Group = 1, 913, 0);
   nTSS914Group := i.f(DealPFI.IsTSS914Group = 1, 914, 0);
   if nMode = 1 then
      sUTDesc := 'Переоценка ТСС по сделкам ПФИ за ' ||dtDate;
      sMessage := 'PFIRevaluation';
   else
      sUTDesc := 'Откат переоценки ТСС по сделкам ПФИ за ' ||dtDate;
      sMessage := 'PFIRevaluation_RB';
   end if;
   sDesc :=  'Параметры операции: '||sCrlf||
             'Дата "'||dtDate||'"'||sCrlf||
             'Категория сделок "'||i.f(nCategory = 0, 'FXLong', CategoryLabel(nCategory))||'"'||sCrlf||
             'Режим "'||i.f(nMode = 1, 'Переоценка','Откат переоценки')||'"'||sCrlf||
             'Подробный отчет по сделкам в журнале "'||i.f(nIsEchDealLog = 1, 'Да','Нет')||'"'||sCrlf||
             'Фиксация транзакции после каждой успешной обработки сделки "'||i.f(nIsCommitDoc = 1, 'Да','Нет')||'"'||sCrlf||
             'Режим переоценки даже заблокированных сделок "'||i.f(nProcessLockDoc = 1, 'Да','Нет')||'".';
   EventService.StartLog(3, 0, 'UT_DealCalcTSS_TCB', sUTDesc);
   EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sUTDesc, sDesc);
   sSqlExpr := loc_GetSql;
   -- insert into DealTemp(sSql) values (sSqlExpr); commit;
   dbms_output.put_line('nCategory = '||nCategory||' nTSS913Group = '||nTSS913Group||' nTSS914Group = '||nTSS914Group||' sSqlExpr = '||sSqlExpr);
   open curPact for sSqlExpr/* using in trunc(dtDate), trunc(dtDate), nCategory, nTSS913Group, nTSS914Group,
                                      trunc(dtDate), trunc(dtDate), nCategory, nTSS913Group, nTSS914Group*/;
   loop
      begin
         dbms_output.put_line('open curPact');
         fetch curPact into recPact;
         --
         exit when curPact%notfound;
         --
         savepoint sp1;
         nCnt := nCnt + 1;
         tempSum := 0;
         nRest526Old := 0;

         dbms_output.put_line('---1 rec.nDoc = '|| recPact.nDoc ||' dtDate = '|| dtDate);

         -- определим счета по договору
         select account into acc52601 from dealaccount
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (83));
         select account into acc52602 from dealaccount
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (84));
         select account into acc70614 from dealaccount
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (85));
         select account into acc70613 from dealaccount
         where doc = recPact.nDoc and accintention in (select classified from dealaccintention where constintention in (86));

         dbms_output.put_line('--- 2');
         
         -- определим текущие остатки на счетах 52601/52602
         accrest52601 := od.accountbalance(acc52601,dtDate) * (-1); -- счет активный, поэтому остаток в таблице balance в основном минусовый
         accrest52602 := od.accountbalance(acc52602,dtDate);
         
         dbms_output.put_line('--- accrest52601: ' || accrest52601);
         dbms_output.put_line('--- accrest52602: ' || accrest52602);

         -- определим остаток на счетах 52601/52602, который должен быть после переоценки
         select sum(round((AMOUNTB*Rate(CURRENCYB,1000001275,pref.exchmatrix,trunc(dtDate))),2)
                - round((AMOUNTS*Rate(CURRENCYS,1000001275,pref.exchmatrix,trunc(dtDate))),2)) into tempSum
         from deal d, doctree dt where d.pact = recPact.nDoc and dt.classified = d.doc
                        and dt.category = 901 and d.AccMethod in(1,2) and dt.docstate not in (Constants.State_RollBack, Constants.State_Cancel)
                        and dtDate >= d.dealdate and dtDate <= d.valuedate;
         
         -- вычисляем дельту
         if accrest52601 != 0 then
           if tempSum > accrest52601 then
             tempSum2 := tempSum - accrest52601;
           else
             tempSum2 := accrest52601 - tempSum;
           end if;
         else -- accrest52602 != 0
           if tempSum < ((-1)*accrest52602) then
             tempSum2 := abs(tempSum) - accrest52602;
           else
             tempSum2 := accrest52602 + tempSum;
           end if;
         end if;
         
         dbms_output.put_line('--- 2 ' || tempSum);
         dbms_output.put_line('--- 2 ' || tempSum2);
         
         sPact := 'Договор № '||DoctreeLabel(recPact.nDoc);
         --EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sPact, sPact);
         --EventService.PutEvent(45, 'UT_DealCalcTSS_TCB', sPact, sPact);
         
         -- определим контрагента по договору
         select od.getclientlabel(client) into sClient from dealpact where doc = recPact.nDoc;
         
         dbms_output.put_line('--- 3 ' || sClient);
         
         -- определим номера, даты сделок и их количество
         nCntDeals := 0;
         sDatDeals := '';
         /*for recDeal in (
                select  dt.label, d.dealdate
                from deal d, doctree dt where d.pact = recPact.nDoc and dt.classified = d.doc
                        and dt.category = 901 and d.AccMethod in(1,2) and dt.docstate not in (Constants.State_RollBack, Constants.State_Cancel)
                        and dtDate >= d.dealdate and dtDate <= d.valuedate
           )
         loop
           nCntDeals := nCntDeals + 1;
           sDatDeals := sDatDeals || ' № ' || recDeal.label || ' от ' || recDeal.dealdate || ',';
         end loop;*/
         
         begin
         for recDeal in (
                select  dt.label, d.dealdate
                from deal d, doctree dt where d.pact = recPact.nDoc and dt.classified = d.doc
                        and dt.category = 901 and d.AccMethod in(1,2) and dt.docstate not in (Constants.State_RollBack, Constants.State_Cancel)
                        and dtDate >= d.dealdate and dtDate <= d.valuedate
           )
         loop
           nCntDeals := nCntDeals + 1;
           sDatDeals := sDatDeals || ' № ' || recDeal.label || ' от ' || recDeal.dealdate || ',';
           
           dbms_output.put_line('--- 4 ' || sDatDeals);
           
         end loop;
         exception when others then sDatDeals := '';
         end;
         
         dbms_output.put_line('--- 5 ' || sDatDeals);
         
         sDatDeals := rtrim(sDatDeals,',');
         
         /*sDesc := 'Переоценка ТСС по договору " № '||DoctreeLabel(recPact.nDoc)||' ". Сумма переоценки "'||abs(tempSum)||'" RUR';*/
         if nCntDeals = 1 then
           sDesc2 := substr('Отражение справедливой стоимости сделки' || sDatDeals || ' с ' || sClient,0,254);
           sDesc := 'Отражение справедливой стоимости сделки' || sDatDeals || ' с ' || sClient;
         else
           sDesc2 := substr('Отражение справедливой стоимости сделок' || sDatDeals || ' с ' || sClient,0,254);
           sDesc := 'Отражение справедливой стоимости сделок' || sDatDeals || ' с ' || sClient;
         end if;
         
         dbms_output.put_line('--- 5 ' || sDesc2);

         -- в зависимости от tempSum определим счета Дт Кт в результирующей проводке
         /*if tempSum >= 0 then
           accDeb  := acc52602;
           accCred := acc70613;
         else
           accDeb  := acc70614;
           accCred := acc52601;
         end if;*/
         
         if accrest52601 = 0 and accrest52602 = 0 then
            if tempSum >= 0 then
               accDeb  := acc52601;
               accCred := acc70613;
            else
               accDeb  := acc70614;
               accCred := acc52602;
            end if;
         else
           if accrest52601 != 0 then
             if tempSum > accrest52601 then
               accDeb  := acc52601;
               accCred := acc70614;
             else
               accDeb  := acc70613;
               accCred := acc52601;
             end if;
           else -- accrest52602 != 0
             if tempSum < ((-1)*accrest52602) then
               accDeb  := acc70613;
               accCred := acc52602;
             else
               accDeb  := acc52602;
               accCred := acc70614;
             end if;
           end if;
         end if;

         -- создаем и исполняем перевод
         nTransfer := Easy_IntTransCreate(1047492427,                      -- тип документа (Внутренний перевод Дилинг)
                                          Constants.GetGenIntention(927),  -- назначение генерации
                                          null,                            -- родительский документ
                                          recPact.nSubSystem,              -- подсистема
                                          accDeb,                          -- cчет дебета
                                          accCred,                         -- cчет кредита
                                          abs(tempSum2),                    -- cумма
                                          1000001275,                      -- валюта суммы (рубли)
                                          dtDate,                          -- дата создания
                                          nCnt/*DoctreeLabel(recPact.nDoc)*/,      -- номер документа
                                          sDesc2,                           -- назначение платежа
                                          dtValidDate => dtDate            -- дата валютирования
                                          );
         DocProcessForChild(nTransfer, Context.OperDate, recPact.nSubSystem, Constants.State_Close, false, false);

         EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sDesc, sDesc);
         EventService.PutEvent(45, 'UT_DealCalcTSS_TCB', sDesc, sDesc);

         --  манипуляции с параметром nProcessLockDoc
         /*if nProcessLockDoc = 1 then
            dbms_output.put_line('nProcessLockDoc = 1');
            -- проверяем блокировку сделки
            nRequest_status := teller_proc.lock_doc(recDeal.nDoc);
            dbms_output.put_line('nRequest_status='||nRequest_status);
            if nRequest_status = 0 then
               -- Разблокируем объект
               teller_proc.lock_release(recDeal.nDoc);
               dbms_output.put_line('lock_release');
               -- сделка свободна - штатная работа с обычной блокировкой
               nLockMode := 2;
            else
               -- Сделка уже заблокирована - обработка в спец. режиме
               nLockMode := 0;
               sDeal2 := 'Сделка('||DealTypeLabel(recDeal2.DealType)||') № '||DoctreeLabel(recDeal.nDoc)||'('||recDeal.nDoc||')'||
                     i.f(GetSwappedDeal(recDeal.nDoc) is not null, ', FX своп ', ' ')||' обработана заблокированной.';

               EventService.PutEvent(56, 'UT_DealCFVRevaluation', sDeal2, 'В процессе переоценки сделка была заблокирована другим пользователем !');
            end if;
         else
            -- обычный режим
            nLockMode := 2;
         end if;*/
         --
         /*idMessage := Message.Send(sReturn, Constants.GetEntityMessage(sMessage), recDeal.nDoc, GetDocType(recDeal.nDoc), Context.OperDate, nLockMode => nLockMode);*/
         --


         -- статистика
         /*if nIsEchDealLog = 1 then
            -- сумма текущей ТСС
            nTssAmount := GetTssByDeal(nDeal, 1, dtDate, DealPFI.GetTSSExchMatrix);
            EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDeal, 'Сумма расcчитанной переоценки "'||nTssAmount||'" RUR');
            -- проводки переоценки
            for rec in (select BO.SumAccount, DCT.Label, BO.Doc
                          from Doctree DCT, GenIntention GI, BankOper BO
                         where DCT.Parent = recDeal.nDoc
                           and DCT.Classified = BO.Doc
                           and DCT.DocType in (select Classified from Doctype where Category = 5)
                           and DCT.GenIntention = GI.Classified
                           and GI.ConstIntention in (927)
                           and trunc(DCT.ValidFromDate) = trunc(dtDate)
                           and DCT.DocState not in (Constants.State_RollBack, Constants.State_Cancel)
                      order by DCT.Classified asc )
            loop
               sDesc := 'Документ "'||rec.Label||'('||rec.Doc||')" сумма переоценки "'||rec.SumAccount||'" RUR';
               EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDesc, sDesc);
               EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDesc, sDesc);
            end loop;
            -- инициированные расчеты
            for rec in (select DCT.Label, BO.Doc
                          from Doctree DCT, GenIntention GI, BankOper BO, PrepareMoney PM
                         where DCT.Parent = recDeal.nDoc
                           and DCT.Classified = BO.Doc
                           and BO.Doc = PM.Doc
                           and DCT.DocType in (select Classified from Doctype where Category = 5)
                           and DCT.GenIntention = GI.Classified
                           and GI.ConstIntention in (923, 926, 4)
                           and trunc(DCT.ValidFromDate) = trunc(dtDate)
                           and DCT.DocState not in (Constants.State_RollBack, Constants.State_Cancel)
                           and (BO.Account in (select Account from DealAccount
                                                where Doc = DCT.Parent
                                                  and AccIntention in (select Classified from DealAccIntention
                                                                        where ConstIntention in(83,84,85,86,87,11,12,36,37,29,30,38,39))
                                               )
                                or
                                PM.Account in (select Account from DealAccount
                                                where Doc = DCT.Parent
                                                  and AccIntention in (select Classified from DealAccIntention
                                                                      where ConstIntention in(83,84,85,86,87,11,12,36,37,29,30,38,39))
                                               )
                                )
                      order by DCT.Classified asc )
            loop
               sDesc := 'Документ "'||rec.Label||'('||rec.Doc||')"';
               EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDesc, sDesc);
               EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDesc, sDesc);
            end loop;
            -- Срочные переводы
            for rec in (select DCT.Label, DCT.Classified
                          from Doctree DCT, GenIntention GI
                         where DCT.Parent = recDeal.nDoc
                           and DCT.DocType in (select Classified from Doctype where Category = 70)
                           and DCT.GenIntention = GI.Classified
                           and GI.ConstIntention in (923, 37, 941)    -- Закрытие срочных сделок, перенос на баланс
                           and trunc(DCT.ValidFromDate) = trunc(dtDate)
                           and DCT.DocState not in (Constants.State_RollBack, Constants.State_Cancel)
                         order by DCT.Classified asc)
            loop
               sDesc := 'Документ срочного перевода "'||rec.Label||'('||rec.Classified||')"';
               EventService.PutEvent(35, 'UT_DealCFVRevaluation', sDesc, sDesc);
               EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDesc, sDesc);
            end loop;
            --
            EventService.PutEvent(45, 'UT_DealCFVRevaluation', sDeal, 'Сумма раcсчитанной переоценки "'||nTssAmount||'" RUR');
         end if;*/
         --
         dbms_output.put_line('executed');
         if nIsCommitDoc = 1 then
            commit;
         end if;
      exception
         when nextdeal then
            null;
         when others then
            rollback to sp1;
            nErr := nErr + 1;
            EventService.PutEvent(35, 'UT_DealCalcTSS_TCB', sPact, sPact);
            EventService.PutEvent(121, 'UT_DealCalcTSS_TCB', 'Ошибка при обработке договора', SqlErrm);
            EventService.PutEvent(45, 'UT_DealCalcTSS_TCB', sPact, sPact);
            dbms_output.put_line('ОШИБКА на Pact = '||recPact.nDoc||' SqlErrm = '||SqlErrm);
      end;
   end loop;
   if curPact%IsOpen then
      close curPact;
   end if;
   nSucc := nCnt - nErr;
   EventService.PutEvent(45, 'UT_DealCalcTSS_TCB', sUTDesc,
    'Обработано сделок "'||nCnt||'" '||sCrlf||
    'Из них успешных "'||nSucc||'" '||sCrlf||
    'Ошибочных "'||nErr||'".');
   EventService.EndLog;
   if nSysContext is not null then
      Context.RestoreContext(nSysContext);
   end if;
exception
   when others then
      if nSysContext is not null then
         Context.RestoreContext(nSysContext);
      end if;
      raise;
end UT_DealCalcTSS_TCB;


select * from EventType

----------------------------------------------------------------------------------
--27/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.deal_createaccount_tcb
od.deal_createaccount

select * from dealaccount where contextvalue is not null
select * from accounttype
select * from GeneralToAccount 

----------------------------------------------------------------------------------
--28/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from account where code = '31402810000000007388'
select * fr

select * from balance where account = 52524970
select (accountbalance(52524970,to_date('31/03/2014','dd/mm/yyyy')+1)*rate(1000001275,1000001275,1000131199,to_date('31/03/2014','dd/mm/yyyy')+1))/1000 from dual
select (reestrrestout(260409972,to_date('31/03/2014','dd/mm/yyyy')+1)*rate(1000001275,1000001275,1000131199,to_date('31/03/2014','dd/mm/yyyy')+1))/1000 from dual
(reestrrestout(da2.rsaccount,:DT+1)*rate(d.currencyb,1000001275,1000131199,:DT+1))/1000

select * from dealaccount where doc = 260408489

select * from od.accountwithreestr where account = 52524970 -- classified = 260409972

select * from reestr where accountwithreestr = 1116806486 and reestrinit = 260409972
select * from reestrdoc where accountwithreestr = 1116806486


select * from account where code = '31407978400000007388'
select * from od.accountwithreestr where account = 46983450 -- classified = 1122133649

select * from dealaccount where doc = 258187344 -- 258189001
select * from dealaccount where doc = 255496628 -- 255500744

select * from reestr where accountwithreestr = 1122133649 and reestrinit in (258189001,255500744)
select * from reestrdoc where accountwithreestr = 1122133649

select (reestrrestout(255500744,to_date('31/03/2014','dd/mm/yyyy'))*rate(1000119259,1000001275,1000131199,to_date('31/03/2014','dd/mm/yyyy')))/1000 from dual

select 2000*48.968 from dual
select 2000*49.0519 from dual


select * from currency

-- правил отчет в RN "Отчет_финдеп (привлечение)" для Огневой IPI 191265 => тестит, закрыть задачу                                                                   ++
-- убрал + 1 день при вычислении курса
-- 28/05/2014 сделал костыль, чтобы не было нулевых сумм по ОД на реестрах по обычным сделкам, если есть проблемы с реестрами и квитовкой плановых
-- 29/05/2014 добавил колонку "Срок до погашения к дате отчета план."

----------------------------------------------------------------------------------
--29/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.FUNC_TCB_BILL_NOM_P_NAL_2013

select * -- profile, sum(limit) 
from DBA_PROFILES
where limit is not null and limit not like '%U%'
group by profile


select PP.PayReq, DT.Label
  from v_DealPactPayReq PP, v_DocTree DT, v_DealTransactio T 
 where PP.Doc = 224361522
   and DT.Category = 912 
   and DT.Classified = PP.PayReq 
   and (PP.DealType = 1179849837 or PP.DealType is null) 
   and DT.DocState = 1000000039 
   and T.Doc = DT.Classified 
   and PP.Category = 928 
 order by case when T.Currency = 1000001275 then 1 else 2 end asc, T.Currency, PP.Priority, DT.Label

----------------------------------------------------------------------------------
--30/05/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- поменял по векселю 0019440 дату Date1 на 02062014 - просила Цыплина (Нижний Новгород) счет 523* остался *05*, хотя по-хорошему надо *04*                          ++
select * from bill where num = '0019440' and classified = 1329768439
update bill set Date1 = to_date('02062014','ddmmyyyy') where num = '0019440' and classified = 1329768439

select * from doccategory
od.DPC_BillFactPayDate

-- написал процедуру DPC_BillFactPayDClear_TCB, чтобы не приходилось вручную затирать даты фактического погашения на повторноучитываемых векселях                    ++
-- привязал процедуру на "Учет векселя"                                                                                                                              ++
create or replace procedure DPC_BillFactPayDClear_TCB
/**********************************************************************************
очистка фактической даты погашения векселей (на основе DPC_BillFactPayDate)
Для операции "Учет векселя"
30/05/2014 Панфилов М.С.
**********************************************************************************/
   is
     dtDate  Date;
  begin
     if GetDocCategory(Message.IdObject) = 711 then
     update Bill set RepayDate = null where Classified in (select Bill from BillRange where Doc = Message.IdObject);
     else
       return;
     end if;
end DPC_BillFactPayDClear_TCB;


----------------------------------------------------------------------------------
--02/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- поменял наименование банка ТКБ с ЗАО на ОАО в шаблонах Word T:\BBRWORD\TMP и в отчетах по векселям                                                                ++

bbr.REPSIGNATURE(getrepblank)

bbr.BBR_CREDSIGNATURE_TCB

bbr.BBR_TCB_LOAN_HEAD(100);  

od.Mainbankname_tcb
od.Mainbankname

select * from Preference

select * from Client where classified = 1

bbr.BBR_DOC_SWIFT

----------------------------------------------------------------------------------
--03/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------
-- правил для Антиповой bbr.BBR_TCB_BILL_RASP_CLOSE_ACC, чтобы быстрее работало                                                                                      ++
-- отключил в схеме проводок проводку ДТ99999 КТ90705 при выдаче векселя (на "Исполнить") по просьбе Герасимовой                                                     ++


select * from doccategory

select ba.account, acccode(ba.account), acclabel(ba.account), ba.bill, ba.accintention from billaccount ba where 
ba.bill in  
(select bill from billoper where doc in (select classified from doctree where 
(category = 703 or doctype = 1155771305) and operdate >= to_date('30.05.2014','dd.mm.yyyy') and operdate <= to_date('31.05.2014','dd.mm.yyyy') and sysfilial = 1 and docstate = 1000000035)
--and exists (select classified from doctree where classified = ba.account and docstate = 1000000039)
--and (acccode(ba.account) like '523%' or acccode(ba.account) like '52501%' or acccode(ba.account) like '52503%' or acccode(ba.account) like '52406%')
UNION
select bill from billrange where doc in (select classified from doctree where 
(category = 703 or doctype = 1155771305) and operdate >= to_date('30.05.2014','dd.mm.yyyy') and operdate <= to_date('31.05.2014','dd.mm.yyyy')  and sysfilial = 1 and docstate = 1000000035))


and ba.accintention in (1011996343,1011996468,1011996336,1011996470) 
and exists (select classified from doctree where classified = ba.account and docstate = 1000000039)
and (acccode(ba.account) like '523%' or acccode(ba.account) like '52501%' or acccode(ba.account) like '52503%' or acccode(ba.account) like '52406%')


UNION
-- залоги и хранения
select ba.account, acccode(ba.account), acclabel(ba.account), ba.bill, ba.accintention from billaccount ba where 
 ba.pact in
(
select doc from billstatushistory where bill in 
(
select bill from billoper where doc in (
select dt.classified from doctree dt where 
dt.doctype in (1110316673,1113093181/*новые залоги и хранения*/) and dt.operdate >= to_date('30.05.2014','dd.mm.yyyy') and dt.operdate <= to_date('31.05.2014','dd.mm.yyyy') and dt.sysfilial = 1 and dt.docstate = 1000000035)
union
select bill from billrange where doc in (
select dt.classified from doctree dt where 
dt.doctype in (1110316673,1113093181/*новые залоги и хранения*/) and dt.operdate >= to_date('30.05.2014','dd.mm.yyyy') and dt.operdate <= to_date('31.05.2014','dd.mm.yyyy') and dt.sysfilial = 1 and dt.docstate = 1000000035)
) and status in (34,38) 
    and enddate <= to_date('31.05.2014','dd.mm.yyyy')
    and enddate >= to_date('30.05.2014','dd.mm.yyyy')
)
and exists (select * from doctree where classified = ba.account and docstate = 1000000039)
and (acccode(ba.account) like '91202%'  or acccode(ba.account) like '90803%' /*новые счета по залогам и хранениям*/)
and od.accountBalance(ba.account,to_date('31.05.2014','dd.mm.yyyy')) = 0
order by 4

----------------------------------------------------------------------------------
--04/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from doctree where classified = 270684092
select * from doctree where classified = 270665988
select * from doctype where classified = 1047166507

select BENEFICIARYBANKCODE, od.FindClientByCode(BENEFICIARYBANKCODE,BENEFICIARYCODETYPE) --into sBeneficiaryBSWIFT, nBeneficiaryB
from CUSTOMERISO where doc = 270693868

select bc.code, bc.* --into sBeneficiarySWIFT
from CUSTOMERTRANSFER c, bankcode bc where c.doc = 270693868 and c.BENEFICIARY = bc.client and bc.codesystem = 1000004993
and td >= bc.validfromdate and td <= nvl(bc.validtodate,max_date)
BBR.BBR_RASP_DILING_MT202_TCB
swift.

select * from v$session where machine ='TCB\VOINKOV-OV'or machine = 'voinkov-ov' --  status = 'ACTIVE' -- where schemaname = 'OD'

select * from sys.v_$session_connect_info where osuser = 'panfilov_ms' and client_driver = 'jdbcthin'


----------------------------------------------------------------------------------
--05/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------


select dt.category, d.*, dt.*
  from dealaccount d
inner join account a
    on a.classified = d.account
   and a.code in('47407978200000403480','47407978200000403176')
inner join doctree dt
    on dt.classified = d.doc

select * from account where classified in (57871204,81081966)
select * from accountwithreestr where account in (57871204,81081966)

select * from doccategory

----------------------------------------------------------------------------------
--06/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from balance where account = 65225996
select * from billsumtype

select (select (riskperc/100)*od.bc.getbillsum(classified,23) from bill b where classified = ba.bill) 
from billaccount ba where account = 65225996 -- 51510810600100000047

select 
446219.21+
892438.43+
446219.21+
446219.21+
446219.21+
446219.21+
446219.21+
446219.21+
818960.29+
446219.21+
446219.21+
446219.21+
446219.21
from dual

select * from entitymethod where classified = 1207196408

declare
 sCode1 VarChar2(50);
begin
 if Is_to_DEV(Context.CurrentDoc) = 1 then
  select acccode(b.Account) into sCode1
   from BankOper b where b.Doc=Context.CurrentDoc;
  if sCode1 = '30232810700001000017' then
   :nCondResult := 0;
  else
   :nCondResult := 1;
  end if; 
 end if; 
end;

BBR.BBR_TCB_TRANSACT_2WH_XML





CREATE OR REPLACE PROCEDURE BBR_TCB_TRANSACT_2WH_XML (
   dBegDate_ IN DATE,
   dEndDate_ IN DATE,
   nSysFilial_ IN NUMBER,
   nAccCat IN NUMBER
   
   --nChange IN NUMBER,
   --nDel IN NUMBER,
   --PageSize IN dt.ConstValue DEFAULT 40,
   --nStrata IN dt.ConstValue DEFAULT 255,
   --SysMode IN dt.ConstValue DEFAULT 0
)
AS
   j NUMBER;
   sDoc VARCHAR2(10000);
   sInitiator VARCHAR2(4000);
   dOperDate DATE;
   --nRur NUMBER;
   --sPathName VARCHAR2(4000);
   FilialCode VARCHAR2(4000);
   dEndDate DATE;
   dBegDate DATE;
   nSysFilial NUMBER;
BEGIN
   dBegDate := dBegDate_;
   dEndDate := dEndDate_+1;
   nSysFilial := nvl(nSysFilial_,1);

--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   
/*
dBegDate:= GETDOCID_2WH();
dEndDate:= dBegDate + 1;
IF nSysFilial < 16 then
   nSysFilial:= 95;
end if;   

   IF nSysFilial NOT IN (5,10,8,15,16,17,18) THEN
      nSysFilial:= 95;
   END IF;

IF nSysFilial = '1' then
   nSysFilial:='999';
   FilialCode:='9999';
end if;
*/
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   FilialCode := case nSysFilial
                   when 1  then '9100'
                   when 2  then '8010'
                   when 3  then '8060'
                   when 4  then '8020'
                   when 5  then '8120'
                   when 6  then '8050'
                   when 8  then '8150'
                   when 9  then '8030'
                   when 10 then '8130'
                   when 11 then '8100'
                   when 12 then '8110'
                   when 13 then '8080'
                   when 14 then '8040'
                   when 15 then '8170'
                   when 16 then '8180'
                   when 17 then '8190'
                   when 18 then '8200'
                   when 19 then '8140'
                   when 20 then '8090'
                   when 21 then '8210'
                   else ''
                 end;
   

   INSERT INTO bbr.TO_DATAWAREHOUSE_LOG (ID,LOG_TIME,FILIAL,PROC_NAME,LOG_TEXT) 
   VALUES(bbr_tcb.NEXTVAL,sysdate,FilialCode,'BBR_TCB_TRANSACT_2WH_XML','Начало выгрузки документов. dBegDate: ' || dBegDate || ', dEndDate: ' || dEndDate);
   commit;

---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   IF 1 = 2 THEN
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      dOperDate := dBegDate;
      WHILE dOperDate < dEndDate LOOP
      NULL;
    
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'<УдалитьДокументы>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Филиал>' || FilialCode || '</Филиал>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ФормаДокументов>Мем_орд</ФормаДокументов>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'</УдалитьДокументы>');
     
    dOperDate := dOperDate + 1; 
      END LOOP;
   END IF;
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   IF 1 = 0 THEN -- mmi удаление вынесено в BBR_TCB_TRANSACT_DEL_2WH_XML
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      DECLARE
         CURSOR CycleQuery IS SELECT Classified
         FROM DocTree
         WHERE 
              ((OperDate >= dBegDate and OperDate < dEndDate) or (UserDate >= dBegDate and UserDate < dEndDate))
              and SysFilial = nSysFilial
              and docstate = 1000000037
              and doctype in (1000135265,1000135286) -- mmi
         ;
         nDTClass NUMBER;
      BEGIN
         OPEN CycleQuery;
         FETCH CycleQuery INTO nDTClass;
         IF CycleQuery%FOUND THEN 
            NULL;
            LOOP
            EXIT WHEN CycleQuery%NOTFOUND;
      
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'<Документ>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Код>' ||  nDTClass || '/' || FilialCode || '</Код>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ОперацияНадОбъектом Метод="delete"/>' );
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'</Документ>');
         
               FETCH CycleQuery INTO nDTClass;
               EXIT WHEN CycleQuery%NOTFOUND;
            END LOOP;
            NULL;
         END IF;
         CLOSE CycleQuery;
      END;
   END IF;
   sDoc:='Select /*+ index (a sys_c001634) index (a1 sys_c001634)*/ 
                 Trunc(b.OperDate), 
                 b.Classified,
                 REPLACE(REPLACE(REPLACE(REPLACE(b.LABEL,''&'',''&amp;''),''"'',''&quot;''),''>'',''&gt;''),''<'',''&lt;'') as Label,
                 b.CATEGORY,
                 a.client,
                 TRUNC(b.pDate),
                 b.operobj,
                 a.Code,
                 a.foldaccount,
                 CurrencyCB(a.currency),
                 NVL(MinorUnit(a.currency),2),
                 a1.Code,
                 a1.foldaccount,
                 CurrencyCB(a1.currency),
                 NVL(MinorUnit(a.currency),2),
                 b.AmountDeb,
                 b.AmountCred,
                 b.AmountRurDeb,
                 b.IsEndTurn,
                 DECODE(b.amountdeb,0,b.mocred,b.modeb) Kode,
                 DECODE(b.bCATEGORY,2,''А'',3,''В'',66,''Г'',67,''Б'',''''),
                 GetObjDesc(b.classified,1051764777),
                 GetObjDesc(b.classified,1063879930),
                 GetObjDesc(b.classified,1018917921),
                 od.TCB_DWH.GetDocProduct(DECODE(b.amountdeb,0,b.mocred,b.modeb)),
                 GetObjDesc(b.classified,1016664285),
                 
                 case  
                   when (a.code LIKE ''47425%'' or a1.code LIKE ''47425%'') THEN (select d2.Parent from  AllReservDoc a, ReservElement e, DocTree d2
                                                                                  where d2.Classified = e.Doc and e.Classified = a.ReservElement and a.Doc = b.Parent)
                   when b.subsystem = 3 then (select Pact from cGeneralAccRualLog where Classified = b.InitObj)
                   when b.subsystem = 6 then p.Obj
-- mmi 24/07/2012 ipi 101210
                   when b.subsystem = 26 then (
                     select p.classified from dual where p.category in (2601,2605)
                     union select A.ACCREDITIVE from accredrequir a where a.doc=p.classified and p.category = 2611 and p.doctype <>1034265328
                     union select A.ACCREDITIVE from doctree d3,accredrequir a where p.category = 905 and d3.classified =p.parent and a.doc=d3.classified and d3.category = 2611 and p.doctype <>1034265328
                     union select d3.classified from doctree d3 where p.category = 101 and p.doctype <>1034265328 and d3.classified=p.parent
                     union select c.Pact from doctree d2, cGeneralAccRualLog c where c.ReceiptDoc = b.Classified and c.pact = d2.classified and d2.category in (2601,2605,2611)
                     union select c.Pact from doctree d2, cGeneralAccRualLog c,cAccrualCloseLog cacl where cacl.initDoc = b.Classified and c.pact = d2.classified and CACL.GENERALLOG=C.CLASSIFIED and d2.category in (2601,2605,2611)
                                                )
-- OA 31/10/2013 ipi 146810
-- Сделки МБК                     
                   when b.subsystem = 9 then
                     od.PARENTDOC(b.Parent) -- проводка по событием, событие под траншем/сделкой
                   when b.subsystem = 1 then 
                     nvl((select Pact from cGeneralAccRualLog where ReceiptDoc = b.Parent),
                         (select case
                                   when count(distinct a.doc) = 1 then max(a.doc)
                                 end 
                            from od.dealaccount      a 
                                ,od.doctree          t
                                ,od.deal             d
                                ,od.dealaccintention i
                           where d.doc             = a.doc 
                             and t.classified      = d.doc
                             and t.category        = 908 
                             and i.classified      = a.accintention
                             and i.constintention  in (15
                                                      ,16
                                                      ,17
                                                      ,18)
                             and a.account         in (b.credaccount 
                                                      ,b.debaccount)
                             and (
                                  a.rsaccount      is null
                              or  exists (select 1 
                                            from od.reestrdoc   x
                                                ,od.doctree     y 
                                           where x.reestrinit = a.rsaccount 
                                             and y.classified = x.doc 
                                             and y.parent     = b.classified)
                                 )))
-- OA 31/10/2013 ipi 146810
                 end dogovor,
-- mmi 06/02/2013 ipi 123579                  
                 OD.GetObjDescParent_TCB(b.classified,1203048090),
                 case -- Признак проводки Диасофт
                    when exists(select 1 from OD.TCB_DOCINFO where DOC = b.CLASSIFIED) then 1
                 end,
                 to_char(s.SERVICE),
                 to_char(s.DEPARTMENT)
          FROM 
              (
               select -- mmi 04/07/2013 ipi 127540
                    b.OperDate,
                    b.AmountDeb,
                    b.AmountCred,
                    b.AmountRurDeb,
                    b.IsEndTurn,
                    b.mocred,
                    b.modeb,
                    b.DebAccount,
                    b.CredAccount,
                    b.CATEGORY     as  bCATEGORY,
                    p.Classified,
                    p.LABEL,
                    p.CATEGORY,
                    p.operobj,
                    p.operdate     as  pDate,
                    p.Parent,
                    p.subsystem,
                    p.InitObj
               FROM BBook   b,
                    DocTree p,
                    DocTree dtp1, 
                    DocTree dtp2
               WHERE b.OperDate     >= '''||dBegDate||'''
                 and b.OperDate     <  '''||dEndDate||'''
                 and b.SysFilial    =  '''||nSysFilial||'''
                 and p.classified  =  b.parent
                 and (
                      p.CATEGORY   <> 20 
                  or  b.OperDate    >= to_date(20100101,''yyyymmdd'')
                     )
                 and dtp1.classified = b.mocred
                 and dtp2.classified = b.modeb 
               union all
               SELECT /*+leading (dtp1) index (b ix_book_mocred) index(p SYS_C004009) */ 
                    b.OperDate,
                    b.AmountDeb,
                    b.AmountCred,
                    b.AmountRurDeb,
                    b.IsEndTurn,
                    b.mocred,
                    b.modeb,
                    b.DebAccount,
                    b.CredAccount,
                    b.CATEGORY     as  bCATEGORY,
                    p.Classified,
                    p.LABEL,
                    p.CATEGORY,
                    p.operobj,
                    p.operdate     as  pDate,
                    p.Parent,
                    p.subsystem,
                    p.InitObj
               FROM DocTree dtp1, 
                    BBook b,
                    DocTree p,
                    DocTree dtp2
               WHERE dtp1.UserDate >= '''||dBegDate||'''
                 AND dtp1.UserDate <  '''||dEndDate||'''
                 AND b.mocred     =  dtp1.classified
                 AND b.SysFilial  =  '''||nSysFilial||'''
                 AND (
                      b.OperDate  <  '''||dBegDate||'''
                  or  b.OperDate  >= '''||dEndDate||'''
                     )
                 AND p.classified=  b.parent
                 and (
                      p.CATEGORY <> 20 
                  or  b.OperDate  >= to_date(20100101,''yyyymmdd'')
                     )
                 and dtp2.classified = b.modeb 
               union all
               SELECT /*+leading (dtp2) index (b ix_bbook_modeb) index(p SYS_C004009) */ 
                    b.OperDate,
                    b.AmountDeb,
                    b.AmountCred,
                    b.AmountRurDeb,
                    b.IsEndTurn,
                    b.mocred,
                    b.modeb,
                    b.DebAccount,
                    b.CredAccount,
                    b.CATEGORY     as  bCATEGORY,
                    p.Classified,
                    p.LABEL,
                    p.CATEGORY,
                    p.operobj,
                    p.operdate     as  pDate,
                    p.Parent,
                    p.subsystem,
                    p.InitObj
               FROM DocTree dtp2,
                    BBook b,
                    DocTree p,
                    DocTree dtp1
               WHERE dtp2.UserDate   >= '''||dBegDate||'''
                 AND dtp2.UserDate   <  '''||dEndDate||'''
                 AND b.modeb         = dtp2.classified
                 AND b.SysFilial    =  '''||nSysFilial||'''
                 AND (
                      b.OperDate    <  '''||dBegDate||'''
                  or  b.OperDate    >= '''||dEndDate||'''
                     )
                 AND p.classified  =  b.parent
                 and (
                      p.CATEGORY   <> 20 
                  or  b.OperDate   >= to_date(20100101,''yyyymmdd'')
                     )
                 and dtp1.classified =  b.mocred
                 and (
                      dtp1.UserDate  <   '''||dBegDate||'''
                  or  dtp1.UserDate  >=  '''||dEndDate||'''
                     )) b
          inner join ACCOUNT a
                  on a.Classified    = b.DebAccount
          inner join ACCOUNT a1
                  on a1.Classified   = b.CredAccount
           left join OD.DOCTREE     p
                  on p.classified    = b.Parent
           left join OD.OPERSERVICE s  -- mmi 06/06/2014 
                  on s.doc           = b.Parent
                 and 1               = 0';

   IF nAccCat <> 0 THEN
      sDoc := sDoc || ' and b.bCATEGORY = ' || nAccCat;
   END IF;
   sDoc := sDoc || ' order by Kode';
   --nRUR := NVL(MinorUnit(pref.currency),2);
   DECLARE
      CycleQuery INTEGER;
      ignore  INTEGER;
      nCodeDeb VARCHAR2(4000);
      nParentD NUMBER;
      DDTOperdate DATE;
      nAmountC NUMBER(24,3);
      nParentC NUMBER;
      nCodeCred VARCHAR2(4000);
      sAccType VARCHAR2(1 );
      nCurD VARCHAR2(3 );
      nRurAmount NUMBER(24,3);
      nMuD NUMBER;
      sID_schet VARCHAR2(4000);
      --sID_pdr VARCHAR2(4000);
      SDO VARCHAR2(4000);
      nInitiator NUMBER;
      g_1053328759 NUMBER;
      nAmountD NUMBER(24,3);
      nDTCat NUMBER;
      nDTLabel VARCHAR2(4000);
      nDTClass NUMBER;
      nKode NUMBER;
      nIsEndTurn NUMBER;
      nDTClient NUMBER;
      nMuC NUMBER;
      dOperDate DATE;
      nCurC VARCHAR2(3);
      nType NUMBER;     
      nCurrency VARCHAR2(3); 
      sReis varchar(4000);
      nProduct number(10);
      sOutSysID varchar(255);
      nDogovorID number(10);
      sTerm varchar2(4000);
      nDias NUMBER;
      sSvcID varchar2(15);
      sSvcDepID varchar2(15);
   BEGIN
      CycleQuery := DBMS_SQL.OPEN_CURSOR;
      DBMS_SQL.PARSE(CycleQuery,sDoc, dbms_sql.v7);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,1,dOperDate);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,2,nDTClass);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,3,nDTLabel,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,4,nDTCat);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,5,nDTClient);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,6,DDTOperdate);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,7,nInitiator);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,8,nCodeDeb,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,9,nParentD);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,10,nCurD,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,11,nMuD);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,12,nCodeCred,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,13,nParentC);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,14,nCurC,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,15,nMuC);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,16,nAmountD);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,17,nAmountC);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,18,nRurAmount);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,19,nIsEndTurn);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,20,nKode);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,21,sAccType,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,22,sID_schet,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,23,SDO,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,24,sReis,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,25,nProduct);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,26,sOutSysID,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,27,nDogovorID);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,28,sTerm,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,29,nDias);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,30,sSvcID,15);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,31,sSvcDepID,15);
      ignore := DBMS_SQL.EXECUTE(CycleQuery);
      IF DBMS_SQL.FETCH_ROWS(CycleQuery) > 0 THEN
         ignore := 1;
         DBMS_SQL.COLUMN_VALUE(CycleQuery,1,dOperDate);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,2,nDTClass);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,3,nDTLabel);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,4,nDTCat);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,5,nDTClient);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,6,DDTOperdate);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,7,nInitiator);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,8,nCodeDeb);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,9,nParentD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,10,nCurD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,11,nMuD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,12,nCodeCred);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,13,nParentC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,14,nCurC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,15,nMuC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,16,nAmountD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,17,nAmountC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,18,nRurAmount);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,19,nIsEndTurn);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,20,nKode);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,21,sAccType);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,22,sID_schet);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,23,SDO);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,24,sReis);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,25,nProduct);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,26,sOutSysID);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,27,nDogovorID);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,28,sTerm);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,29,nDias);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,30,sSvcID);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,31,sSvcDepID);
         NULL;
         LOOP
         EXIT WHEN ignore = 0;
           IF nDTCat = 20 THEN
             nCurrency := '810';
             nDTLabel := nDTLabel || ' ' || nDTClass;
           ELSE
             nCurrency := nCurD;
           END IF;  
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'<Документ Тип="Плат_док" Код="' || nKode || '/'|| FilialCode || '" Номер="' || nDTLabel || '">');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Дата>' || TO_CHAR(dDTOperDate,'DD-MM-YYYY') || '</Дата>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Валюта>'||to_char(nCurrency) ||'</Валюта> ');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ШтатнаяЕдиница>' || FilialCode || '_ТехОпер</ШтатнаяЕдиница>');
      
            -- Клиент
           BEGIN
             SELECT Client
             INTO sInitiator
             FROM BOUsedBlank
             WHERE Doc = nDTClass;
            
           EXCEPTION WHEN NO_DATA_FOUND THEN
             BEGIN
               IF nInitiator IS NULL THEN
                 SELECT Initiator INTO sInitiator
                 FROM BOCashParam WHERE Doc = nDTClass;
               ELSE
                 SELECT LABEL INTO sInitiator FROM Client WHERE Classified = nInitiator;
               END IF;
              EXCEPTION
                WHEN NO_DATA_FOUND THEN NULL;
              END;  
           END;
           
           sInitiator := NVL(TO_CHAR(nDTClient),FilialCode||'_ТехКлиент');

           IF nDTCat = 15 THEN
             sInitiator := FilialCode||'_ТехКлиент';
           END IF;
           -- Клиент END
            
           -- Признак электронного платежа
           BEGIN
             select dt.doctype into nType 
             from doctree dt, 
                  doctree dt1 
             where dt.classified = dt1.parent 
                   and dt1.classified = nKode;
             CASE  
               WHEN nType in (1011964620, 1011981694, 1011963819, 1011980756, 1011981218, 1011981077) THEN 
                    INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Электронно>Д</Электронно>');
               ELSE INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Электронно>Н</Электронно>');
             END CASE;
           EXCEPTION WHEN NO_DATA_FOUND THEN
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Электронно>0</Электронно>');
           END;  
           -- Признак электронного платежа END
            
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Субъект>' || sInitiator||'</Субъект>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Операция>Неопр_опер</Операция>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Форма>Мем_орд</Форма>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ИДСчета>' || sID_schet || '</ИДСчета>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ДО>' || SDO || '</ДО>');
           --INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Подразделение>' || SDO || '</Подразделение>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Рейс>' || sReis || '</Рейс>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Продукт>' || to_char(nProduct) || '</Продукт>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ВнешИД>' || sOutSysID || '</ВнешИД>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Договор_ID>' || nDogovorID || '</Договор_ID>');
           IF sTerm is not null THEN
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Терминал>' || sTerm || '</Терминал>');
           END IF;

           IF nDTCat = 20 OR nDTCat = 54 THEN
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <СуммаДокумента>0.00</СуммаДокумента>');
           ELSE
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <СуммаДокумента>' || nAmountD || '</СуммаДокумента>');
           END IF;
           
           -- Доп. информация по документу
           bbr.BBR_TCB_Payments_2WH_XML(nKode, nDtClass);

           IF nDias = 1 THEN
              INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Диасофт>Д</Диасофт>');
           END IF;

           IF sSvcID is not null THEN
              INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <УслКод>' || sSvcID || '</УслКод>');
              IF sSvcDepID is not null THEN
                INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <УслПод>' || sSvcDepID || '</УслПод>');
              END IF;
           END IF;

           -- Проводки
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Проводки> ');
           g_1053328759 := nKode;
           LOOP 
           EXIT WHEN NOT Report.IsEqual(g_1053328759, nKode);
             IF nAmountD = 0 OR nAmountC = 0 THEN
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' ||  TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>' );
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/810</СчетДебета>');
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/810</СчетКредита>');
-- mmi Судя по хвостам счетов такое возможно только для рублей               
--               IF nAmountD = 0 THEN
--                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountC || '</Сумма>');
--               ELSE
--                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountD || '</Сумма>');
--               END IF;
-- Поэтому
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nRurAmount || '</Сумма>');
               
               IF nParentD > 0 THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <РангСчетаДебета>2</РангСчетаДебета>');
               END IF;
               
               IF nParentC > 0  THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <РангСчетаКредита>2</РангСчетаКредита>');
               END IF;
               
               IF nIsEndTurn = 1 THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
               END IF;
               
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
               
               IF nParentC > 0 OR nParentD > 0 THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии> ');
               END IF;
               
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка> ');
               
             ELSE 
               IF nCurD = nCurC  THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/' || nCurD || '</СчетДебета>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/' || nCurC || '</СчетКредита>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountD || '</Сумма>');
             
                 IF nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаДебета>2</РангСчетаДебета>');
                 END IF;
          
                 IF nParentC > 0  THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаКредита>2</РангСчетаКредита>');
                 END IF;
             
                 IF nIsEndTurn = 1 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
                 END IF;
         
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
          
                 IF nParentC > 0 OR nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии> ');
                 END IF;
      
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка>');
               END IF; -- nCurD = nCurC
                  
               IF nCurd <> CurrencyCB(pref.currency) OR nCurC <> CurrencyCB(pref.currency) THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/810</СчетДебета>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/810</СчетКредита>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nRurAmount || '</Сумма>');

                 IF nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаДебета>2</РангСчетаДебета>');
                 END IF;
                     
                 IF nParentC > 0  THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаКредита>2</РангСчетаКредита>');
                 END IF;
          
                 IF nIsEndTurn = 1 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
                 END IF;
      
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
           
                 IF nParentC > 0 OR nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии>');
                 END IF;
     
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка>' );

           -- проводка по счетам в разной валюте
                 IF nCurD <> nCurC THEN
                   FOR i IN 1..2
                   LOOP
                     j:= 0;
                     IF nCurD <> CurrencyCB(pref.currency) AND i = 1 THEN
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/' || nCurD || '</СчетДебета>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>00000/' || nCurD || '_'  || sAccType || '</СчетКредита>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountD || '</Сумма>');
                       j:= 1;
                     END IF;
              
                     IF nCurC <> CurrencyCB(pref.currency) AND i = 2 THEN
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>' );
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>00000/' || nCurC || '_' || sAccType || '</СчетДебета>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/' || nCurC || '</СчетКредита>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountC || '</Сумма>');
                       j:=1;
                     END IF;

                     IF j = 1 THEN
                       IF nParentC > 0  THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаКредита>2</РангСчетаКредита>');
                       END IF;
  
                       IF nParentD > 0 THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаДебета>2</РангСчетаДебета>');
                       END IF;
          
                       IF nIsEndTurn = 1 THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
                       END IF;
          
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
          
                       IF nParentC > 0 OR nParentD > 0 THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии>');
                       END IF;
              
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка>');
                     END IF;
                   END LOOP;
                 END IF; -- nCurD <> nCurC
          -- проводка по счетам в разной валюте END
               END IF; -- nCurd <> CurrencyCB(pref.currency) OR nCurC <> CurrencyCB(pref.currency)
          
             END IF; -- nAmountD = 0 OR nAmountC = 0 

             IF DBMS_SQL.FETCH_ROWS(CycleQuery) > 0 THEN
               ignore := 1;
               DBMS_SQL.COLUMN_VALUE(CycleQuery,1,dOperDate);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,2,nDTClass);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,3,nDTLabel);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,4,nDTCat);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,5,nDTClient);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,6,DDTOperdate);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,7,nInitiator);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,8,nCodeDeb);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,9,nParentD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,10,nCurD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,11,nMuD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,12,nCodeCred);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,13,nParentC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,14,nCurC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,15,nMuC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,16,nAmountD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,17,nAmountC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,18,nRurAmount);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,19,nIsEndTurn);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,20,nKode);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,21,sAccType);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,22,sID_schet);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,23,SDO);    
               DBMS_SQL.COLUMN_VALUE(CycleQuery,24,sReis);              
               DBMS_SQL.COLUMN_VALUE(CycleQuery,25,nProduct);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,26,sOutSysID);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,27,nDogovorID);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,28,sTerm);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,29,nDias);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,30,sSvcID);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,31,sSvcDepID);
             ELSE
               ignore := 0;
             END IF;
             EXIT WHEN ignore = 0;
           END LOOP;
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  </Проводки>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'</Документ> ');
           EXIT WHEN ignore = 0;
         END LOOP;
         NULL;
      
      END IF;
      DBMS_SQL.CLOSE_CURSOR(CycleQuery);
   END;

   INSERT INTO bbr.TO_DATAWAREHOUSE_LOG (ID,LOG_TIME,FILIAL,PROC_NAME,LOG_TEXT) 
   VALUES(bbr_tcb.NEXTVAL,sysdate,FilialCode,'BBR_TCB_TRANSACT_2WH_XML','Конец выгрузки документов');
   commit;

END;


----------------------------------------------------------------------------------
--09/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.TaxService

od.Get_OS_ServiceName

-- IPI 72189 - организовать возможность формирования МТ540-МТ543 и МТ599 для Депозитария                                                                             --
-- сделать BBR, которое бы формировало "Сообщение общей группы" 599 по заданным параметрам
-- разместить BBR в дереве отчетов в папке Депозитарий

od.dpc_dealbanknote_swift_mt399
od.DPC_DealNetting_Swift_MT399
bbr.BBR_DOC_SWIFT

od.dpc_tcb_dealswift_mt399

----------------------------------------------------------------------------------
--10/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE BBR_TCB_TRANSACT_2WH_XML (
   dBegDate_ IN DATE,
   dEndDate_ IN DATE,
   nSysFilial_ IN NUMBER,
   nAccCat IN NUMBER
   
   --nChange IN NUMBER,
   --nDel IN NUMBER,
   --PageSize IN dt.ConstValue DEFAULT 40,
   --nStrata IN dt.ConstValue DEFAULT 255,
   --SysMode IN dt.ConstValue DEFAULT 0
)
AS
   j NUMBER;
   sDoc VARCHAR2(16000);
   sInitiator VARCHAR2(4000);
   dOperDate DATE;
   --nRur NUMBER;
   --sPathName VARCHAR2(4000);
   FilialCode VARCHAR2(4000);
   dEndDate DATE;
   dBegDate DATE;
   nSysFilial NUMBER;
BEGIN
   dBegDate := dBegDate_;
   dEndDate := dEndDate_+1;
   nSysFilial := nvl(nSysFilial_,1);

--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   
/*
dBegDate:= GETDOCID_2WH();
dEndDate:= dBegDate + 1;
IF nSysFilial < 16 then
   nSysFilial:= 95;
end if;   

   IF nSysFilial NOT IN (5,10,8,15,16,17,18) THEN
      nSysFilial:= 95;
   END IF;

IF nSysFilial = '1' then
   nSysFilial:='999';
   FilialCode:='9999';
end if;
*/
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   FilialCode := case nSysFilial
                   when 1  then '9100'
                   when 2  then '8010'
                   when 3  then '8060'
                   when 4  then '8020'
                   when 5  then '8120'
                   when 6  then '8050'
                   when 8  then '8150'
                   when 9  then '8030'
                   when 10 then '8130'
                   when 11 then '8100'
                   when 12 then '8110'
                   when 13 then '8080'
                   when 14 then '8040'
                   when 15 then '8170'
                   when 16 then '8180'
                   when 17 then '8190'
                   when 18 then '8200'
                   when 19 then '8140'
                   when 20 then '8090'
                   when 21 then '8210'
                   else ''
                 end;
   

   INSERT INTO bbr.TO_DATAWAREHOUSE_LOG (ID,LOG_TIME,FILIAL,PROC_NAME,LOG_TEXT) 
   VALUES(bbr_tcb.NEXTVAL,sysdate,FilialCode,'BBR_TCB_TRANSACT_2WH_XML','Начало выгрузки документов. dBegDate: ' || dBegDate || ', dEndDate: ' || dEndDate);
   commit;

---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   IF 1 = 2 THEN
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      dOperDate := dBegDate;
      WHILE dOperDate < dEndDate LOOP
      NULL;
    
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'<УдалитьДокументы>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Филиал>' || FilialCode || '</Филиал>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ФормаДокументов>Мем_орд</ФормаДокументов>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'</УдалитьДокументы>');
     
    dOperDate := dOperDate + 1; 
      END LOOP;
   END IF;
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   IF 1 = 0 THEN -- mmi удаление вынесено в BBR_TCB_TRANSACT_DEL_2WH_XML
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      DECLARE
         CURSOR CycleQuery IS SELECT Classified
         FROM DocTree
         WHERE 
              ((OperDate >= dBegDate and OperDate < dEndDate) or (UserDate >= dBegDate and UserDate < dEndDate))
              and SysFilial = nSysFilial
              and docstate = 1000000037
              and doctype in (1000135265,1000135286) -- mmi
         ;
         nDTClass NUMBER;
      BEGIN
         OPEN CycleQuery;
         FETCH CycleQuery INTO nDTClass;
         IF CycleQuery%FOUND THEN 
            NULL;
            LOOP
            EXIT WHEN CycleQuery%NOTFOUND;
      
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'<Документ>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Код>' ||  nDTClass || '/' || FilialCode || '</Код>');
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ОперацияНадОбъектом Метод="delete"/>' );
      INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'</Документ>');
         
               FETCH CycleQuery INTO nDTClass;
               EXIT WHEN CycleQuery%NOTFOUND;
            END LOOP;
            NULL;
         END IF;
         CLOSE CycleQuery;
      END;
   END IF;
   sDoc:='Select /*+ index (a sys_c001634) index (a1 sys_c001634)*/ 
                 Trunc(b.OperDate), 
                 b.Classified,
                 REPLACE(REPLACE(REPLACE(REPLACE(b.LABEL,''&'',''&amp;''),''"'',''&quot;''),''>'',''&gt;''),''<'',''&lt;'') as Label,
                 b.CATEGORY,
                 a.client,
                 TRUNC(b.pDate),
                 b.operobj,
                 a.Code,
                 a.foldaccount,
                 CurrencyCB(a.currency),
                 NVL(MinorUnit(a.currency),2),
                 a1.Code,
                 a1.foldaccount,
                 CurrencyCB(a1.currency),
                 NVL(MinorUnit(a.currency),2),
                 b.AmountDeb,
                 b.AmountCred,
                 b.AmountRurDeb,
                 b.IsEndTurn,
                 DECODE(b.amountdeb,0,b.mocred,b.modeb) Kode,
                 DECODE(b.bCATEGORY,2,''А'',3,''В'',66,''Г'',67,''Б'',''''),
                 GetObjDesc(b.classified,1051764777),
                 GetObjDesc(b.classified,1063879930),
                 GetObjDesc(b.classified,1018917921),
                 od.TCB_DWH.GetDocProduct(DECODE(b.amountdeb,0,b.mocred,b.modeb)),
                 GetObjDesc(b.classified,1016664285),
                 
                 case  
                   when (a.code LIKE ''47425%'' or a1.code LIKE ''47425%'') THEN (select d2.Parent from  AllReservDoc a, ReservElement e, DocTree d2
                                                                                  where d2.Classified = e.Doc and e.Classified = a.ReservElement and a.Doc = b.Parent)
                   when b.subsystem = 3 then (select Pact from cGeneralAccRualLog where Classified = b.InitObj)
                   when b.subsystem = 6 then p.Obj
-- mmi 24/07/2012 ipi 101210
                   when b.subsystem = 26 then (
                     select p.classified from dual where p.category in (2601,2605)
                     union select A.ACCREDITIVE from accredrequir a where a.doc=p.classified and p.category = 2611 and p.doctype <>1034265328
                     union select A.ACCREDITIVE from doctree d3,accredrequir a where p.category = 905 and d3.classified =p.parent and a.doc=d3.classified and d3.category = 2611 and p.doctype <>1034265328
                     union select d3.classified from doctree d3 where p.category = 101 and p.doctype <>1034265328 and d3.classified=p.parent
                     union select c.Pact from doctree d2, cGeneralAccRualLog c where c.ReceiptDoc = b.Classified and c.pact = d2.classified and d2.category in (2601,2605,2611)
                     union select c.Pact from doctree d2, cGeneralAccRualLog c,cAccrualCloseLog cacl where cacl.initDoc = b.Classified and c.pact = d2.classified and CACL.GENERALLOG=C.CLASSIFIED and d2.category in (2601,2605,2611)
                                                )
-- OA 31/10/2013 ipi 146810
-- Сделки МБК                     
                   when b.subsystem = 9 then
                     od.PARENTDOC(b.Parent) -- проводка по событием, событие под траншем/сделкой
                   when b.subsystem = 1 then 
                     nvl((select Pact from cGeneralAccRualLog where ReceiptDoc = b.Parent),
                         (select case
                                   when count(distinct a.doc) = 1 then max(a.doc)
                                 end 
                            from od.dealaccount      a 
                                ,od.doctree          t
                                ,od.deal             d
                                ,od.dealaccintention i
                           where d.doc             = a.doc 
                             and t.classified      = d.doc
                             and t.category        = 908 
                             and i.classified      = a.accintention
                             and i.constintention  in (15
                                                      ,16
                                                      ,17
                                                      ,18)
                             and a.account         in (b.credaccount 
                                                      ,b.debaccount)
                             and (
                                  a.rsaccount      is null
                              or  exists (select 1 
                                            from od.reestrdoc   x
                                                ,od.doctree     y 
                                           where x.reestrinit = a.rsaccount 
                                             and y.classified = x.doc 
                                             and y.parent     = b.classified)
                                 )))
-- OA 31/10/2013 ipi 146810
                 end dogovor,
-- mmi 06/02/2013 ipi 123579                  
                 OD.GetObjDescParent_TCB(b.classified,1203048090),
                 case -- Признак проводки Диасофт
                    when exists(select 1 from OD.TCB_DOCINFO where DOC = b.CLASSIFIED) then 1
                 end,
                 b.classified
          FROM 
              (
               select -- mmi 04/07/2013 ipi 127540
                    b.OperDate,
                    b.AmountDeb,
                    b.AmountCred,
                    b.AmountRurDeb,
                    b.IsEndTurn,
                    b.mocred,
                    b.modeb,
                    b.DebAccount,
                    b.CredAccount,
                    b.CATEGORY     as  bCATEGORY,
                    p.Classified,
                    p.LABEL,
                    p.CATEGORY,
                    p.operobj,
                    p.operdate     as  pDate,
                    p.Parent,
                    p.subsystem,
                    p.InitObj
               FROM BBook   b,
                    DocTree p,
                    DocTree dtp1, 
                    DocTree dtp2
               WHERE b.OperDate     >= '''||dBegDate||'''
                 and b.OperDate     <  '''||dEndDate||'''
                 and b.SysFilial    =  '''||nSysFilial||'''
                 and p.classified  =  b.parent
                 and (
                      p.CATEGORY   <> 20 
                  or  b.OperDate    >= to_date(20100101,''yyyymmdd'')
                     )
                 and dtp1.classified = b.mocred
                 and dtp2.classified = b.modeb 
               union all
               SELECT /*+leading (dtp1) index (b ix_book_mocred) index(p SYS_C004009) */ 
                    b.OperDate,
                    b.AmountDeb,
                    b.AmountCred,
                    b.AmountRurDeb,
                    b.IsEndTurn,
                    b.mocred,
                    b.modeb,
                    b.DebAccount,
                    b.CredAccount,
                    b.CATEGORY     as  bCATEGORY,
                    p.Classified,
                    p.LABEL,
                    p.CATEGORY,
                    p.operobj,
                    p.operdate     as  pDate,
                    p.Parent,
                    p.subsystem,
                    p.InitObj
               FROM DocTree dtp1, 
                    BBook b,
                    DocTree p,
                    DocTree dtp2
               WHERE dtp1.UserDate >= '''||dBegDate||'''
                 AND dtp1.UserDate <  '''||dEndDate||'''
                 AND b.mocred     =  dtp1.classified
                 AND b.SysFilial  =  '''||nSysFilial||'''
                 AND (
                      b.OperDate  <  '''||dBegDate||'''
                  or  b.OperDate  >= '''||dEndDate||'''
                     )
                 AND p.classified=  b.parent
                 and (
                      p.CATEGORY <> 20 
                  or  b.OperDate  >= to_date(20100101,''yyyymmdd'')
                     )
                 and dtp2.classified = b.modeb 
               union all
               SELECT /*+leading (dtp2) index (b ix_bbook_modeb) index(p SYS_C004009) */ 
                    b.OperDate,
                    b.AmountDeb,
                    b.AmountCred,
                    b.AmountRurDeb,
                    b.IsEndTurn,
                    b.mocred,
                    b.modeb,
                    b.DebAccount,
                    b.CredAccount,
                    b.CATEGORY     as  bCATEGORY,
                    p.Classified,
                    p.LABEL,
                    p.CATEGORY,
                    p.operobj,
                    p.operdate     as  pDate,
                    p.Parent,
                    p.subsystem,
                    p.InitObj
               FROM DocTree dtp2,
                    BBook b,
                    DocTree p,
                    DocTree dtp1
               WHERE dtp2.UserDate   >= '''||dBegDate||'''
                 AND dtp2.UserDate   <  '''||dEndDate||'''
                 AND b.modeb         = dtp2.classified
                 AND b.SysFilial    =  '''||nSysFilial||'''
                 AND (
                      b.OperDate    <  '''||dBegDate||'''
                  or  b.OperDate    >= '''||dEndDate||'''
                     )
                 AND p.classified  =  b.parent
                 and (
                      p.CATEGORY   <> 20 
                  or  b.OperDate   >= to_date(20100101,''yyyymmdd'')
                     )
                 and dtp1.classified =  b.mocred
                 and (
                      dtp1.UserDate  <   '''||dBegDate||'''
                  or  dtp1.UserDate  >=  '''||dEndDate||'''
                     )) b
          inner join ACCOUNT a
                  on a.Classified    = b.DebAccount
          inner join ACCOUNT a1
                  on a1.Classified   = b.CredAccount
           left join OD.DOCTREE     p
                  on p.classified    = b.Parent
               where 1 = 1';

   IF nAccCat <> 0 THEN
      sDoc := sDoc || ' and b.bCATEGORY = ' || nAccCat;
   END IF;
   sDoc := sDoc || ' order by Kode';
   --nRUR := NVL(MinorUnit(pref.currency),2);
   DECLARE
      CycleQuery INTEGER;
      ignore  INTEGER;
      nCodeDeb VARCHAR2(4000);
      nParentD NUMBER;
      DDTOperdate DATE;
      nAmountC NUMBER(24,3);
      nParentC NUMBER;
      nCodeCred VARCHAR2(4000);
      sAccType VARCHAR2(1 );
      nCurD VARCHAR2(3 );
      nRurAmount NUMBER(24,3);
      nMuD NUMBER;
      sID_schet VARCHAR2(4000);
      --sID_pdr VARCHAR2(4000);
      SDO VARCHAR2(4000);
      nInitiator NUMBER;
      g_1053328759 NUMBER;
      nAmountD NUMBER(24,3);
      nDTCat NUMBER;
      nDTLabel VARCHAR2(4000);
      nDTClass NUMBER;
      nKode NUMBER;
      nIsEndTurn NUMBER;
      nDTClient NUMBER;
      nMuC NUMBER;
      dOperDate DATE;
      nCurC VARCHAR2(3);
      nType NUMBER;     
      nCurrency VARCHAR2(3); 
      sReis varchar(4000);
      nProduct number(10);
      sOutSysID varchar(255);
      nDogovorID number(10);
      sTerm varchar2(4000);
      nDias NUMBER;
      sSvcID varchar2(15);
      sSvcDepID varchar2(15);
      nParentB NUMBER;
   BEGIN
      CycleQuery := DBMS_SQL.OPEN_CURSOR;
      DBMS_SQL.PARSE(CycleQuery,sDoc, dbms_sql.v7);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,1,dOperDate);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,2,nDTClass);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,3,nDTLabel,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,4,nDTCat);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,5,nDTClient);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,6,DDTOperdate);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,7,nInitiator);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,8,nCodeDeb,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,9,nParentD);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,10,nCurD,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,11,nMuD);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,12,nCodeCred,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,13,nParentC);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,14,nCurC,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,15,nMuC);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,16,nAmountD);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,17,nAmountC);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,18,nRurAmount);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,19,nIsEndTurn);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,20,nKode);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,21,sAccType,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,22,sID_schet,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,23,SDO,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,24,sReis,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,25,nProduct);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,26,sOutSysID,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,27,nDogovorID);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,28,sTerm,2000);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,29,nDias);
      DBMS_SQL.DEFINE_COLUMN(CycleQuery,30,nParentB);
      ignore := DBMS_SQL.EXECUTE(CycleQuery);
      IF DBMS_SQL.FETCH_ROWS(CycleQuery) > 0 THEN
         ignore := 1;
         DBMS_SQL.COLUMN_VALUE(CycleQuery,1,dOperDate);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,2,nDTClass);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,3,nDTLabel);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,4,nDTCat);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,5,nDTClient);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,6,DDTOperdate);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,7,nInitiator);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,8,nCodeDeb);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,9,nParentD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,10,nCurD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,11,nMuD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,12,nCodeCred);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,13,nParentC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,14,nCurC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,15,nMuC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,16,nAmountD);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,17,nAmountC);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,18,nRurAmount);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,19,nIsEndTurn);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,20,nKode);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,21,sAccType);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,22,sID_schet);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,23,SDO);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,24,sReis);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,25,nProduct);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,26,sOutSysID);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,27,nDogovorID);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,28,sTerm);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,29,nDias);
         DBMS_SQL.COLUMN_VALUE(CycleQuery,30,nParentB);
         NULL;
         LOOP
         EXIT WHEN ignore = 0;
           IF nDTCat = 20 THEN
             nCurrency := '810';
             nDTLabel := nDTLabel || ' ' || nDTClass;
           ELSE
             nCurrency := nCurD;
           END IF;  
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'<Документ Тип="Плат_док" Код="' || nKode || '/'|| FilialCode || '" Номер="' || nDTLabel || '">');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Дата>' || TO_CHAR(dDTOperDate,'DD-MM-YYYY') || '</Дата>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Валюта>'||to_char(nCurrency) ||'</Валюта> ');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ШтатнаяЕдиница>' || FilialCode || '_ТехОпер</ШтатнаяЕдиница>');
      
            -- Клиент
           BEGIN
             SELECT Client
             INTO sInitiator
             FROM BOUsedBlank
             WHERE Doc = nDTClass;
            
           EXCEPTION WHEN NO_DATA_FOUND THEN
             BEGIN
               IF nInitiator IS NULL THEN
                 SELECT Initiator INTO sInitiator
                 FROM BOCashParam WHERE Doc = nDTClass;
               ELSE
                 SELECT LABEL INTO sInitiator FROM Client WHERE Classified = nInitiator;
               END IF;
              EXCEPTION
                WHEN NO_DATA_FOUND THEN NULL;
              END;  
           END;
           
           sInitiator := NVL(TO_CHAR(nDTClient),FilialCode||'_ТехКлиент');

           IF nDTCat = 15 THEN
             sInitiator := FilialCode||'_ТехКлиент';
           END IF;
           -- Клиент END
            
           -- Признак электронного платежа
           BEGIN
             select dt.doctype into nType 
             from doctree dt, 
                  doctree dt1 
             where dt.classified = dt1.parent 
                   and dt1.classified = nKode;
             CASE  
               WHEN nType in (1011964620, 1011981694, 1011963819, 1011980756, 1011981218, 1011981077) THEN 
                    INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Электронно>Д</Электронно>');
               ELSE INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Электронно>Н</Электронно>');
             END CASE;
           EXCEPTION WHEN NO_DATA_FOUND THEN
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Электронно>0</Электронно>');
           END;  
           -- Признак электронного платежа END
            
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Субъект>' || sInitiator||'</Субъект>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Операция>Неопр_опер</Операция>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Форма>Мем_орд</Форма>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ИДСчета>' || sID_schet || '</ИДСчета>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ДО>' || SDO || '</ДО>');
           --INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Подразделение>' || SDO || '</Подразделение>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Рейс>' || sReis || '</Рейс>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Продукт>' || to_char(nProduct) || '</Продукт>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ВнешИД>' || sOutSysID || '</ВнешИД>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Договор_ID>' || nDogovorID || '</Договор_ID>');
           IF sTerm is not null THEN
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Терминал>' || sTerm || '</Терминал>');
           END IF;

           IF nDTCat = 20 OR nDTCat = 54 THEN
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <СуммаДокумента>0.00</СуммаДокумента>');
           ELSE
             INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <СуммаДокумента>' || nAmountD || '</СуммаДокумента>');
           END IF;
           
           -- Доп. информация по документу
           bbr.BBR_TCB_Payments_2WH_XML(nKode, nDtClass);

           IF nDias = 1 THEN
              INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Диасофт>Д</Диасофт>');
           END IF;

           -- Услуги
           BEGIN
              select to_char(SERVICE)
                    ,to_char(DEPARTMENT)
                into sSvcID
                    ,sSvcDepID
                from OD.OPERSERVICE
               where classified in (
              select operservice
                from OD.TaxService
               where nParentB   in (
                                    chargedoc
                                   ,ndsdoc
                                   ,paydoc));

             IF sSvcID is not null THEN
                INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <УслКод>' || sSvcID || '</УслКод>');
                IF sSvcDepID is not null THEN
                  INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <УслПод>' || sSvcDepID || '</УслПод>');
                END IF;
             END IF;

           EXCEPTION WHEN NO_DATA_FOUND THEN
             NULL;
           END;  

           -- Проводки
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <Проводки> ');
           g_1053328759 := nKode;
           LOOP 
           EXIT WHEN NOT Report.IsEqual(g_1053328759, nKode);
             IF nAmountD = 0 OR nAmountC = 0 THEN
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' ||  TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>' );
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/810</СчетДебета>');
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/810</СчетКредита>');
-- mmi Судя по хвостам счетов такое возможно только для рублей               
--               IF nAmountD = 0 THEN
--                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountC || '</Сумма>');
--               ELSE
--                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountD || '</Сумма>');
--               END IF;
-- Поэтому
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nRurAmount || '</Сумма>');
               
               IF nParentD > 0 THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <РангСчетаДебета>2</РангСчетаДебета>');
               END IF;
               
               IF nParentC > 0  THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <РангСчетаКредита>2</РангСчетаКредита>');
               END IF;
               
               IF nIsEndTurn = 1 THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
               END IF;
               
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
               
               IF nParentC > 0 OR nParentD > 0 THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии> ');
               END IF;
               
               INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка> ');
               
             ELSE 
               IF nCurD = nCurC  THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/' || nCurD || '</СчетДебета>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/' || nCurC || '</СчетКредита>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountD || '</Сумма>');
             
                 IF nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаДебета>2</РангСчетаДебета>');
                 END IF;
          
                 IF nParentC > 0  THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаКредита>2</РангСчетаКредита>');
                 END IF;
             
                 IF nIsEndTurn = 1 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
                 END IF;
         
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
          
                 IF nParentC > 0 OR nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии> ');
                 END IF;
      
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка>');
               END IF; -- nCurD = nCurC
                  
               IF nCurd <> CurrencyCB(pref.currency) OR nCurC <> CurrencyCB(pref.currency) THEN
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/810</СчетДебета>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/810</СчетКредита>');
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nRurAmount || '</Сумма>');

                 IF nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаДебета>2</РангСчетаДебета>');
                 END IF;
                     
                 IF nParentC > 0  THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаКредита>2</РангСчетаКредита>');
                 END IF;
          
                 IF nIsEndTurn = 1 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
                 END IF;
      
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
           
                 IF nParentC > 0 OR nParentD > 0 THEN
                   INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии>');
                 END IF;
     
                 INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка>' );

           -- проводка по счетам в разной валюте
                 IF nCurD <> nCurC THEN
                   FOR i IN 1..2
                   LOOP
                     j:= 0;
                     IF nCurD <> CurrencyCB(pref.currency) AND i = 1 THEN
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>' || nCodeDeb || '/' || nCurD || '</СчетДебета>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>00000/' || nCurD || '_'  || sAccType || '</СчетКредита>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountD || '</Сумма>');
                       j:= 1;
                     END IF;
              
                     IF nCurC <> CurrencyCB(pref.currency) AND i = 2 THEN
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    <Проводка>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Филиал>' || FilialCode || '</Филиал>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Дата>' || TO_CHAR(dOperDate,'DD-MM-YYYY') || '</Дата>' );
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетДебета>00000/' || nCurC || '_' || sAccType || '</СчетДебета>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <СчетКредита>' || nCodeCred || '/' || nCurC || '</СчетКредита>');
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <Сумма>' || nAmountC || '</Сумма>');
                       j:=1;
                     END IF;

                     IF j = 1 THEN
                       IF nParentC > 0  THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаКредита>2</РангСчетаКредита>');
                       END IF;
  
                       IF nParentD > 0 THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <РангСчетаДебета>2</РангСчетаДебета>');
                       END IF;
          
                       IF nIsEndTurn = 1 THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ЗаключительныеОбороты>Y</ЗаключительныеОбороты>');
                       END IF;
          
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьОстаток>Y</ПрокатыватьОстаток>');
          
                       IF nParentC > 0 OR nParentD > 0 THEN
                         INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'      <ПрокатыватьПоИерархии>Y</ПрокатыватьПоИерархии>');
                       END IF;
              
                       INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'    </Проводка>');
                     END IF;
                   END LOOP;
                 END IF; -- nCurD <> nCurC
          -- проводка по счетам в разной валюте END
               END IF; -- nCurd <> CurrencyCB(pref.currency) OR nCurC <> CurrencyCB(pref.currency)
          
             END IF; -- nAmountD = 0 OR nAmountC = 0 

             IF DBMS_SQL.FETCH_ROWS(CycleQuery) > 0 THEN
               ignore := 1;
               DBMS_SQL.COLUMN_VALUE(CycleQuery,1,dOperDate);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,2,nDTClass);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,3,nDTLabel);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,4,nDTCat);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,5,nDTClient);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,6,DDTOperdate);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,7,nInitiator);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,8,nCodeDeb);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,9,nParentD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,10,nCurD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,11,nMuD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,12,nCodeCred);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,13,nParentC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,14,nCurC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,15,nMuC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,16,nAmountD);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,17,nAmountC);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,18,nRurAmount);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,19,nIsEndTurn);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,20,nKode);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,21,sAccType);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,22,sID_schet);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,23,SDO);    
               DBMS_SQL.COLUMN_VALUE(CycleQuery,24,sReis);              
               DBMS_SQL.COLUMN_VALUE(CycleQuery,25,nProduct);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,26,sOutSysID);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,27,nDogovorID);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,28,sTerm);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,29,nDias);
               DBMS_SQL.COLUMN_VALUE(CycleQuery,30,nParentB);
             ELSE
               ignore := 0;
             END IF;
             EXIT WHEN ignore = 0;
           END LOOP;
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'  </Проводки>');
           INSERT INTO bbr.TO_DATAWAREHOUSE_TMP VALUES(bbr_tcb.NEXTVAL,'</Документ> ');
           EXIT WHEN ignore = 0;
         END LOOP;
         NULL;
      
      END IF;
      DBMS_SQL.CLOSE_CURSOR(CycleQuery);
   END;

   INSERT INTO bbr.TO_DATAWAREHOUSE_LOG (ID,LOG_TIME,FILIAL,PROC_NAME,LOG_TEXT) 
   VALUES(bbr_tcb.NEXTVAL,sysdate,FilialCode,'BBR_TCB_TRANSACT_2WH_XML','Конец выгрузки документов');
   commit;

END;

----------------------------------------------------------------------------------
--16/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from dealtransaction where doc = 272090130
select * from deal where doc = 250988804

od.DPC_BTM_EVENTCTRL

-- по просьбе Ледовской написал DPC_BTM_EVENTCTRL и повесил её вместо DPC_BTM_EVENTCTRL_TCB на действие "Обработать" для "Cобытий депозитной сделки" и 
-- "Событий по форексу"                                                                                                                                             ++

CREATE OR REPLACE PROCEDURE DPC_BTM_EVENTCTRL_TCB
/******************************************************************************
 Описание: Процедура контроля заполненности полей в событии по сделке (на основе DPC_BTM_EVENTCTRL, добавил только description события в сообщение об ошибке)
16/06/2014 Панфилов М.С. 
******************************************************************************/
AS
   recdealtr   dealtransaction%ROWTYPE;                     -- Событие сделки
   stext       dt.text;                         -- Начало сообщения об ошибке
   sbank       dt.text;                         -- Название банка контрагента
   sagent      dt.text;
   snostro     dt.text;
   
      recdoctree  doctree%ROWTYPE;
   
BEGIN
   SELECT *
     INTO recdealtr
     FROM dealtransaction
    WHERE doc = CONTEXT.currentdoc;
    
    SELECT *
     INTO recdoctree
     FROM doctree
    WHERE classified = CONTEXT.currentdoc;

-- Если событие включенно в неттинг или замещенно, тогда ничего не проверяем
   IF recdealtr.isnetting in  (1,2)
   THEN
          RETURN;
   END IF;

-- Определяем текст для сообщений об ошибках в зависимости от знака события
   IF recdealtr.amount > 0
   THEN                                                    -- + для требований
      stext :=
            'В событии (требования) c внутренним номером '
         || CONTEXT.currentdoc
         || ' //'
         || recdoctree.description
         || ' //';
      sbank := 'поле 52: Банк отправителя ';
      sagent := 'поле 50: Отправитель ';
      snostro := 'поле Счет дебета ';
   ELSE                                                 --  - для обязательств
      stext :=
            'В событии (обязательства) c внутренним номером '
         || CONTEXT.currentdoc
         || ' //'
         || recdoctree.description
         || ' //';
      sbank := 'поле 57: Банк бенефициара ';
      sagent := 'поле 58/59: Бенефициар ';
      snostro := 'поле Счет кредита ';
   END IF;

-- Анализируем Банк отправителя/получателя
   IF SUBSTR (recdealtr.sectionflag, 3, 1) = 'A'
   THEN
      IF recdealtr.beneficiarybank IS NULL
      THEN
         raise_application_error (-20000, stext || 'не указано ' || sbank);
      END IF;
   ELSE
      IF recdealtr.beneficiarybankname IS NULL
      THEN
         raise_application_error (-20000, stext || 'не указано ' || sbank);
      END IF;
   END IF;

-- Анализируем отправителя/получателя
   IF SUBSTR (recdealtr.sectionflag, 4, 1) = 'A'
   THEN
      IF recdealtr.beneficiary IS NULL and not(recdealtr.amount > 0)  -- isy временоо добавлена проверка - нетребования
      THEN
         raise_application_error (-20000, stext || 'не указано ' || sagent);
      END IF;
   ELSE
      IF recdealtr.beneficiaryname IS NULL
      THEN
         raise_application_error (-20000, stext || 'не указано ' || sagent);
      END IF;
   END IF;

-- Анализируем корр. счет
   IF recdealtr.nostro IS NULL
   THEN
      raise_application_error (-20000, stext || 'не указано ' || snostro);
   END IF;

-- Анализируем траспортную систему и тип сообщения по событиям где м.б. платежи
   IF     recdealtr.amount < 0
      AND SUBSTR (recdealtr.sectionflag, 3, 1) = 'A'
      AND recdealtr.beneficiarybank != pref.ourbank
   THEN
      IF recdealtr.clearinghouse IS NULL
      THEN
         raise_application_error (-20000,
                                  stext || 'не указана транспортная система '
                                 );
      END IF;

      IF    getconstclearinghouse (1) = recdealtr.clearinghouse
         OR getconstclearinghouse (14) = recdealtr.clearinghouse
      THEN                          -- Для SWIFT и SWIFT-RUR нужно заполнять тип сообщения
         IF recdealtr.transfermessage IS NULL
         THEN
            raise_application_error
                    (-20000,
                        stext
                     || 'не указан тип сообщения для транспортной системы SWIFT'
                    );
         END IF;
      END IF;
   END IF;
END DPC_BTM_EVENTCTRL_TCB;

----------------------------------------------------------------------------------
--17/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select rowid, c.* from certoper c where changedepo in (1177367941,1177367942) --  certificate = 1177367542

SELECT * FROM CHANGEDEPOBALANCE where classified in (1177367941,1177367942)


-- убирал первый нолик в номере сертификата по просьбе Калашниковой                                                                                                  ++
select rowid, s.* from SYSSECURITYSERIES s where security = 1177367524
select rowid, s.* from syscertificate s where classified = 1177367542

----------------------------------------------------------------------------------
--18/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- Bari, Rome           
select 336 + 168, 242 + (7380/48)*2 from dual

select 300000*((td-to_date('06052014','ddmmyyyy'))/365)*0.0875 from dual

od.GET_TCB_BILLACCOUNTLABEL

----------------------------------------------------------------------------------
--23/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- mbank
--cyberplat2
--cyberplat2

select * from groups 
select * from operators where cid = 3313 -- ID, NAME, CID
select * from fields where oper_id = 99989 --
select * from request
select * from request_prop where oper_id = 99989

select * from operators where cid = 484 -- ID, NAME, CID
select * from fields where oper_id = 99998 --
select * from request_prop where oper_id = 99998
select * from request

----------------------------------------------------------------------------------
--24/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from clientregiontree connect by prior classified = parent start with classified = 1000043360

WITH RECURSIVE Rec (classified, parent, label)
 AS (
   SELECT classified, parent, label FROM clientregiontree
   UNION ALL
   SELECT Rec.classified, Rec.parent, Rec.label
    FROM Rec, clientregiontree
    WHERE Rec.classified = clientregiontree.parent
   )
 SELECT * FROM Rec 
 WHERE parent is null;

select deptno,
    max(sys_connect_by_path
       (ename, ' ' )) scbp
  from (select deptno, ename,
            row_number() over
           (partition by deptno
            order by ename) rn
         from emp
          )
start with rn = 1
connect by prior rn = rn-1
and prior deptno = deptno
  group by deptno
  order by deptno
  
select * from emp 

----------------------------------------------------------------------------------
--25/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- написать отчет BBR_DEPO_711_101_TCB (Сверка данных формы 711 с основным балансом) по задаче IPI 191411 (за основу взят BBR_DEPO_CHECKBAL_TCB8) => 
-- тестит Гордеева                                                                                                                                                   ++

select * from DEPOSECURITYTYPE order by code      

bbr.bbr_depo_711_101_tcb  

select code,0,classified, decode(code,'SHS3',1,'SHS4',1,classified) as uni from DEPOSECURITYTYPE where code is not null and consttype != 5 
order by 1            

bbr.BBR_DEPO_711_101_TCB                                       
 
----------------------------------------------------------------------------------
--26/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from sysdepo

select * from depoaccount
select * from syssecurity

select  nvl(DT.IsActive, 0), 
        D.Classified, 
        nvl(D.Code, ' '),
        nvl(D.Label,' '),
        nvl(DS.RegistrCode,' '),
        DA.Code,
        abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  dtDate),0)),
        nvl(DS.Description,DS.Label),
        DA.Denominator,
        DA.DepoPartition,
        DA.StoreType,
        DA.Classified,
        DST.ConstType,

        /*decode(dst.isemissive,1,clientlabel(Ds.issuer), '')*/
    clientlabel(Ds.issuer),
--выводим только если эмиссионная

        dst.classified,
        GetFilialLabel(D.SysFilial)

from DepoType DT, Depo D, DocTree T, ObjProp OP,
       DepoAccount DA, DepoAccount DAP,SysDepo SD, DepoSecurity DS, DepoPartitionType DPT,
       DepoSecurityType dst
where --D.SysFilial = C_Access.GetFilial
   DA.DepoPartType=DPT.Classified(+)
   and DA.DepoPartition = DAP.Classified(+)
   and DT.Classified = D.Type 
   and D.Doc = T.Classified
--   and T.DocState =Constants.State_Start
   and OP.Obj(+) = D.Classified
   and OP.Prop(+) =nPropClass
   and (nIsHidden = 2
    or (nIsHidden = 1 and nvl(OP.Status, 0) = 0 and nvl(DPT.IsHidden, 0)=0)
    or (nIsHidden = 3 and (nvl(OP.Status, 0) = 1 or (nvl(OP.Status, 0) = 0 and nvl(DPT.IsHidden, 0)=1))))
   and DA.Depo = D.Classified
   and DA.SysDepo = SD.Classified
   and DS.SysSecurity = SD.Security 
   and dst.Classified=ds.Type   
   and (nNullOstatki=0 or Depo_ExistsNoZeroRests(DA.SysDepo, dtDate)=1)   
order by nvl(DT.IsActive, 0) desc, nvl(D.Code, ' '), DA.DepoPartition,
          /*nvl(DS.Label,' ') ,*/ DA.Code
          
select * from account where maingeneralacc in ( 
       select classified from od.GENERALACCTREE where instr('50104, 50116, 50205, 50214, 50305, 50313',code) > 0 
       connect by prior classified = parent start with classified = 1000018728
       ) 

select * from GENERALACCTREE where parent = 1000018728

and od.accountB accountBalance(ba.account,to_date('31.05.2014','dd.mm.yyyy')) = 0

--
select sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  td),0))) /*into nAmount*/ from sysdepo SD, deposecurity DS, depoaccount DA, depo D, deposecuritytype DST where 
    /*DST.Classified = nDSTClassified
and*/ DS.SysSecurity = SD.Security 
and DA.DEPOSECURITY = DS.Classified
and D.CLASSIFIED = DA.DEPO
and D.Doctype = 1000168226
and DST.Classified = DS.Type;
--
select sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  td),0))) /*into nAmount*/ from sysdepo SD, deposecurity DS, depoaccount DA, depo D, deposecuritytype DST where 
    /*DST.Classified = nDSTClassified
and*/ DS.SysSecurity = SD.Security 
and DST.Classified = DS.Type;




select * from depo
select * from deposecurity
select * from sysdepo
bbr.BBR_DEPO_F711

Реестр сделок по привлечению МБК за период

select * from dealdeposit where doc in (256855153,226015768)
select * from od.dealtransaction


select SD.classified, DS.*, DA.classified, abs(nvl(DepoAcc.SysDepoBalance(SD.Classified,  td),0)), DST.Classified, d.* /*sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  dtDate),0)))*/ /*into nAmount*/ 
from deposecuritytype DST, deposecurity DS, depoaccount DA, depo D, sysdepo SD where 
    DST.Classified = 1000012160 and DS.SysSecurity = 1024018393
and DST.Classified = DS.Type
and DS.Classified = DA.DEPOSECURITY
and D.CLASSIFIED = DA.DEPO
and D.Doctype = 1000168226
--and d.Type = 1021767783
--and DS.SysSecurity = SD.Security 
and DA.Sysdepo = SD.CLASSIFIED

and abs(nvl(DepoAcc.SysDepoBalance(SD.Classified,  td),0)) != 0

and (D.SysFilial = nFilial or nFilial is null) ;

select * from doctype where classified in (1000168226,1000168255)

select * from depobalance where sysdepo in (1046862671,1201042936,1201226384,1247340384)

select * from od.sysdepo where classified = 1046862671

select distinct doctype from depo

select * from depoaccount da where classified in (1024056229,1024072299)

select * from deposecuritytype where classified = 1000012160

select * from depo

----------------------------------------------------------------------------------
--27/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from dochistory where maindoc = 226015768

-- поправить отчет BBR_TCB_BILL_OPER_MSK для Антиповой (добавить входящий параметр "показывать только операции с нерезидентами" IPI 160437 =>
-- перевести задачу на Волкорезова                                                                                                                                  ++

BBR_TCB_BILL_OPER_MSK

case
when nvl(ObjAttr.GetOneProp(c.classified,
ObjAttr.PropClass(6)),
1) = 1 then
'Да'
else
'Нет'
end as isres;

   and ((bOnlyNeres = 0 and ((nvl(ObjAttr.GetOneProp(tbl1.cur75,ObjAttr.PropClass(6)),1) != 1) or (nvl(ObjAttr.GetOneProp(tbl2.cur75,ObjAttr.PropClass(6)),1) != 1))) 
       or bOnlyNeres = 1) 
       
   and ((bOnlyNeres = 0 and ((nvl(ObjAttr.GetOneProp(nvl(tbl1.cur75,1),ObjAttr.PropClass(6)),1) != 1) or (nvl(ObjAttr.GetOneProp(nvl(tbl2.cur75,1),ObjAttr.PropClass(6)),1) != 1))) or bOnlyNeres = 1)

   and ((nvl(ObjAttr.GetOneProp(nvl(tbl1.cur75,1),ObjAttr.PropClass(6)),1) != 1) or (nvl(ObjAttr.GetOneProp(nvl(tbl2.cur75,1),ObjAttr.PropClass(6)),1) != 1))

select nvl(ObjAttr.GetOneProp(nvl(null,1),ObjAttr.PropClass(6)),1) from dual where 1!=1

select * from
(select 1 as a from dual) tbl1
left join 
(select 1 as a from dual) tbl2
ON tbl1.a = tbl2.a
where 1!=1

((nvl(ObjAttr.GetOneProp(nvl(tbl1.cur75,1),ObjAttr.PropClass(6)),1) != 1) /*or (nvl(ObjAttr.GetOneProp(nvl(tbl2.cur75,1),ObjAttr.PropClass(6)),1) != 1)*/)

od.ART_Bank_screen;

select * from tcb_bill
select * from testcred
select * from client where classified = 1

-- 03/07/2014 поправил по просьбе Филимоновой
((bOnlyNeres = 0 and ((nvl(ObjAttr.GetOneProp(nvl(tbl1.cur75,1),ObjAttr.PropClass(6)),1) != 1) or (nvl(ObjAttr.GetOneProp(nvl(tbl2.cur75,1),ObjAttr.PropClass(6)),1) != 1))) or bOnlyNeres = 1)

----------------------------------------------------------------------------------
--30/06/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил номинал по векселю '00014' для Рыжовой (с 250000000 на 200000000)                                                                                          ++
select rowid, b.* from bill b where num = '00014'

-- поменял по векселям даты Date1 - просила Цыплина (Нижний Новгород) счета 523* остались старые, хотя по-хорошему надо новые                                        ++

0019450	02.07.2014	01.09.2014
0019451	02.07.2014	01.09.2014
0019454	05.11.2014	02.12.2014
0019455	05.11.2014	01.12.2014
0019457	12.01.2015	02.02.2015

select * from bill where num = '0019450' and classified = 1330395623
update bill set Date1 = to_date('01092014','ddmmyyyy') where num = '0019450' and classified = 1330395623

select * from bill where num = '0019451' and classified = 1330395808
update bill set Date1 = to_date('01092014','ddmmyyyy') where num = '0019451' and classified = 1330395808
       
select * from bill where num = '0019454' and classified = 1330396059
update bill set Date1 = to_date('02122014','ddmmyyyy') where num = '0019454' and classified = 1330396059

select * from bill where num = '0019455' and classified = 1330396085
update bill set Date1 = to_date('01122014','ddmmyyyy') where num = '0019455' and classified = 1330396085

select * from bill where num = '0019457' and classified = 1330396180
update bill set Date1 = to_date('02022015','ddmmyyyy') where num = '0019457' and classified = 1330396180
-- также пришлось поменять по двум векселям repayinterval                                                                                                                                                                                                                                                                              
select rowid, b.* from bill b where num in ('0019450','0019451')
select rowid, br.* from billrepayinterval br where bill in (1330395623,1330395808)

----------------------------------------------------------------------------------
--01/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from repayinterval

select length('Налоговая декларация за предыдущий календарный год и истекшие кварталы текущего года (при наличии)') from dual

-- правил отчет в RN "Ежеквартальный отчет сделок swap (своп-договоров)" для Ледовской, так как в количество договоров попадали лишние переходящие с предыдущего месяца 
-- сделки => тестит Ледовская                                                                                                                                        +-

----------------------------------------------------------------------------------
--03/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from  v_account
where account = 217073762
select * from doctree
select * from od.accountcode

ACCOUNT PACT

ptnGeneralGuid

od.DPC_TCB_CreateBillAcc

select * from billrange

select * from account where pact  

select * from doctree where classified = 124751

-- правил DPC_TCB_CreateBillAcc (закомментил кусок про 52501)                                                                                                        ++

od.DPC_TCB_CreateBillAcc
od.Get_TCB_BillAccountCode

----------------------------------------------------------------------------------
--04/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

SELECT DISTINCT
       dst.label, ClientLabel(ds.issuer), CASE WHEN LENGTH(get_allcertnum(SS.CLASSIFIED))<6 THEN nvl(ds.registrcode,get_allcertnum(SS.CLASSIFIED)) ELSE get_allcertnum(SS.CLASSIFIED) END AS numreg/*, SS.CLASSIFIED*/ ,
       ds.facevalue,getcurrencyname(ds.currency)
FROM Depo d, DepoAccount da, DepoAccount dp, DepoSecurity DS, DepoSecurityType dst,
     DepoAccount daf, DepoType dty  ,Syssecurityseries SS , client c
WHERE d.Classified IN(28244574,131449437,214728600,251198830)

AND da.Depo=d.Classified
AND da.Denominator=1
AND SS.SECURITY = da.deposecurity
AND dp.Classified=da.DepoPartition
AND DS.Classified=da.DepoSecurity
AND DS.IsWork=1
AND getclientisphys(ds.issuer)=1
--AND getdoctype(ds.issuer) <> 1014337927
AND c.doc = ds.issuer
AND c.doctype <> 1014337927
AND dst.Classified=ds.Type
AND daf.Classified(+)=da.FractionAccount
AND dty.Classified=d.Type
AND (da.closed IS NULL OR da.closed> to_date('03072014','ddmmyy'))
AND SS.CLASSIFIED IN (SELECT DISTINCT sss.classified
FROM DepoCertBalance dcb, SysSecuritySeries sss, SysCertificate sc
WHERE dcb.BegDate <= to_date('03072014','ddmmyy') and to_date('03072014','ddmmyy') < dcb.EndDate
AND sc.Classified=dcb.Certificate
AND dst.classified NOT in (1000082479,1000032131,1000082480)
AND dcb.amount > 0
AND sss.Classified=sc.Series  )
order by 2,4 ;

----------------------------------------------------------------------------------
--07/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select r.*
        from  Account a
        left join (SELECT ob.validtodate as validtodate, ob.validfromdate as validfromdate, ob.Obj, substr( AccountCode( ob.Obj ), 1, 254 ) AccountCode, ob.AssocOrder
                     FROM ObjAssoc ob
                    WHERE Category = 37 and substr( AccountCode( ob.Obj ), 1, 254 ) like '933%'
                    START WITH ob.Obj in ( SELECT Obj FROM ObjAssoc OA
                    WHERE Classified IN ( SELECT Classified FROM ObjAssoc
                                           WHERE Category = 37
                                           START WITH Obj in 167692921/*,209774301*/
                                         CONNECT BY Assoc = PRIOR Obj )
                  and not exists( select Classified from ObjAssoc
                                   where Category=37 and Assoc=OA.Obj ) )
                  CONNECT BY PRIOR Assoc = ob.Obj )R
          on (substr(trim(R.AccountCode),10,10) = substr(trim(a.code),10,10)
         and substr(trim(R.AccountCode),6,3) = substr(trim(a.code),6,3)
         and (case when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') > 90 then 90
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') between 30 and 90 then 30
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') between 7 and 30 then 7
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') between 1 and 7  then 1
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') = 0 then 0
               end ) = GetAccMinTime(R.obj))
        left join Account aa on aa.code = R.AccountCode
        where abs(coalesce(accRestIn(a.classified, to_date('20140702','yyyymmdd'), 1, 0),0))= 0 and coalesce(aa.classified,0)<>0
      /* and a.classified in (167692921,
                            209774301)*/
        and  a.classified = 167692921          

             

       select r.*
        from  Account a
        left join (SELECT ob.validtodate as validtodate, ob.validfromdate as validfromdate, ob.Obj, substr( AccountCode( ob.Obj ), 1, 254 ) AccountCode, ob.AssocOrder
                     FROM ObjAssoc ob
                    WHERE Category = 37 and substr( AccountCode( ob.Obj ), 1, 254 ) like '933%'
                    START WITH ob.Obj in ( SELECT Obj FROM ObjAssoc OA
                    WHERE Classified IN ( SELECT Classified FROM ObjAssoc
                                           WHERE Category = 37
                                           START WITH Obj in (167692921,209774301)
                                         CONNECT BY Assoc = PRIOR Obj )
                  and not exists( select Classified from ObjAssoc
                                   where Category=37 and Assoc=OA.Obj ) )
                  CONNECT BY PRIOR Assoc = ob.Obj  )R
          on (substr(trim(R.AccountCode),10,10) = substr(trim(a.code),10,10)
         and substr(trim(R.AccountCode),6,3) = substr(trim(a.code),6,3)
         and (case when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') > 90 then 90
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') between 30 and 90 then 30
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') between 7 and 30 then 7
                   when to_date('20140707','yyyymmdd')  - to_date('20140702','yyyymmdd') between 1 and 7  then 1
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') = 0 then 0
               end ) = /*R.AssocOrder*/ GetAccMinTime(R.obj))
        left join Account aa on aa.code = R.AccountCode
       where abs(coalesce(accRestIn(a.classified, to_date('20140702','yyyymmdd'), 1, 0),0))= 0 and coalesce(aa.classified,0)<>0
      /* and a.classified in (167692921,
                            209774301)*/
        and  a.classified =  167692921   
        
        
        
        select r.*
        from  Account a
        left join (SELECT ob.validtodate as validtodate, ob.validfromdate as validfromdate, ob.Obj, substr( AccountCode( ob.Obj ), 1, 254 ) AccountCode, ob.AssocOrder
                     FROM ObjAssoc ob
                    WHERE Category = 37 and substr( AccountCode( ob.Obj ), 1, 254 ) like '933%'
                    START WITH ob.Obj in ( SELECT Obj FROM ObjAssoc OA
                    WHERE Classified IN ( SELECT Classified FROM ObjAssoc
                                           WHERE Category = 37
                                           START WITH Obj in (167692921/*,209774301*/)
                                         CONNECT BY Assoc = PRIOR Obj )
                  and not exists( select Classified from ObjAssoc
                                   where Category=37 and Assoc=OA.Obj ) )
                  CONNECT BY PRIOR Assoc = ob.Obj  )R
          on (substr(trim(R.AccountCode),10,10) = substr(trim(a.code),10,10)
         and substr(trim(R.AccountCode),6,3) = substr(trim(a.code),6,3)
         and (case when to_date('20140707','yyyymmdd') - to_date('20140707','yyyymmdd') > 90 then 90
                   when to_date('20140707','yyyymmdd') - to_date('20140707','yyyymmdd') between 30 and 90 then 30
                   when to_date('20140707','yyyymmdd') - to_date('20140707','yyyymmdd') between 7 and 30 then 7
                   when to_date('20140707','yyyymmdd')  - to_date('20140707','yyyymmdd') between 1 and 7  then 1
                   when to_date('20140707','yyyymmdd') - to_date('20140707','yyyymmdd') = 0 then 0
               end ) = R.AssocOrder /*GetAccMinTime(R.obj)*/)
        left join Account aa on aa.code = R.AccountCode
       where abs(coalesce(accRestIn(a.classified, to_date('20140707','yyyymmdd'), 1, 0),0))= 0 and coalesce(aa.classified,0)<>0
       and a.classified in (167692921/*,
                            209774301*/)
                            
       select * from account where classified in (167692921,209774301/*,167692922*/) 
                       



       select r.*
        from  Account a
        left join (SELECT ob.validtodate as validtodate, ob.validfromdate as validfromdate, ob.Obj, substr( AccountCode( ob.Obj ), 1, 254 ) AccountCode, ob.AssocOrder
                     FROM ObjAssoc ob
                    WHERE Category = 37 and substr( AccountCode( ob.Obj ), 1, 254 ) like '933%'
                    START WITH ob.Obj in ( SELECT Obj FROM ObjAssoc OA
                    WHERE Classified IN ( SELECT Classified FROM ObjAssoc
                                           WHERE Category = 37
                                           START WITH Obj in (167692921,209774301)
                                         CONNECT BY Assoc = PRIOR Obj )
                  and not exists( select Classified from ObjAssoc
                                   where Category=37 and Assoc=OA.Obj ) )
                  CONNECT BY PRIOR Assoc = ob.Obj  )R
          on (substr(trim(R.AccountCode),10,10) = substr(trim(a.code),10,10)
         and substr(trim(R.AccountCode),6,3) = substr(trim(a.code),6,3)
         and (case when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') > 90 then 90
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') between 30 and 90 then 30
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') between 7 and 30 then 7
                   when to_date('20140707','yyyymmdd')  - to_date('20140702','yyyymmdd') between 1 and 7  then 1
                   when to_date('20140707','yyyymmdd') - to_date('20140702','yyyymmdd') = 0 then 0
               end ) = R.AssocOrder)
        left join Account aa on aa.code = R.AccountCode
       where abs(coalesce(accRestIn(a.classified, to_date('20140702','yyyymmdd'), 1, 0),0))= 0 and coalesce(aa.classified,0)<>0
      /* and a.classified in (167692921,
                            209774301)*/
        and  a.classified =  167692921                          

od.GetAccMinTime

----------------------------------------------------------------------------------
--08/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- выгрузка из Депозитария для ФАС IPI 197227                                                                                                                         
-- написал процедуру getregionNBKI_tcb и запрос v.8                                                                                                                  ++
-- сделать отчет в Афине BBR_TCB_DEPO_FAS => тестит Гордеева                                                                                                         +- 

bbr.BBR_TCB_DEPO_FAS   

od.getregioncl2_tcb

SELECT S.Issuer,
       ST.Code,
       ST.Classified,  
       GetObjectCode(S.Issuer, 20, td),
       od.ClientLabel(S.Issuer)||decode(ST.ConstType,11, ' ('||S.Label||')', null),
       S.SysSecurity, --Decode(ST.ISEMISSIVE, 1, S.SysSecurity, 0)
       GetObjectCode(S.Classified, 1004, td),
       DS.Classified,
       NVL(DS.FaceValue, S.FaceValue),
       DepoSecurityCalcFaceValue(S.SysSecurity, td),--S.FaceValue,
       ST.Description,
       decode(ST.ISEMISSIVE, 1,
           decode(nvl(objAttr.GetOneProp(S.Issuer, PropClass(6)),1), 
                 1, nvl(nvl(S.RegistrCode, GetObjectCode(S.Classified,1003)),'  -'),
                    nvl(nvl(GetObjectCode(S.Classified,1003), S.RegistrCode),'  -') 
                 ),
           null
             ),
      S.Currency,
      nvl(GetObjectCode(S.Classified, 1004, td), ST.Code),
      ST.ConstType,
      decode(ST.ISEMISSIVE, 1,
               decode(nvl(objAttr.GetOneProp(S.Issuer, PropClass(6)),1), 
                      1, decode(S.RegistrCode, 
                                null, decode(GetObjectCode(S.Classified,1003), null, null, 2),
                                1),
                         decode(GetObjectCode(S.Classified,1003), 
                                null, decode(S.RegistrCode, null, null, 1),
                                2)
                      ),
               null
             )  
FROM DepoSecurity S, DepoSecurityType ST, DepoSecuritySet DSS, DepoSecurity DS --группа
WHERE ST.Classified = S.Type
  and nvl(S.ValidFromDate,td) <= td
  and nvl(S.ValidToDate,td + 1) > td
  and DSS.DepoSecurity(+) = S.Classified
  and DS.Classified(+) = DSS.DepoSecuritySet
  and ST.ConstType <> 5 --не векселя

UNION --Векселя

SELECT DISTINCT 
       S.Issuer,
       ST.Code,
       ST.Classified,  
       GetObjectCode(S.Issuer, 20, td),
       od.ClientLabel(S.Issuer),
       S.SysSecurity,
       GetObjectCode(S.Classified, 1004, td),
       S.Classified,
       nvl(SC.BillNominal,1), 
       nvl(SC.BillNominal,1),
       ST.Description,
       null,
       nvl(SC.BILLCURRENCY,1000001275), 
       nvl(GetObjectCode(S.Classified, 1004, td), ST.Code),
       ST.ConstType,
       null
FROM DepoSecurity S, DepoSecurityType ST, DepoAccount DA, DEPOCERTBALANCE B, SysCertificate SC
WHERE ST.Classified = S.Type
  and nvl(S.ValidFromDate,td) <= td
  and nvl(S.ValidToDate,td + 1) > td
  and ST.ConstType = 5 /* векселя*/
  and B.SysDepo = DA.SysDepo
  and DA.DepoSecurity = S.Classified
  and B.BEGDATE <  td
  and B.EndDate >= td
  and B.CERTIFICATE = SC.Classified
  and B.Amount!=0
--  and S.Issuer=24679818 

order by 5, 14, 4, 11, 13, 10


--v.1------
/*if nConstType <> 5 then
  sSelect :=*/ 
select nvl(sum(DepoAcc.SysDepoBalanceIn(SD.Classified, to_date('31/12/2012','dd/mm/yyyy'))),0) as nCount, 
x.IssName, 
nvl((select label from clientregiontree where classified in (od.getclientreg1_tcb(x.Issuer))),nvl(od.tcb_tools.addressLines(x.Issuer, 'AddressJur', 'Region'),nvl(od.tcb_tools.addressLines(x.Issuer, 'AddressPost', 'Region'),/*nvl(*/od.tcb_tools.addressLines(x.Issuer, 'AddressFact', 'Region')/*,od.tcb_tools.addressLines(x.Issuer, 'AddressJur', 'City'))*/))), 
--od.tcb_tools.addressLines(x.Issuer, 'AddressJur', 'Region'),
--od.tcb_tools.addressLines(x.Issuer, 'AddressPost', 'Region'),
--od.tcb_tools.addressLines(x.Issuer, 'AddressFact', 'Region'),
x.SysSecurity
   --'    to_date('''||dtDate||''')) ' ||  -- Успенский - непонятно что хотелось?
   --' * '||nvl(nNominal,1)||'/'|| nvl(nValue,1) || 
   --' / nvl(DA.DENOMINATOR,1)),0) nCount, ';
/*else
  sSelect :=*/  
  /*select nvl(sum(od.DEPO_GET_CERTCOUNT_BY_NOM(SD.Classified, '||nvl(nNominal,1)||', 
        to_date('''||dtDate||'''))),0) nCount, ';*/
/*end if;*/
/*
sSelect := sSelect ||
'    1-DpT.IsService , '||
'    DpT.ConstType, '||
'    nvl(od.ObjAttr.GetOneProp(D.Client,'||nRezProp||', to_date('''||dtDate||''')),1) nPriznRez,  '||
'    nvl(od.GetClientIsPhys(D.Client),0) nPriznFiz, '||
'    decode(GetCLientType(D.Client),'||nClTypeBank||',1,null,0,0), D.Code '||
*/
from DepoAccount DA, SysDepo SD, DepoSecurity DS, Depo D, DepoType DpT,
(
SELECT S.Issuer,
       ST.Code,
       ST.Classified as STClassified,  
       GetObjectCode(S.Issuer, 20, to_date('31/12/2012','dd/mm/yyyy')),
       od.ClientLabel(S.Issuer)||decode(ST.ConstType,11, ' ('||S.Label||')', null) as IssName,
       S.SysSecurity, --Decode(ST.ISEMISSIVE, 1, S.SysSecurity, 0)
       GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')),
       DS.Classified,
       NVL(DS.FaceValue, S.FaceValue),
       DepoSecurityCalcFaceValue(S.SysSecurity, to_date('31/12/2012','dd/mm/yyyy')),--S.FaceValue,
       ST.Description,
       decode(ST.ISEMISSIVE, 1,
           decode(nvl(objAttr.GetOneProp(S.Issuer, PropClass(6)),1), 
                 1, nvl(nvl(S.RegistrCode, GetObjectCode(S.Classified,1003)),'  -'),
                    nvl(nvl(GetObjectCode(S.Classified,1003), S.RegistrCode),'  -') 
                 ),
           null
             ),
      S.Currency,
      nvl(GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')), ST.Code),
      ST.ConstType,
      decode(ST.ISEMISSIVE, 1,
               decode(nvl(objAttr.GetOneProp(S.Issuer, PropClass(6)),1), 
                      1, decode(S.RegistrCode, 
                                null, decode(GetObjectCode(S.Classified,1003), null, null, 2),
                                1),
                         decode(GetObjectCode(S.Classified,1003), 
                                null, decode(S.RegistrCode, null, null, 1),
                                2)
                      ),
               null
             )  
FROM DepoSecurity S, DepoSecurityType ST, DepoSecuritySet DSS, DepoSecurity DS --группа
WHERE ST.Classified = S.Type
  and nvl(S.ValidFromDate,to_date('31/12/2012','dd/mm/yyyy')) <= to_date('31/12/2012','dd/mm/yyyy')
  and nvl(S.ValidToDate,to_date('31/12/2012','dd/mm/yyyy') + 1) > to_date('31/12/2012','dd/mm/yyyy')
  and DSS.DepoSecurity(+) = S.Classified
  and DS.Classified(+) = DSS.DepoSecuritySet
  and ST.ConstType <> 5 --не векселя

UNION --Векселя

SELECT DISTINCT 
       S.Issuer,
       ST.Code,
       ST.Classified,  
       GetObjectCode(S.Issuer, 20, to_date('31/12/2012','dd/mm/yyyy')),
       od.ClientLabel(S.Issuer),
       S.SysSecurity,
       GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')),
       S.Classified,
       nvl(SC.BillNominal,1), 
       nvl(SC.BillNominal,1),
       ST.Description,
       null,
       nvl(SC.BILLCURRENCY,1000001275), 
       nvl(GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')), ST.Code),
       ST.ConstType,
       null
FROM DepoSecurity S, DepoSecurityType ST, DepoAccount DA, DEPOCERTBALANCE B, SysCertificate SC
WHERE ST.Classified = S.Type
  and nvl(S.ValidFromDate,to_date('31/12/2012','dd/mm/yyyy')) <= to_date('31/12/2012','dd/mm/yyyy')
  and nvl(S.ValidToDate,to_date('31/12/2012','dd/mm/yyyy') + 1) > to_date('31/12/2012','dd/mm/yyyy')
  and ST.ConstType = 5 /* векселя*/
  and B.SysDepo = DA.SysDepo
  and DA.DepoSecurity = S.Classified
  and B.BEGDATE <  to_date('31/12/2012','dd/mm/yyyy')
  and B.EndDate >= to_date('31/12/2012','dd/mm/yyyy')
  and B.CERTIFICATE = SC.Classified
  and B.Amount!=0
) x

--if sBankCode is not null then 
--   sSelect := sSelect ||', BankCode BC ';
--end if;

where  DS.Issuer= x.Issuer

--if sBankCode is not null then 
--   sSelect := sSelect ||
--'   and  BC.Client = DS.Classified '||
--'   and  BC.CodeSystem = '||n1004||
--'   and  BC.Code = '''|| sBankCode ||'''';
--else
and  DS.Type = x.STClassified
--end if;

and  DS.SysSecurity = x.SysSecurity
and  SD.IsActive = 0 
and  D.Type = DpT.Classified 
and  DA.Depo = D.Classified 
and  DA.SysDepo = SD.Classified 
and  DS.SysSecurity = SD.Security

--if nFilial is not null then 
--sSelect := sSelect ||
--'   and D.SysFilial = '||nFilial ||' ';
--end if;
group by x.IssName, x.Issuer, x.SysSecurity /*1-DpT.IsService, DpT.ConstType, 
nvl(od.ObjAttr.GetOneProp(D.Client,1000002566, td),1),
nvl(od.GetClientIsPhys(D.Client),0),
decode(GetCLientType(D.Client),'||nClTypeBank||',1,null,0,0),  D.Code*/ 
order by 2
--------

od.getclientreg_tcb

CREATE OR REPLACE Function getregionNBKI_tcb(nCode BankCode.Code%type, nDate date) Return Clientregiontree.Label%Type
/*********************************************************
    09.07.2014 - Панфилов М.С. -  функция возвращает label региона по коду НБКИ 
*********************************************************/ 
As
    sRegion Clientregiontree.Label%Type;        -- регион      
Begin
  select (select label from clientregiontree where classified = bc.client) into sRegion 
  from od.BankCode bc where codesystem = 1075366264 and code = nCode and nDate >= nvl(validfromdate,MIN_DATE) and nDate < nvl(validtodate,MAX_DATE);

Return sRegion;

Exception When others Then
    Return Null;
end getregionNBKI_tcb;

CREATE OR REPLACE Function getregioncl2_tcb(idClient Client.Classified%type) Return Clientregiontree.Label%Type
/*********************************************************
    11.07.2014 - Панфилов М.С. -  функция возвращает label региона по клиенту (если lev = 2, то берем родительский регион)
*********************************************************/
As
    sRegion Clientregiontree.Label%Type;      -- регион
    idRegion Clientregiontree.Classified%Type;
    nLev Clientregiontree.Lev%Type;
Begin
    begin
    Select Classified, Lev Into idRegion, nLev from clientregiontree where classified in (select
    ClientRegion
    from Client Where Classified = idClient);
    Exception When others Then null;
    end;

    if sRegion is null then
    Select Classified, Lev Into idRegion, nLev from clientregiontree where classified in (select
    coalesce(od.tcb_tools.addressLines(idClient, 'AddressJur', 'ClientRegion'),od.tcb_tools.addressLines(idClient, 'AddressPost', 'ClientRegion'),od.tcb_tools.addressLines(idClient, 'AddressFact', 'ClientRegion'))
    from Client Where Classified = idClient);
    end if;
    
    if idRegion = 1000043360 then
      Select Classified, Lev Into idRegion, nLev from clientregiontree where classified = (select clientregion from client where classified = idClient);
    end if;

    if nLev = 2 then
       Select label Into sRegion from clientregiontree where classified = (select Parent from clientregiontree where classified = idRegion);
    else
       Select label Into sRegion from clientregiontree where classified = idRegion;
    end if;

Return sRegion;

Exception When others Then
    Return Null;
end getregioncl2_tcb;


select getregionNBKI_tcb('12',td) from dual
select * from deposecurity

select Classified
--into nRezProp
from PropList
where ConstProp = 6

select od.getregion(od.getclientreg_tcb(155748252)) from dual 

select * from clientregiontree where classified in (1000043360,1000132730,1000132733,1000132631,1000132688,1000132706
)

select label from clientregiontree where classified in (1000043360,1000132730,1000132733,1000132631,1000132688,1000132706)

od.getregiongroup_tcb

select od.GetClientCode(119716544,20) from dual

select * from clientregiontree where

select * from od.clientcode

select * from od.V_BankCodeN where client = 1000132952 and const = 2600
select * from od.BankCode where client = 1000132940
select * from clientregiontree where classified = 1000132940

                   when '31'  then 'Белгородская область'
                   when '36'  then 'Воронежская область'
                   when '46'  then 'Курская область'
                   when '77'  then 'г.Москва'
                   when '1'  then 'Самарская область'
                   when '1'  then 'г. Санкт-Петербург'
                   when '1'  then 'Ирскутская область'
                   when '1'  then 'Ярославская область'
                   when '1'  then 'Калининградская область'
                   when '1'  then 'Калужская область'
                   when '1'  then 'Кемеровская область'
                   when '1'  then 'Краснодарский край'
                   when '1'  then 'Ленинградская область'
                   when '1'  then 'Московская область'
                   when '1'  then 'Мурманская область'
                   when '1'  then 'Омская область'
                   when '1'  then 'Пермский край'
                   when '1'  then 'Приморский край'
                   when '1'  then 'Республика КОМИ'
                   when '1'  then 'Республика Татарстан'
                   when '1'  then 'Свердловская область'
                   when '1'  then 'Тюменская область'
                   when '1'  then 'ХМАО'
                   when '1'  then 'ЯНАО'
                   when '1'  then 'Удмуртская республика'

                   else ''
                 end

--v.2------
/*if nConstType <> 5 then
  sSelect :=*/ 
select nvl(sum(DepoAcc.SysDepoBalanceIn(SD.Classified, to_date('31/12/2012','dd/mm/yyyy'))),0) as nCount, 
x.IssName, 
od.GetObjectCode(x.Issuer,20,to_date('31/12/2012','dd/mm/yyyy'),0) as INN,
substr(od.GetObjectCode(x.Issuer,20,to_date('31/12/2012','dd/mm/yyyy'),0),0,2) as IssRegionCode,
getregionNBKI_tcb(substr(od.GetObjectCode(x.Issuer,20,to_date('31/12/2012','dd/mm/yyyy'),0),0,2),to_date('31/12/2012','dd/mm/yyyy')) as IssRegion, 
x.SysSecurity
   --'    to_date('''||dtDate||''')) ' ||  -- Успенский - непонятно что хотелось?
   --' * '||nvl(nNominal,1)||'/'|| nvl(nValue,1) || 
   --' / nvl(DA.DENOMINATOR,1)),0) nCount, ';
/*else
  sSelect :=*/  
  /*select nvl(sum(od.DEPO_GET_CERTCOUNT_BY_NOM(SD.Classified, '||nvl(nNominal,1)||', 
        to_date('''||dtDate||'''))),0) nCount, ';*/
/*end if;*/
/*
sSelect := sSelect ||
'    1-DpT.IsService , '||
'    DpT.ConstType, '||
'    nvl(od.ObjAttr.GetOneProp(D.Client,'||nRezProp||', to_date('''||dtDate||''')),1) nPriznRez,  '||
'    nvl(od.GetClientIsPhys(D.Client),0) nPriznFiz, '||
'    decode(GetCLientType(D.Client),'||nClTypeBank||',1,null,0,0), D.Code '||
*/
from DepoAccount DA, SysDepo SD, DepoSecurity DS, Depo D, DepoType DpT,
(
SELECT S.Issuer,
       ST.Code,
       ST.Classified as STClassified,  
       GetObjectCode(S.Issuer, 20, to_date('31/12/2012','dd/mm/yyyy')),
       od.ClientLabel(S.Issuer)||decode(ST.ConstType,11, ' ('||S.Label||')', null) as IssName,
       S.SysSecurity, --Decode(ST.ISEMISSIVE, 1, S.SysSecurity, 0)
       GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')),
       DS.Classified,
       NVL(DS.FaceValue, S.FaceValue),
       DepoSecurityCalcFaceValue(S.SysSecurity, to_date('31/12/2012','dd/mm/yyyy')),--S.FaceValue,
       ST.Description,
       decode(ST.ISEMISSIVE, 1,
           decode(nvl(objAttr.GetOneProp(S.Issuer, PropClass(6)),1), 
                 1, nvl(nvl(S.RegistrCode, GetObjectCode(S.Classified,1003)),'  -'),
                    nvl(nvl(GetObjectCode(S.Classified,1003), S.RegistrCode),'  -') 
                 ),
           null
             ),
      S.Currency,
      nvl(GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')), ST.Code),
      ST.ConstType,
      decode(ST.ISEMISSIVE, 1,
               decode(nvl(objAttr.GetOneProp(S.Issuer, PropClass(6)),1), 
                      1, decode(S.RegistrCode, 
                                null, decode(GetObjectCode(S.Classified,1003), null, null, 2),
                                1),
                         decode(GetObjectCode(S.Classified,1003), 
                                null, decode(S.RegistrCode, null, null, 1),
                                2)
                      ),
               null
             )  
FROM DepoSecurity S, DepoSecurityType ST, DepoSecuritySet DSS, DepoSecurity DS --группа
WHERE ST.Classified = S.Type
  and nvl(S.ValidFromDate,to_date('31/12/2012','dd/mm/yyyy')) <= to_date('31/12/2012','dd/mm/yyyy')
  and nvl(S.ValidToDate,to_date('31/12/2012','dd/mm/yyyy') + 1) > to_date('31/12/2012','dd/mm/yyyy')
  and DSS.DepoSecurity(+) = S.Classified
  and DS.Classified(+) = DSS.DepoSecuritySet
  and ST.ConstType <> 5 --не векселя

UNION --Векселя

SELECT DISTINCT 
       S.Issuer,
       ST.Code,
       ST.Classified,  
       GetObjectCode(S.Issuer, 20, to_date('31/12/2012','dd/mm/yyyy')),
       od.ClientLabel(S.Issuer),
       S.SysSecurity,
       GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')),
       S.Classified,
       nvl(SC.BillNominal,1), 
       nvl(SC.BillNominal,1),
       ST.Description,
       null,
       nvl(SC.BILLCURRENCY,1000001275), 
       nvl(GetObjectCode(S.Classified, 1004, to_date('31/12/2012','dd/mm/yyyy')), ST.Code),
       ST.ConstType,
       null
FROM DepoSecurity S, DepoSecurityType ST, DepoAccount DA, DEPOCERTBALANCE B, SysCertificate SC
WHERE ST.Classified = S.Type
  and nvl(S.ValidFromDate,to_date('31/12/2012','dd/mm/yyyy')) <= to_date('31/12/2012','dd/mm/yyyy')
  and nvl(S.ValidToDate,to_date('31/12/2012','dd/mm/yyyy') + 1) > to_date('31/12/2012','dd/mm/yyyy')
  and ST.ConstType = 5 /* векселя*/
  and B.SysDepo = DA.SysDepo
  and DA.DepoSecurity = S.Classified
  and B.BEGDATE <  to_date('31/12/2012','dd/mm/yyyy')
  and B.EndDate >= to_date('31/12/2012','dd/mm/yyyy')
  and B.CERTIFICATE = SC.Classified
  and B.Amount!=0
) x

--if sBankCode is not null then 
--   sSelect := sSelect ||', BankCode BC ';
--end if;

where  DS.Issuer= x.Issuer

--if sBankCode is not null then 
--   sSelect := sSelect ||
--'   and  BC.Client = DS.Classified '||
--'   and  BC.CodeSystem = '||n1004||
--'   and  BC.Code = '''|| sBankCode ||'''';
--else
and  DS.Type = x.STClassified
--end if;

and  DS.SysSecurity = x.SysSecurity
and  SD.IsActive = 0 
and  D.Type = DpT.Classified 
and  DA.Depo = D.Classified 
and  DA.SysDepo = SD.Classified 
and  DS.SysSecurity = SD.Security

--if nFilial is not null then 
--sSelect := sSelect ||
--'   and D.SysFilial = '||nFilial ||' ';
--end if;
group by x.IssName, x.Issuer, x.SysSecurity /*1-DpT.IsService, DpT.ConstType, 
nvl(od.ObjAttr.GetOneProp(D.Client,1000002566, td),1),
nvl(od.GetClientIsPhys(D.Client),0),
decode(GetCLientType(D.Client),'||nClTypeBank||',1,null,0,0),  D.Code*/ 
order by 2
--------


--v.3------
select count(DA.Classified), sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2012','dd/mm/yyyy')),0))) /*into nAmount*/, 
od.clientlabel(DS.Issuer) as IssName,
od.GetObjectCode(DS.Issuer,20,to_date('31/12/2012','dd/mm/yyyy'),0) as INN,
substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2012','dd/mm/yyyy'),0),0,2) as IssRegionCode,
getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2012','dd/mm/yyyy'),0),0,2),to_date('31/12/2012','dd/mm/yyyy')) as IssRegion
from sysdepo SD, depoaccount DA, deposecurity DS, depo D where 
SD.CLASSIFIED = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
--and D.type in (1021767785)
and (D.SysFilial = 1)
group by DS.Issuer
--------

--v.4------
select 
coalesce(p.Reg,s.Reg,du.Reg,nom.Reg) as "Наименование субъекта РФ",
nvl(p.n1,0) as "Количество физических лиц, шт",
nvl(p.n2,0) as "Количество счетов депо, шт",
nvl(p.n3,0) as "Количество ценных бумаг, шт",
nvl(s.n4,0) as "Количество юридических лиц, шт",
nvl(s.n5,0) as "Количество счетов депо, шт",
nvl(s.n6,0) as "Количество ценных бумаг, шт",
nvl(du.n7,0) as "Количество дов. упр. ц.б., шт",
nvl(du.n8,0) as "Количество счетов депо, шт",
nvl(du.n9,0) as "Количество ценных бумаг, шт",
nvl(nom.n10,0) as "Количество ном. держателей, шт",
nvl(nom.n11,0) as "Количество счетов депо, шт",
nvl(nom.n12,0) as "Количество ценных бумаг, шт"
from
-- физ.
(
select getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg,
count(C.Classified) as n1,
count(DA.Classified) as n2,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n3,
0 as n4,
0 as n5,
0 as n6,
0 as n7,
0 as n8,
0 as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C where 
SD.CLASSIFIED = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
--and D.type in (1021767797)
and nvl(od.GetClientIsPhys(C.Classified),0) = 1
and getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) is not null
group by getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy'))
) p
FULL JOIN
-- соб.
(
select getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg,
0 as n1,
0 as n2,
0 as n3,
count(C.Classified) as n4,
count(DA.Classified) as n5,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n6,
0 as n7,
0 as n8,
0 as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C where 
SD.CLASSIFIED = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (1021767785,1201024558,1025885943)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) is not null
group by getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy'))
) s
ON p.Reg = s.Reg
FULL JOIN
-- ДУ
(
select getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg,
0 as n1,
0 as n2,
0 as n3,
0 as n4,
0 as n5,
0 as n6,
count(C.Classified) as n7,
count(DA.Classified) as n8,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C where 
SD.CLASSIFIED = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (1021767797)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) is not null
group by getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy'))
) du
ON p.Reg = du.Reg
FULL JOIN
-- ном.
(
select getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg,
0 as n1,
0 as n2,
0 as n3,
0 as n4,
0 as n5,
0 as n6,
0 as n7,
0 as n8,
0 as n9,
count(C.Classified) as n10,
count(DA.Classified) as n11,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C where 
SD.CLASSIFIED = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (1021767792)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) is not null
group by getregionNBKI_tcb(substr(od.GetObjectCode(DS.Issuer,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy'))
) nom
ON p.Reg = nom.Reg
--------

--v.5-(не по эмитентам, а по владельцам)----
--select getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg,
select getregioncl2_tcb(C.Classified) as Reg,
getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg2,

od.tcb_tools.addressLines(C.Classified, 'AddressJur', 'City'),

od.clientlabel(C.Classified) as ClName,
od.GetObjectCode(C.Classified,20,to_date('31/12/2012','dd/mm/yyyy'),0) as INN,
substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2012','dd/mm/yyyy'),0),0,2) as ClRegionCode,
--coalesce(getregioncl_tcb(C.Classified),getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy'))) as Reg2,

count(distinct C.Classified) as n4,
count(distinct D.Classified) as n5,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n6
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR where 
SD.CLASSIFIED = DA.Sysdepo 
and DA.DEPOSECURITY = DS.Classified
and DA.DEPO = D.CLASSIFIED
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (/*1021767785,1201024558,1025885943*/1021767792)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and D.classified = DTR.classified and DTR.Docstate = 1000000039
--and getregionNBKI_tcb(substr(od.GetObjectCode(C.Client,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) is not null
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
group by C.Classified
--------

select * from docstate

--v.6-(не по эмитентам, а по владельцам)----
select 
coalesce(p.Reg,s.Reg,du.Reg,nom.Reg) as "Наименование субъекта РФ",
nvl(p.n1,0) as "Количество физических лиц, шт",
nvl(p.n2,0) as "Количество счетов депо, шт",
nvl(p.n3,0) as "Количество ценных бумаг, шт",
nvl(s.n4,0) as "Количество юридических лиц, шт",
nvl(s.n5,0) as "Количество счетов депо, шт",
nvl(s.n6,0) as "Количество ценных бумаг, шт",
nvl(du.n7,0) as "Количество дов. упр. ц.б., шт",
nvl(du.n8,0) as "Количество счетов депо, шт",
nvl(du.n9,0) as "Количество ценных бумаг, шт",
nvl(nom.n10,0) as "Количество ном. держателей, шт",
nvl(nom.n11,0) as "Количество счетов депо, шт",
nvl(nom.n12,0) as "Количество ценных бумаг, шт"
from
-- физ.
(
select getregioncl2_tcb(C.Classified) as Reg,
count(distinct C.Classified) as n1,
count(distinct D.Classified) as n2,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n3,
0 as n4,
0 as n5,
0 as n6,
0 as n7,
0 as n8,
0 as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
--and D.type in (1021767797)
and nvl(od.GetClientIsPhys(C.Classified),0) = 1
--and getregioncl2_tcb(C.Classified) is not null
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
and DTR.DocState in (1000000039,1000000035)
group by getregioncl2_tcb(C.Classified)
) p
FULL JOIN
-- соб.
(
select nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) as Reg,
0 as n1,
0 as n2,
0 as n3,
count(distinct C.Classified) as n4,
count(distinct D.Classified) as n5,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n6,
0 as n7,
0 as n8,
0 as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR  where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (1021767785,1201024558,1025885943)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) is not null
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
and DTR.DocState in (1000000039,1000000035)
group by nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified))
) s
ON p.Reg = s.Reg
FULL JOIN
-- ДУ
(
select nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) as Reg,
0 as n1,
0 as n2,
0 as n3,
0 as n4,
0 as n5,
0 as n6,
count(distinct C.Classified) as n7,
count(distinct D.Classified) as n8,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR  where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (1021767797)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) is not null
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
and DTR.DocState in (1000000039,1000000035)
group by nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified))
) du
ON p.Reg = du.Reg
FULL JOIN
-- ном.
(
select nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) as Reg,
0 as n1,
0 as n2,
0 as n3,
0 as n4,
0 as n5,
0 as n6,
0 as n7,
0 as n8,
0 as n9,
count(distinct C.Classified) as n10,
count(distinct D.Classified) as n11,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR  where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO = D.CLASSIFIED 
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (1021767792)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) is not null
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
and DTR.DocState in (1000000039,1000000035)
group by nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified))
) nom
ON p.Reg = nom.Reg
--------

--v.7-(не по эмитентам, а по владельцам)-( и с пустыми разделами)--
--select getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg,
select getregioncl2_tcb(C.Classified) as Reg,
getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg2,

--od.tcb_tools.addressLines(C.Classified, 'AddressJur', 'City'),

od.clientlabel(C.Classified) as ClName,
od.GetObjectCode(C.Classified,20,to_date('31/12/2012','dd/mm/yyyy'),0) as INN,
substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2012','dd/mm/yyyy'),0),0,2) as ClRegionCode,
--coalesce(getregioncl_tcb(C.Classified),getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy'))) as Reg2,

count(distinct C.Classified) as n4,
count(distinct D.Classified) as n5,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n6
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR where 
SD.CLASSIFIED (+) = DA.Sysdepo 
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO = D.CLASSIFIED
and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
and D.type in (1021767785,1201024558,1025885943,1021767792)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and getregionNBKI_tcb(substr(od.GetObjectCode(C.Client,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) is not null
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
group by C.Classified
--------

--v.8-(не по эмитентам, а по владельцам)----
select 
coalesce(p.Reg,s.Reg,du.Reg,nom.Reg) as "Наименование субъекта РФ",
nvl(p.n1,0) as "Количество физических лиц, шт",
nvl(p.n2,0) as "Количество счетов депо, шт",
nvl(p.n3,0) as "Количество ценных бумаг, шт",
nvl(s.n4,0) as "Количество юридических лиц, шт",
nvl(s.n5,0) as "Количество счетов депо, шт",
nvl(s.n6,0) as "Количество ценных бумаг, шт",
nvl(du.n7,0) as "Количество дов. упр. ц.б., шт",
nvl(du.n8,0) as "Количество счетов депо, шт",
nvl(du.n9,0) as "Количество ценных бумаг, шт",
nvl(nom.n10,0) as "Количество ном. держателей, шт",
nvl(nom.n11,0) as "Количество счетов депо, шт",
nvl(nom.n12,0) as "Количество ценных бумаг, шт"
from
-- физ.
(
select getregioncl2_tcb(C.Classified) as Reg,
count(distinct C.Classified) as n1,
count(distinct D.Classified) as n2,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n3,
0 as n4,
0 as n5,
0 as n6,
0 as n7,
0 as n8,
0 as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR, depotype DTY  where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO (+) = D.CLASSIFIED 
and D.Type = DTY.Classified and DTY.ISACTIVE = 0 and DTY.IsService = 0 
and D.Client = C.CLASSIFIED
--and D.type in (1021767797)
and nvl(od.GetClientIsPhys(C.Classified),0) = 1
--and getregioncl2_tcb(C.Classified) is not null
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
and DTR.DocState in (1000000039,1000000035)
and DTR.Sysfilial = 1
and D.TYPE != 1025885943 -- "владелец не установлен"
group by getregioncl2_tcb(C.Classified)
) p
FULL JOIN
-- соб.
(
select nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) as Reg,
0 as n1,
0 as n2,
0 as n3,
count(distinct C.Classified) as n4,
count(distinct D.Classified) as n5,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n6,
0 as n7,
0 as n8,
0 as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR, depotype DTY   where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO (+) = D.CLASSIFIED 
and D.Type = DTY.Classified and DTY.ISACTIVE = 0 and DTY.IsService = 0 
and D.Client = C.CLASSIFIED
and D.type in (1021767785,1201024558,1025885943)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
--and nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) is not null
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
and DTR.DocState in (1000000039,1000000035)
and DTR.Sysfilial = 1
and D.TYPE != 1025885943 -- "владелец не установлен"
group by nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified))
) s
ON p.Reg = s.Reg
FULL JOIN
-- ДУ
(
select nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) as Reg,
0 as n1,
0 as n2,
0 as n3,
0 as n4,
0 as n5,
0 as n6,
count(distinct C.Classified) as n7,
count(distinct D.Classified) as n8,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n9,
0 as n10,
0 as n11,
0 as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR, depotype DTY where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO (+) = D.CLASSIFIED 
and D.Type = DTY.Classified and DTY.ISACTIVE = 0 and DTY.IsService = 0 
and D.Client = C.CLASSIFIED
and D.type in (1021767797)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
--and nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) is not null
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
and DTR.DocState in (1000000039,1000000035)
and DTR.Sysfilial = 1
and D.TYPE != 1025885943 -- "владелец не установлен"
group by nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified))
) du
ON p.Reg = du.Reg
FULL JOIN
-- ном.
(
select nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) as Reg,
0 as n1,
0 as n2,
0 as n3,
0 as n4,
0 as n5,
0 as n6,
0 as n7,
0 as n8,
0 as n9,
count(distinct C.Classified) as n10,
count(distinct D.Classified) as n11,
sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n12
from sysdepo SD, depoaccount DA, deposecurity DS, depo D, Client C, doctree DTR, depotype DTY  where 
SD.CLASSIFIED (+) = DA.Sysdepo
and DA.DEPOSECURITY = DS.Classified (+)
and DA.DEPO (+) = D.CLASSIFIED 
and D.Type = DTY.Classified and DTY.ISACTIVE = 0 and DTY.IsService = 0 
and D.Client = C.CLASSIFIED
and D.type in (1021767792)
and nvl(od.GetClientIsPhys(C.Classified),0) = 0
--and nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified)) is not null
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
--and nvl(ObjAttr.GetOneProp(c.classified,ObjAttr.PropClass(6)),1) = 1
and DTR.DocState in (1000000039,1000000035)
and DTR.Sysfilial = 1
and D.TYPE != 1025885943 -- "владелец не установлен"
group by nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),getregioncl2_tcb(C.Classified))
) nom
ON p.Reg = nom.Reg
--------


--select getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg,
select getregioncl2_tcb(C.Classified) as Reg,
--getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) as Reg2,

--od.tcb_tools.addressLines(C.Classified, 'AddressJur', 'City'),

od.clientlabel(C.Classified) as ClName,
--od.GetObjectCode(C.Classified,20,to_date('31/12/2012','dd/mm/yyyy'),0) as INN,
--substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2012','dd/mm/yyyy'),0),0,2) as ClRegionCode,
--coalesce(getregioncl_tcb(C.Classified),getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy'))) as Reg2,

count(distinct C.Classified) as n4,
count(distinct D.Classified) as n5,
--sum(abs(nvl(DepoAcc.SysDepoBalanceIn(SD.Classified,  to_date('31/12/2013','dd/mm/yyyy')),0))) /*into nAmount*/ as n6,
D.type 
from /*sysdepo SD,*/ depoaccount DA, /*deposecurity DS,*/ depo D, Client C, doctree DTR where 
/*SD.CLASSIFIED (+) = DA.Sysdepo 
and DA.DEPOSECURITY = DS.Classified (+)
and*/ DA.DEPO (+) = D.CLASSIFIED
--and D.Doctype != 1000168226
and D.Client = C.CLASSIFIED
--and D.type in (1021767785,1201024558,1025885943,1021767792)
and nvl(od.GetClientIsPhys(C.Classified),0) = 1
and DTR.DocState in (1000000039,1000000035)
and D.classified = DTR.classified --and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DTR.Validtodate,MAX_DATE)
and nvl(DTR.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy') and DTR.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
--and getregionNBKI_tcb(substr(od.GetObjectCode(C.Client,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')) is not null
--and to_date('31/12/2013','dd/mm/yyyy') <= nvl(DA.CLOSED,MAX_DATE)
and DTR.Sysfilial = 1
group by C.Classified, D.Classified, D.type 


select * from docstate 
select * from doctree where classified = 28244205

select od.GetClientIsPhys(null) from dual

select * from depo where client is null 
where classified = 28244358
select * from depo
type
select */*distinct consttype*/ from depotype

select * from depo d where not exists (select * from doctree where classified = d.classified) 

select * from od.constantslabel where constvalue in (select distinct consttype from depotype) and table_name = 'DEPOTYPE' 

select 250000000*0.015*(1/365) from dual

nvl(getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')),nvl(od.tcb_tools.addressLines(x.Issuer, 'AddressJur', 'Region'),nvl(od.tcb_tools.addressLines(x.Issuer, 'AddressPost', 'Region'),/*nvl(*/od.tcb_tools.addressLines(x.Issuer, 'AddressFact', 'Region')/*,od.tcb_tools.addressLines(x.Issuer, 'AddressJur', 'City'))*/))),
coalesce(od.tcb_tools.addressLines(x.Issuer, 'AddressJur', 'ClientRegion'),od.tcb_tools.addressLines(x.Issuer, 'AddressPost', 'ClientRegion'),od.tcb_tools.addressLines(x.Issuer, 'AddressFact', 'ClientRegion'),getregionNBKI_tcb(substr(od.GetObjectCode(C.Classified,20,to_date('31/12/2013','dd/mm/yyyy'),0),0,2),to_date('31/12/2013','dd/mm/yyyy')))

CLIENTANKETA.1000062175.1000062178
lineCode lc, questValue qv
select * from ReportSchema where classified = 1000062175
select * from lineCode where ReportSchema = 1000062175

od.getregion

select * from clientregiontree 

select * from client

select * from depo where classified = 152111740
select *from depoaccount where depo = 152111740

SELECT  od.clientlabel(D.Client) as ClName, D.CLASSIFIED, DpT.ConstType nPrizn, 
       nvl(od.ObjAttr.GetOneProp(D.Client,PropClass(6),to_date('31/12/2013','dd/mm/yyyy')),1) nPriznRez,
       nvl(od.GetClientIsPhys(D.Client),0) nPriznFiz
   FROM  Depo D, DocTree DT, DepoType DpT
   WHERE  DpT.IsService = 0 
   and    DT.Classified=D.doc
   and    nvl(DT.Validtodate,to_date('31/12/2013','dd/mm/yyyy')+1) >= to_date('31/12/2013','dd/mm/yyyy')
   and    DT.Validfromdate < to_date('31/12/2013','dd/mm/yyyy')
   and    DT.DocState in /*(Constants.State_Start,Constants.State_Close)*/(1000000039,1000000035)
   and    DT.SysFilial = 1
   and    D.Type = DpT.Classified
   and    DpT.ISACTIVE = 0
   --and    DpT.ConstType <> 7
   and nvl(od.GetClientIsPhys(D.Client),0) = 1
   Group BY DpT.ConstType,
       nvl(od.ObjAttr.GetOneProp(D.Client,PropClass(6),to_date('31/12/2013','dd/mm/yyyy')),1),
       nvl(od.GetClientIsPhys(D.Client),0), D.Client,  D.CLASSIFIED



----------------------------------------------------------------------------------
--11/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил для Герасимовой дату старта начисления процентов по векселю 00017
select * from bill where num = '00017' and classified = 1382734758
update bill set percentdate = to_date('11072147','ddmmyyyy') where num = '00017' and classified = 1382734758

-- правил два погашения валютных векселей от 28/05/2014 (проставил цены векселей в операции), по просьбе Сиротиной                                                   ++ 

select * from billoper where doc in (269472983, 269462758) -- 300787.50 + 117.42 -- 65562.50 + 25.6
select rowid, br.* from billrange br where doc in (269472983, 269462758) 
update billoper set opersum = 300787.50 + 117.42, sumfrom = 300787.50 + 117.42, sumto = 300787.50 + 117.42 where doc = 269462758
update billoper set opersum = 65562.50 + 25.6, sumfrom = 65562.50 + 25.6, sumto = 65562.50 + 25.6 where doc = 269472983

select * from billoper where doc in (273741356)
select * from billrange where doc in (273741356)

----------------------------------------------------------------------------------
--14/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

select * from pub_setup where parameter_code like '%DB%'

select * from billoper where doc = 276737931

select * from lic_bus_matrix

--alter table LIC_BUS_MATRIX add END_LIC_DATE date default to_date('01.01.2999', 'fmDD.MM.YYYY');
--comment on column LIC_BUS_MATRIX.END_LIC_DATE is 'Дата, до которой действует лицензия';

select * from lineCode lc
      where lc.reportSchema = 1000062165
      
      select * from depo
      select * from depoaccount
      select * from depostatus
      select * from client
      select 

----------------------------------------------------------------------------------
--15/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- проблемы у Бакумцевой с FX от 10/07/2014 с Радико                                                                                                                +-
---- сделать счета 933*00033 и 963*00033 реестровыми                                                                                                                ++
---- сделать из счетов 933*00033 и 963*00033 цепочки                                                                                                                ++
---- подвязать под сделку счета 93304*00033 и 96304*00033                                                                                                           ++
---- разобраться с остатками на реестрах                                                                                                                            --
---- в головном "Переводе по срочным" под сделкой договорились ничего не исправлять (хотя там должны быть счета 93304*00033 и 96304*00033) 

select * from account where code = '96307978600000001203'
select * from accountwithreestr where account = 209771898

select * from account where code = '93301810200000000033'
select * from accountwithreestr where account = 276334439

select * from dealaccount where doc = 276324578
update dealaccount set account = 276681512 where doc = 276324578 and account = 276334439
update dealaccount set account = 276683050 where doc = 276324578 and account = 276334658

268487075
select * from accountwithreestr where account = 209774297
select * from reestr where accountwithreestr = 1218145660 and reestrinit = 268495885
select * from reestrdoc where accountwithreestr = 1218145660 

bbr.BBR_TCB_STD_RATE

-- проблемы с нумерацией счетов по векселям (Герасимова, Рыжова)                                                                                                    +-
-- пеоверил счета 52406 с 14/07/2014 и мсключил их из процедуры DPC_TCB_CreateBillAcc                                                                               ++
-- проверить счета 523* и 52501* с 14/07/2014 до выдачи векселя 0000019                                                                                             --
-- реализовать нумератор для счетов 52501* по процентам, чтобы не подтягивались старые счета                                                                        --

od.DPC_TCB_CreateBillAcc
select to_date('10/10/2014','dd/mm/yyyy') - to_date('14/07/2014','dd/mm/yyyy') from dual 

----------------------------------------------------------------------------------
--16/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил отчет BBR_TCB_BILLOWN_MFSO_REP_NEW для Огневой Т.С. по задаче IPI 198535 (расширил столбец Филиал и обрезал его содержимое)                                ++
-- также добавил пустые столбцы                                                                                                                                      ++ 
BBR_TCB_BILLOWN_MFSO_REP_NEW

bbr.BBR_TRADE_INSTR33_1100_DEPOTCB

----------------------------------------------------------------------------------
--18/07/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------


od.GET_TCB_BILLACCOUNTLABEL -- чуть правил по письму Рыжовой

-- поправить для Бакумцевой отчет  в RN "Отчеты - Афина - БэкОфис – Реестр сделок по привлечению МБК за период" по задаче IPI 196265                                 --

----------------------------------------------------------------------------------
--04/08/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

od.reestr
select * from account where code = '47426840850000003475' 
select * from accountwithreestr where account = 270868838
select * from reestr where accountwithreestr = 1370286971

-- правил отчет Отчет_финдеп(привлечение) для Огневой по задаче IPI 199076 убрал +1 при вычислении курса => тестят                                                   +-

od.getregioncl2_tcb
od.getregionNBKI_tcb

bbr.BBR_TCB_DEPO_FAS

select * from clientregiontree where classified = 1000043360

CREATE OR REPLACE Function getregioncl2_tcb(idClient Client.Classified%type) Return Clientregiontree.Classified%Type
/*********************************************************
    04.08.2014 - Панфилов М.С. -  функция возвращает classified региона по клиенту (если lev = 2, то берем родительский регион)
*********************************************************/
As
    nRegion Clientregiontree.Classified%Type;      -- регион
    idRegion Clientregiontree.Classified%Type;
    nLev Clientregiontree.Lev%Type;
Begin
    begin
    Select Classified, Lev Into idRegion, nLev from clientregiontree where classified in (select
    ClientRegion
    from Client Where Classified = idClient);
    Exception When others Then null;
    end;

    if nRegion is null then
    Select Classified, Lev Into idRegion, nLev from clientregiontree where classified in (select
    coalesce(od.tcb_tools.addressLines(idClient, 'AddressJur', 'ClientRegion'),od.tcb_tools.addressLines(idClient, 'AddressPost', 'ClientRegion'),od.tcb_tools.addressLines(idClient, 'AddressFact', 'ClientRegion'))
    from Client Where Classified = idClient);
    end if;

    if idRegion = 1000043360 then
      Select Classified, Lev Into idRegion, nLev from clientregiontree where classified = (select clientregion from client where classified = idClient);
    end if;

    if nLev = 2 then
       Select classified Into nRegion from clientregiontree where classified = (select Parent from clientregiontree where classified = idRegion);
    else
       Select classified Into nRegion from clientregiontree where classified = idRegion;
    end if;

Return nRegion;

Exception When others Then
    Return Null;
end getregioncl2_tcb;

CREATE OR REPLACE Function getregionNBKI_tcb(nCode BankCode.Code%type, nDate date) Return Clientregiontree.Classified%Type
/*********************************************************
    04.08.2014 - Панфилов М.С. -  функция возвращает classified региона по коду НБКИ
*********************************************************/
As
    nRegion Clientregiontree.Classified%Type;        -- регион
Begin
  select (select classified from clientregiontree where classified = bc.client) into nRegion
  from od.BankCode bc where codesystem = 1075366264 and code = nCode and nDate >= nvl(validfromdate,MIN_DATE) and nDate < nvl(validtodate,MAX_DATE);

Return nRegion;

Exception When others Then
    Return Null;
end getregionNBKI_tcb;

----------------------------------------------------------------------------------
--05/08/2014----------------------------------------------------------------------
----------------------------------------------------------------------------------

-- правил отчет BBR_TCB_BILL_NOVACIA и соответствующий шаблон Word для Герасимовой по задаче IPI 200588                                                              --

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- Prezayavka 2013 ---------------------------------------------------------------                                                                                   --
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- IPI 156300 
-- IPI задачи по websphera
-- 38957
-- 47521
-- 56205
-- 83795

-- доработка:                                                                                                                                                     --  

--- по главной таблице:                                                                                                                                           +-
---- не выводятся данные в столбце "Статус"                                                                                                                       ++
---- не выводятся данные в столбце "Время звонка"                                                                                                                 ++
---- не выводятся данные в столбце "Встреча"                                                                                                                      ++
---- coloring в главной таблице => доделать "Черный список"                                                                                                       +-
---- неидеально работает paginator на главной таблице(не показываются записи, когда выделена строка и переходим на др. страницу, приходится нажимать refresh) =>    
---  => оказывается проблема из-за стартовой сортировки на главной таблице => убрал стартовую сортировку                                                          ++

--- по закладкам на главной странице:                                                                                                                             +-
---- на закладке "Анкета": сделать отображение данных через TWebAnketaBean                                                                                        ++
---- по закладке "Статус": добавить поля (3 статуса, Siebel, встреча)                                                                                             ++
---- сделать закладку "Черный список"                                                                                                                             --
                                                                                                                                                      
--- редактирование заявки:                                                                                                                                        --
---- открытие диалога по dblClick                                                                                                                                 ++
---- не обновляются поля после повторного открытия диалога => стал использовать tRequestBean.selectedReq вместо tRequestBean.selectedReqG на диалоге редактирования
---- заявки                                                                                                                                                       ++
---- нет изменений в списке заявок после изменения заявки -> пока полный refresh (хотя скорее всего проблема из-за вылета по причине некорректного маппинга) => 
---- стал использовать tRequestBean.selectedReq вместо tRequestBean.selectedReqG на диалоге редактирования заявки, без refresh                                    ++
---- проблема в comboboxes "после выбора нового значения, в главной таблице ....." => пришлось написать findProNameTrim()                                         ++
---- не сохраняются в базу значения из comboboxes => осталась проблема с пустым значением => пришлось добавить в поиске "selectedReqG.setProID(-1)"               ++
---- при изменении "Продукта" должен меняться "Тип" => добавил "Тип" в selectedReqG                                                                               ++
---- не показывается значение из БД в combobox для Source (для Product - работает) => потому что в таблице Source нет таких данных => добавил в setComboBoxes(ReqG g)
---- setSelectedSrc(g.getSource());                                                                                                                               ++
---- синхронизировать список полей на форме диалога по новой версии => (не нашел в БД "Тип клиента") !!!сделал пока только до Тарифа (+ Валюта)!!!                --
---- валидация на клиенте через growl                                                                                                                             --
---- похоже, что при редактировании заявки должны генериться и корректно отображаться "звонки"                                                                    --
----

--- проверить поле ДО на закладке "Статус"                                                                                                                        --

--- ввод новой заявки                                                                                                                                             +-
---- почему-то не работает, хотя аналогичный ввод звонка работает !!! -> проблема решилась пересмотром куска в xhtml ->
---- (вероятно раньше я остановился именно на этом месте) -> последним возвращал кусок "Отчество..." в результате съехала разметка (проблема только в Chrome) !!! +- 

--- ввод нового звонка                                                                                                                                            --
----                                                                                                                                                              --

--- фильтры главного запроса:                                                                                                                                     --
---- фильтр дат                                                                                                                                                   ++
---- comboBox фильтр                                                                                                                                              --
---- автообновление                                                                                                                                               --

--- импорт                                                                                                                                                        --
--- экспорт                                                                                                                                                       --
--- сигналы БКИ                                                                                                                                                   --

----------
-- мелкие проблемы:                                                                                                                                               --
--- очень большой шрифт в календарях                                                                                                                              --

----------
-- перейти на primefaces 4.0                                                                                                                                      ++
-- переходы стрелками клавиатуры по списку главной таблицы                                                                                                        --
-- есть подозрения, что протухает сессия, и пропадают данные с главной таблицы. нужно сделать, чтобы сессия корректно протухала в интерфейсе =>
-- настройка в web.xml session-config (пока session-timeout = 30 мин.) и error-page 504 =>                                                                        --
-- аутентификация	-> пока с вводом доменных пользователя и пароля                                                                                                 +-
-- тесты с двух браузеров                                                                                                                                         --  

---------- доработки 2014                                                                                                                                         --
--- обязательные поля                                                                                                                                             --
--- автооткрытие по условию (по времени) диалога редактирования заявок                                                                                            -- 

---------- быстродйствие
-- разобраться с lazy loading на главной таблице                                                                                                                  --
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
